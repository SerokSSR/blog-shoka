{"pages":[{"title":"AS FOR ME","text":"Shiro: /ʃɪrɒ/ or しろ 游戏热爱者 创作者 OIer INFP-T 与 ENFP-T 反复横跳 村上春树 | 汪曾祺 | 现当代中国文学 许嵩 | 方大同 | 周杰伦、陶喆 | 千禧后华语流行 2022 高考 信息与计算科学 | PKU 现居天津 | 来自天津 | 咸鱼批发公司 | 学生","link":"/about/"},{"title":"分类","text":"","link":"/categories/"},{"title":"留言板","text":"","link":"/messageboard/"},{"title":"标签","text":"","link":"/tags/"},{"title":"友链清理记录","text":"友链被对方单向删除：安河桥北以北bx%%%g.cn；纵饮孤独z%%d.site； 网站无法访问：保温杯的小站fu%%%%%ye.ga； 博客文章抄袭：笔记b%%%te.cn； 对方暂时未更换链接： site: 栖枝 perchurl: https://520526.xyzimage: https://cdn.jsdelivr.net/gh/tperch/jsd/ico/20200505043817.jpgdesc: 用心创造设计，改变生活 site: 幕光倾城image: https://s1.ax1x.com/2020/05/15/YymjXQ.jpgurl: https://www.meilinfeng.topdesc: 钝学累功，勤能补拙 从本站撤下搬到洛谷上了### OIers site: SerokSSRurl: https://www.luogu.com.cn/user/125032image: https://cdn.jsdelivr.net/gh/SerokSSR/cdn2/k16.pngdesc: 九死南荒吾不恨，兹游奇绝冠平生 site: SiRiehn_nxurl: https://www.luogu.com.cn/user/232125image: https://cdn.luogu.com.cn/upload/usericon/232125.pngdesc: 从开始的连名带姓到最后的连名带姓 site: SingerCoderurl: https://www.luogu.com.cn/user/239241image: https://pic1.zhimg.com/v2-e2eea91387bfbe1cc181ec5db67b429c_xl.jpgdesc: In solitude, where we are least alone. 暂时无法接通 site: Aurora’surl: https://blog.th**--***--is52.cnimage: https://cdn.jsdelivr.net/gh/52assert/CDN/img/2020*****--0711202438.jpgdesc: 偷偷厉害 万物尽可期待！ site: Ky**––inurl: https://ww––howimage: https://ww–***–atar.jpgdesc: 学习不易，努力努力~ site: Qing Sh*––eng url: https://www.on––esite.pro desc: 努力的小白 image: https://www.o––nes–*–ite.pro/img/avatar.png site: Z*––ANurl: https://zeh––yz/image: https://gitee–***–er/images/PT0.jpgdesc: 没有撤退可盐！ site: 木叶*–– | Daimon’s Blogurl: https://blo––agluntan.cnimage: http://q––.qlogo.cn/g?b=qq&amp;nk=2247481637&amp;s=100desc: 生命不息–*–腾不止！","link":"/errors/"},{"title":"友人帐","text":".linkpage ul{color:rgba(255,255,255,.15);}.linkpage ul:after{content:\" \";clear:both;display:block}.linkpage ul li{float:left;width:48%;position:relative;transition:.3s ease-out;border-radius:5px;line-height:1.3;height:90px;display:block;min-width: 15rem;}.linkpage ul li:hover{background:rgba(230,244,250,.5);cursor:pointer}.linkpage ul li a{padding:0 10px 0 90px}.linkpage ul li a img{width:60px;height:60px;object-fit:cover;border-radius:50%;position:absolute;top:15px;left:15px;cursor:pointer;margin:auto;border:none}.linkpage ul li a h4{color:#333;font-size:18px;margin:0 0 7px;padding-left:90px}.linkpage ul li a p{font-size:12px;color:#999;padding-left:90px}.linkpage ul li a h4,.linkpage ul li a p{cursor:pointer;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;line-height:1.4}.linkpage ul li a:hover h4{color:#51aded}.linkpage h3{margin:15px -25px;padding:0 25px;border-left:5px solid #51aded;background-color:#f7f7f7;font-size:25px;line-height:40px} 小嘉的部落格一个爱折腾的Java开发工程师Lete乐特人生只有一次，大胆的生活！！ Heo爱折腾的设计师 YlovexLN 井底之蛙，虽不知大海之宽阔，却知晓天空之蓝！ Jared h🤪🤪🤪 小N同学青石落晚巷 故人未还乡 Sitoi活到老，学到老 大白萝卜一只爱吃兔子的萝卜🥕 HelloWorld不知道呢┑(￣Д ￣)┍ Colsrch愿多年以后，我可以酌一杯清酒，烂醉如泥，梦中回到我们的曾经。 ConstOwn能与你一起成长，我荣幸之至。 PluShine分享小白也能看懂的博客教程 煎鱼的海人之帅，莫过于煎鱼 圣文のblog学深夜的习，读清晨的书 Sakura` Blogs或苦或甜都不要辜负 忧郁的派大星越学习，越发现自己的无知 hfzvictory深自缄默，如云漂泊 王稻草就是很喜欢啊 曦秋的小屋 西交的学术小垃圾 羿潇贤鱼为之则易，不为则难。 Khighness炒菜 K 殿下 我的信息1234site: Shiro's Shelfurl: https://snow.js.org/image: https://snow.js.org/img/share.jpgdesc: 辉星皓夜苍千顷，此宵风醉月舞萤 交换友链请先添加本站，并按如下格式在留言板留言。 有无独立域名均可；有一定数量的原创文章。 不定期检查友链。如果被误清理，请重新申请。 请提供站点的名称、链接、描述与图标。","link":"/friends/"}],"posts":[{"title":"D2T1：贪心、二分、并查集","text":"一些技巧常见的贪心技巧货币使用问题：尽可能少用，那么我们就先拿面值最大的，依次往下走，最后拿光了即可。 区间调度问题：工作时间不能重叠，在可选工作中，每次都选取结束时间最早的作为选择，可以使工作量最大。 切题小技巧 递归，从后向前 预处理 划分子结构 单调队列、滑动窗口 能剪的枝一定要减！能剪的枝一定要减！能剪的枝一定要减！ 但是剪枝别剪挂了…… 手动扩栈编译时指定参数 1-Wl,--stack=size size是栈的大小，单位为字节。 一些题P5686 [CSP-SJX2019]和积和123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int N = 500005, P = 1e9+7;int n;ll a[N], b[N], sa[N], sb[N], s[N], ssa[N], ssb[N];int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, a+i); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, b+i); ll ans = 0, s = 0, sa = 0, sb = 0; for(int i=n; i&gt;=1; --i) { sa += a[i]*(n+1-i)%P; sa%=P; sb += b[i]*(n+1-i)%P; sb%=P; ll del = ((a[i]*sb%P + b[i]*sa%P)%P + P - a[i]*b[i]%P*(n-i+1)%P)%P; s += del; s %= P; ans += s; ans %= P; } printf(&quot;%lld\\n&quot;, ans); return 0;} U129453 「EZEC-4.5」占座位题解 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;map&lt;ll, ll&gt; f;ll n, k;ll dfs(ll n) { if(f[n]) return f[n]; if(n &lt; 2*k+2) return f[n] = 1; return f[n] = dfs(n/2) + dfs(n-n/2);}int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); if(k == 0) printf(&quot;%lld\\n&quot;, n); else printf(&quot;%lld\\n&quot;, dfs(n)); return 0;} P1182 数列分段 Section II12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int N = 1e5 + 10;int n, m; ll a[N];bool check(ll v) { ll sum = 0, pt = 0; int i=1; while(i&lt;=n) { while(i&lt;=n &amp;&amp; sum + a[i] &lt;= v) { sum += a[i]; ++i; } ++pt; if(pt &gt; m) return false; sum = 0; } return true;}int main() { //freopen(&quot;p1182_1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); ll l=1, r=1e9; for(int i=1; i&lt;=n; ++i) { scanf(&quot;%lld&quot;, a+i); l = max(l, a[i]); } while(l &lt; r-1) { ll mid = l+(r-l)/2; if(check(mid)) r=mid; else l=mid+1; } if(check(l)) printf(&quot;%lld\\n&quot;, l); else printf(&quot;%lld\\n&quot;, r); return 0;} P2822 [NOIP2016提高组]组合数问题1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 2200, INF = 0x3f3f3f3f;int c[N][N], sum[N][N];int T, k;int main() { scanf(&quot;%d%d&quot;, &amp;T, &amp;k); c[0][0] = 1; for(int i=1; i&lt;=2000; ++i) { c[i][0] = 1; for(int j=1; j&lt;=i; ++j) { c[i][j] = c[i-1][j-1] + c[i-1][j]; c[i][j] %= k; } } for(int i=0; i&lt;=2000; ++i) { for(int j=0; j&lt;=i; ++j) { sum[i][j] = (c[i][j] == 0); } } for(int i=0; i&lt;=2000; ++i) { for(int j=1; j&lt;=2000; ++j) { sum[i][j] += sum[i][j-1]; } } for(int j=0; j&lt;=2000; ++j) { for(int i=1; i&lt;=2000; ++i) { sum[i][j] += sum[i-1][j]; } } while(T--) { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); printf(&quot;%d\\n&quot;, sum[n][min(n,m)]); } return 0;} P1007 独木桥求最大时间时，把碰面想象成交换身份即可 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int l, n, p[5005];int main() { scanf(&quot;%d%d&quot;, &amp;l, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, p+i); int ans1 = 0; for(int i=1; i&lt;=n; ++i) { ans1 = max(ans1, min(p[i], l+1-p[i])); } int ans2 = 0; for(int i=1; i&lt;=n; ++i) { ans2 = max(ans2, max(p[i], l+1-p[i])); } printf(&quot;%d %d\\n&quot;, ans1, ans2); return 0;} P3958 [NOIP2017提高组]奶酪自底至上找出通路，可以联想到森林合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1100;struct node { LL x, y, z;} a[N];bool cmp(node a, node b) { return (a.z &lt; b.z);}bool tp[N], bt[N];int fa[N], T, n;LL h, r;int root(int x) { return fa[x]==x?x:root(fa[x]);}bool check(int i, int j) { LL dist = (a[i].x-a[j].x)*(a[i].x-a[j].x) + (a[i].y-a[j].y)*(a[i].y-a[j].y) + (a[i].z-a[j].z)*(a[i].z-a[j].z); return dist &lt;= 4*r*r;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%lld%lld&quot;, &amp;n, &amp;h, &amp;r); memset(bt, false, sizeof bt); memset(tp, false, sizeof tp); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld%lld%lld&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z); sort(a+1, a+n+1, cmp); for(int i=1; i&lt;=n; ++i) { if(a[i].z - r &lt;= 0) bt[i] = true; if(a[i].z + r &gt;= h) tp[i] = true; } for(int i=1; i&lt;=n; ++i) fa[i] = i; for(int i=1; i&lt;=n; ++i) { for(int j=i+1; j&lt;=n; ++j) { if(check(i, j)) { fa[root(i)] = root(j); } } } bool fla = false; for(int i=1; i&lt;=n; ++i) { if(bt[i] &amp;&amp; tp[root(i)]) { fla = true; break; } } printf(&quot;%s&quot;, (fla ? &quot;Yes\\n&quot; : &quot;No\\n&quot;)); } return 0;}","link":"/noip-d2t1/"},{"title":"Hexo：为你的博客配置 PWA","text":"本文以 Butterfly 主题为范例。 使用这个方法之前，请先卸载掉其它的 PWA 插件，并安装 Gulp 和 WorkBox。 12npm install gulp-cli -gnpm install workbox-build gulp --save-dev 本文参考利用 Workbox 实现博客的 PWA和Butterfly进阶教程。 写在前面渐进式网络应用程式（英语：Progressive Web Apps，简称：PWA）是一种普通网页或网站架构起来的网络应用程式，但它可以以传统应用程式或原生移动应用程式形式展示给用户。这种应用程式形态视图将目前最为现代化的浏览器提供的功能与行动装置的体验优势相结合。 当你的网站实现了 PWA，那就代表了 用户可以添加你的博客到电脑/手机的桌面，以原生应用般的方式浏览你的博客 用户本地可以自动生成缓存，二次访问速度大大加快 用户可以离线浏览你的博客 下面的 PWA实现方法借助了 Gulp插件，在站点有内容更新时，可以弹窗提醒用户刷新页面。 开启主题相关设置以 Butterfly 主题为例，在 butterfly.yml 中开启 PWA 选项 实例： 12345678pwa: enable: true manifest: /manifest.json # 清单文件，下文将介绍如何生成 theme_color: &quot;#fff&quot; # 应用程序顶栏的背景色 apple_touch_icon: /img/pwa/apple-touch-icon.png # 添加至苹果移动设备的主屏幕后显示的图标，尽量使用 png 格式 favicon_32_32: /img/pwa/32.png # 32 * 32 像素，网页图标 favicon_16_16: /img/pwa/16.png # 16 * 16 像素，网页图标 mask_icon: /img/pwa/safari-pinned-tab.svg # 苹果电脑 Touch Bar 区域显示的收藏栏封面图，须使用 svg 格式 图片尺寸要求： apple_touch_icon：192 * 192 像素 mask_icon：viewBox的值必须是 0 0 16 16 如果你的主题没有内置PWA，下面附有Butterfly主题的PWA部分，可以根据你所用的主题调整下面的Pug模板，编译后插入到html生成模板的head处。 12345678910111213link(rel=&quot;manifest&quot; href=url_for(theme.pwa.manifest))if(theme.pwa.theme_color) meta(name=&quot;theme-color&quot; content=theme.pwa.theme_color)if(theme.pwa.theme_color) meta(name=&quot;msapplication-TileColor&quot; content=theme.pwa.theme_color)if(theme.pwa.apple_touch_icon) link(rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=url_for(theme.pwa.apple_touch_icon))if(theme.pwa.favicon_32_32) link(rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=url_for(theme.pwa.favicon_32_32))if(theme.pwa.favicon_16_16) link(rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=url_for(theme.pwa.favicon_16_16))if(theme.pwa.mask_icon) link(rel=&quot;mask-icon&quot; href=url_for(theme.pwa.mask_icon) color=&quot;#5bbad5&quot;) 配置 manifest.json创建 manifest.json，路径应与配置文件中所填路径相同。 实例及配置说明： 1234567891011121314151617181920{ &quot;name&quot;: &quot;Serok's Blog&quot;, // 应用全称 &quot;short_name&quot;: &quot;Seeker&quot;, // 应用简称 &quot;theme_color&quot;: &quot;#49b1f5&quot;, // 应用主题色 &quot;background_color&quot;: &quot;#49b1f5&quot;, // 加载应用时的背景色 &quot;display&quot;: &quot;minimal-ui&quot;, // 首選顯示模式 //更多顯示模式：&quot;fullscreen&quot;, &quot;standalone&quot;, &quot;browser&quot; &quot;scope&quot;: &quot;/&quot;, &quot;start_url&quot;: &quot;/&quot;, &quot;icons&quot;: [ // 指定 icons 參數，用來適配不同設備 // 需為 png 格式，至少包含一个 192 * 192 像素的圖標 { &quot;src&quot;: &quot;https://snow.js.org/image/pwaicons/192.png&quot;, // 建议采用绝对路径 &quot;sizes&quot;: &quot;192x192&quot;, &quot;type&quot;: &quot;image/png&quot; } ], &quot;splash_pages&quot;: null // 自定義启动动画} default Hexo采用的是严格 Json规范，因此 manifest.json 文件配置好后，需删除文件中的所有注释。 安装插件在命令行中输入 1npm install workbox-build gulp --save-dev 创建 gulpfile.js 文件在博客的根目录下，创建一个 gulpfile.js 文件 123456789101112131415161718const gulp = require(&quot;gulp&quot;);const workbox = require(&quot;workbox-build&quot;);gulp.task('generate-service-worker', () =&gt; { return workbox.injectManifest({ swSrc: './sw-template.js', swDest: './public/sw.js', globDirectory: './public', globPatterns: [ &quot;**/*.{html,css,js,json,woff2}&quot; ], modifyURLPrefix: { &quot;&quot;: &quot;./&quot; } });});gulp.task(&quot;build&quot;, gulp.series(&quot;generate-service-worker&quot;)); 创建 sw-template.js 文件在博客的根目录下，创建一个 sw-template.js 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const workboxVersion = '5.1.3';importScripts(`https://storage.googleapis.com/workbox-cdn/releases/${workboxVersion}/workbox-sw.js`);workbox.core.setCacheNameDetails({ prefix: &quot;Serok's Blog&quot;});workbox.core.skipWaiting();workbox.core.clientsClaim();workbox.precaching.precacheAndRoute(self.__WB_MANIFEST,{ directoryIndex: null});workbox.precaching.cleanupOutdatedCaches();// Imagesworkbox.routing.registerRoute( /\\.(?:png|jpg|jpeg|gif|bmp|webp|svg|ico)$/, new workbox.strategies.CacheFirst({ cacheName: &quot;images&quot;, plugins: [ new workbox.expiration.ExpirationPlugin({ maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 }), new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }) ] }));// Fontsworkbox.routing.registerRoute( /\\.(?:eot|ttf|woff|woff2)$/, new workbox.strategies.CacheFirst({ cacheName: &quot;fonts&quot;, plugins: [ new workbox.expiration.ExpirationPlugin({ maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 }), new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }) ] }));// Google Fontsworkbox.routing.registerRoute( /^https:\\/\\/fonts\\.googleapis\\.com/, new workbox.strategies.StaleWhileRevalidate({ cacheName: &quot;google-fonts-stylesheets&quot; }));workbox.routing.registerRoute( /^https:\\/\\/fonts\\.gstatic\\.com/, new workbox.strategies.CacheFirst({ cacheName: 'google-fonts-webfonts', plugins: [ new workbox.expiration.ExpirationPlugin({ maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 }), new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }) ] }));// Static Librariesworkbox.routing.registerRoute( /^https:\\/\\/cdn\\.jsdelivr\\.net/, new workbox.strategies.CacheFirst({ cacheName: &quot;static-libs&quot;, plugins: [ new workbox.expiration.ExpirationPlugin({ maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 }), new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }) ] }));workbox.googleAnalytics.initialize(); 注意：把 prefix 修改为你博客的名字（最好用英文）。 上面的文件涵盖了大多数资源的缓存策略。如果你想缓存其他类型的资源（例如一些国内的镜像 CDN 库），或者想使用其他的缓存方式，请自行查看相关文档并添加。 添加 js 进主题配置 butterfly.yml, 添加需要的 css 和 js 12345inject: head: - '&lt;style type=&quot;text/css&quot;&gt;.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}&lt;/style&gt;' bottom: - '&lt;div class=&quot;app-refresh&quot; id=&quot;app-refresh&quot;&gt; &lt;div class=&quot;app-refresh-wrap&quot;&gt; &lt;label&gt;✨ 网站已更新最新版本 👉&lt;/label&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;location.reload()&quot;&gt;点击刷新&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t=&quot;light&quot;===document.documentElement.getAttribute(&quot;data-theme&quot;)?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:&quot;已更新最新版本&quot;,backgroundColor:t,duration:5e5,pos:e,actionText:&quot;点击刷新&quot;,actionTextColor:&quot;#fff&quot;,onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${&quot;light&quot;===document.documentElement.getAttribute(&quot;data-theme&quot;)?&quot;#49b1f5&quot;:&quot;#1f1f1f&quot;};`;document.getElementById(&quot;app-refresh&quot;).style.cssText=o}}&quot;serviceWorker&quot;in navigator&amp;&amp;(navigator.serviceWorker.controller&amp;&amp;navigator.serviceWorker.addEventListener(&quot;controllerchange&quot;,function(){showNotification()}),window.addEventListener(&quot;load&quot;,function(){navigator.serviceWorker.register(&quot;/sw.js&quot;)}));&lt;/script&gt;' 同样，如果你使用的不是Butterfly主题，可以在所示代码的基础上修改以适配你的主题。以下是展开后的代码，便于修改调试。 以下代码请插入到头部 &lt;/head&gt; 之前：1234567891011121314151617181920212223242526&lt;style type=&quot;text/css&quot;&gt; .app-refresh { position: fixed; top: -2.2rem; left: 0; right: 0; z-index: 99999; padding: 0 1rem; font-size: 15px; height: 2.2rem; transition: all 0.3s ease; } .app-refresh-wrap { display: flex; color: #fff; height: 100%; align-items: center; justify-content: center; } .app-refresh-wrap span { color: #fff; text-decoration: underline; cursor: pointer; }&lt;/style&gt; 以下代码请插入到底部 &lt;/body&gt; 之前：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div class=&quot;app-refresh&quot; id=&quot;app-refresh&quot;&gt; &lt;div class=&quot;app-refresh-wrap&quot;&gt; &lt;label&gt;✨ 网站已更新最新版本 👉&lt;/label&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;location.reload()&quot;&gt;点击刷新&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; if ('serviceWorker' in navigator) { if (navigator.serviceWorker.controller) { navigator.serviceWorker.addEventListener('controllerchange', function () { showNotification() }) } window.addEventListener('load', function () { navigator.serviceWorker.register('/sw.js') }) } function showNotification() { if (GLOBAL_CONFIG.Snackbar) { var snackbarBg = document.documentElement.getAttribute('data-theme') === 'light' ? GLOBAL_CONFIG.Snackbar.bgLight : GLOBAL_CONFIG.Snackbar.bgDark var snackbarPos = GLOBAL_CONFIG.Snackbar.position Snackbar.show({ text: '已更新最新版本', backgroundColor: snackbarBg, duration: 500000, pos: snackbarPos, actionText: '点击刷新', actionTextColor: '#fff', onActionClick: function (e) { location.reload() }, }) } else { var showBg = document.documentElement.getAttribute('data-theme') === 'light' ? '#49b1f5' : '#1f1f1f' var cssText = `top: 0; background: ${showBg};` document.getElementById('app-refresh').style.cssText = cssText } }&lt;/script&gt; 运行为了方便每次部署，可以在你的博客根目录下新建 deploy.sh，添加以下内容： 123456789#!/bin/shecho &quot;Start&quot;hexo cleanhexo generategulphexo deployecho &quot;Finish&quot;echo 按任意键继续read -n 1 然后每次部署就可以直接运行这个脚本了。","link":"/hexo-gulp-pwa/"},{"title":"Butterfly：添加全局吸底 Aplayer 播放器","text":"以下步骤在 Butterfly主题上可以正常生效。如果你使用的是其他主题，可以根据情况自行适配。 配置播放器解决与 hexo-tag-aplayer 的兼容问题如果你没有安装过 hexo-tag-aplayer 插件，请直接跳过该步骤。 如果你安装过 hexo-tag-aplayer，请在 Hexo 的配置文件中修改以下设置： 123aplayer: meting: true asset_inject: false 开启主题的 aplayerInject 选项在主题配置文件中，enable和per_page均设为true： 1234# Inject the css and script (aplayer/meting)aplayerInject: enable: true per_page: true 插入 Aplayer 代码插入到主题配置文件的 inject.bottom。 示例代码： 1234inject: ... bottom: - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;000PeZCQ1i4XVs&quot; data-server=&quot;tencent&quot; data-type=&quot;artist&quot; data-fixed=&quot;true&quot; data-mini=&quot;true&quot; data-listFolded=&quot;false&quot; data-order=&quot;random&quot; data-preload=&quot;none&quot; data-autoplay=&quot;true&quot; muted&gt;&lt;/div&gt; 参数解释： option default description data-id require song id / playlist id / album id / search keyword data-server require music platform: netease, tencent, kugou, xiami, baidu data-type require song, playlist, album, search, artist data-autoplay false audio autoplay data-theme #2980b9 main color data-loop all player loop play, values: ‘all’, ‘one’, ‘none’ data-order list player play order, values: ‘list’, ‘random’ data-preload auto values: ‘none’, ‘metadata’, ‘auto’ data-volume 0.7 default volume, notice that player will remember user setting, default volume will not work after user set volume themselves data-mutex true prevent to play multiple player at the same time, pause other players when this player start play data-lrctype 0 歌词来源方式，一般不更改 data-listfolded false indicate whether list(指播放列表，不是播放器) should folded at first data-listmaxheight 340px list max height data-storagename metingjs localStorage key that store player setting :::warning 注意： data-id、data-server 和 data-type 必须配置 data-fixed 和 data-mini 参数不要更改::: 运行Hexo就可以看到网页左下角出现了Aplayer。 如果你想切换页面时音乐不中断，请把主题配置文件的 pjax 设为 true。 UI 调整调整右下角回到顶部等按钮按照上面的步骤设置完成后，浏览器左下角会出现 Aplayer。在手机端浏览博客时，如果展开播放器，会将右下角按钮遮住。 在Butterfly配置文件中，调整 rightside-bottom 选项： 12# the position of bottom right button; default unit: px (右下角按鈕距離底部的距離，默認單位為 px)rightside-bottom: 80px 调整 TOC 目录按钮打开文章页面时，你会发现打开 Toc 目录的按钮被遮挡了。我们需要修改 CSS 来改变按钮的位置。 请在主题配置文件中，将这段代码添加到 inject 去： 123inject: head: - '&lt;style type=&quot;text/css&quot;&gt;#toggle-sidebar {bottom: 80px}&lt;/style&gt;' 调整 Aplayer 收回方式如果你觉得Aplayer占地太大，影响正常阅读，可以设置Aplayer收回时将音乐Cover也隐藏掉，只留下右侧的箭头栏。 请在主题配置文件中，将这段代码添加到 inject 去： 123inject: head: - '&lt;style type=&quot;text/css&quot;&gt;.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}&lt;/style&gt;' 调整 APlayer 歌词显示Aplayer的歌词默认在底部正中显示，也会遮挡一些内容。当然我们可以通过调整相应内容高度的方式来解决，但是如果可以设置歌词默认不显示，效果可能会更好。 解决方案：修改Butterfly配置文件中的 CDN.meting_js 配置，将CDN链接替换即可。 1234567CDN: ... # aplayer aplayer_css: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css aplayer_js: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js- meting_js: https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js+ meting_js: https://cdn.jsdelivr.net/gh/SerokSSR/cdn/meting.min.js","link":"/butterfly-aplayer/"},{"title":"About CODESTYLE","text":"Commit 命名规范 feat: 一个新功能 fix: 一个 bug 修复 docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等 style: 不影响代码逻辑的修改，比如空格、格式缩进、删除分号等 refactor: 代码重构 perf: 提升性能的改动 test: 增加或修改测试 chore: 改变构建流程、或者增加辅助工具、依赖库等 码风 凡继承自 C 语言的库，均使用 &lt;xxx.h&gt; 而不是 &lt;cxxx&gt; 。 以下情况中，运算符前后 一定 不加空格： for 循环括号内内容较短时（**e.g.** for(int i=1; i&lt;=n; ++i) ） 运算符前后关系较密切时 以下情况中，运算符前后 一般 不加空格： 变量名长度为 1 时 以下情况中，运算符前后 很可能 不加空格： 考试即将结束时 以下情况中，运算符前后 不可能 不加空格： 除以上情况之外的所有情况 typedef long long ll 。 e.g.（ 2-SAT 模板节选） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int N = 2e6 + 10;struct node { int u, v, next; node() {} node(int _u, int _v, int _next): u(_u), v(_v), next(_next) {}} e[N];int h[N], tot = 0;void add(int u, int v) { e[++tot] = node(u, v, h[u]); h[u] = tot;}int dfn[N], low[N], tag = 0;int id[N], num = 0;stack&lt;int&gt; s;int n, m;void tarjan(int u) { dfn[u] = low[u] = ++tag; s.push(u); for(int i = h[u]; i; i = e[i].next) { int v = e[i].v; if(dfn[v]) { if(!id[v]) low[u] = min(low[u], dfn[v]); } else { tarjan(v); low[u] = min(low[u], low[v]); } } if(dfn[u] == low[u]) { id[u] = ++num; for(; s.top() != u; s.pop()) id[s.top()] = num; s.pop(); }}int main() { freopen(&quot;p4782.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1, _i, a, _j, b, u, v; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;_i, &amp;a, &amp;_j, &amp;b); u = (_i-1)*2 + a, v = (_j-1)*2 + b; add(u^1, v); add(v^1, u); } for(int i=0; i&lt;(n&lt;&lt;1); ++i) if(!dfn[i]) tarjan(i); for(int i=0; i&lt;(n&lt;&lt;1); i+=2) { if(id[i] == id[i^1]) { printf(&quot;IMPOSSIBLE\\n&quot;); return 0; } } printf(&quot;POSSIBLE\\n&quot;); for(int i=0; i&lt;(n&lt;&lt;1); i+=2) printf(&quot;%d &quot;, id[i] &lt; id[i^1] ? 0 : 1); return 0;}","link":"/about-codestyle/"},{"title":"Hexo：将你的博客部署到 Vercel","text":"写在前面近些日子，静态网站的热度又渐渐高了起来。相比于动态网站，静态网站具有轻量、无需服务器、利于SEO、速度快等特点，非常适合个人博客。再加上Hexo、Hugo等静态博客渲染框架的日渐成熟，已能与Wordpress、Typecho等老牌动态博客框架分庭抗礼。 与此同时，很多静态托管网站也应运而生。各种托管网站看似鱼龙混杂，其实由于各种原因，在国内能用的也就那么几家；如果你像我一样，没有服务器、没有备案，还想白嫖（），那么仅有的选择就更少了。综合各种因素，目前最适合托管静态博客的服务有： GitHub Pages微软旗下，闻名遐迩的全球第一大开源仓库网站。服务器设在荷兰、美国等地。部分地区部分运营商的用户可能遭到DNS污染，无法正常访问。 Gitee PagesOSCHINA旗下，服务器在上海腾讯云，速度较快，较稳定，提供 xxx.gitee.io 域名，不支持免费自定义域名。 旧Coding Pages腾讯旗下，服务器在香港/新加坡腾讯云，速度较快，但稳定性差。部分地区速度极慢或不能访问。支持免费自定义域名。 新Coding Pages与腾讯云绑定食用，功能较齐全，但按量计费。 Vercel原名Zeit，服务器在美国，在港台有CDN节点。速度略慢于Coding，但大部分地区均可正常访问。提供自定义 xxx.now.sh 和 xxx.vercel.app 域名，且支持免费绑定个人域名。 大部分网站采用的一般都是GitHub + Coding双部署的形式。这种方法比较麻烦，需要DNSPod解析，因此需要实名认证，而且还真未必快到那里去。 Colsrch大佬出过一篇三部署教程，使用了Coding（联通线路），Vercel（默认线路），Cloudflare回源GitHub Page（移动线路），速度略有提升，但是门槛较高，对小白并不友好。而且近期Coding似乎越来越不稳定了，所以也不太推荐此方法。 下面是晚上六点左右，Vercel与Gitee的速度对比。和99块钱相比，慢点就慢点吧（ 还是由于某种原因，市面上的Vercel部署教程并不多。而且由于Vercel里的一些操作还是挺不常规的，所以就写了这么一篇文章，说一下将网站部署在Vercel的详细过程。 导入 GitHub 仓库Vercel是一个静态网页部署网站，并不托管代码。因此，我们通过GitHub来托管 hexo deploy 生成的网页文件，并设置自动导入。当你的源代码仓库有变动后，Vercel会第一时间检测到并重新部署网站，部署完成后会通过邮件提醒。 :::default 在开始之前，请准备一个 GitHub账号（注意不能是绑有QQ邮箱的）、一个Git仓库（存储Hexo生成的页面）。 ::: 进入Vercel官网，点击 Continue with GitHub 注意：如果出现下图所示的情况，请确认你的GitHub账号上没有绑QQ邮箱（即便它不是主邮箱）。如果仍然报错，请换用国外邮箱。 授权完成后，选择 Import Git Repository，点击Continue，进入如下界面。输入你的仓库 url（https）。 :::default 如果你配置过 GitHub Pages，那么这个地方直接填入你的 GitHub Pages仓库就可以了。 注意：你生成的页面应推送至 master 分支，而不是 gh-pages 分支。如果你之前设置了多部署，比如： 123456deploy: type: git repo: github: xxx coding: xxx branch: master 请务必将 GitHub 拆出来单独写，就像这样： 1234567deploy:- type: git repo: coding: xxx- type: git repo: git@github.com:xxx/xxx.git branch: master 因为如果按照第一种方式，你的生成页面有一定概率会被推送至 gh-pages 分支（由于 Hexo 的默认设置），导致Vercel无法拉取。::: 导入项目中会弹出一些自定义选项，不知道会出什么锅的话就不要改，顺着右下角的蓝色键一直点，遵照默认选项就可以了。 这里建议选择 All repo，方便后续部署。 部署完成后，Vercel会提供几个默认域名，可以通过 [项目名].[用户名].vercel.app 访问。 自定义域名进入 dashboard，点击[项目卡片] -&gt; View Domains 如果你想使用Vercel提供的二级域名，直接添加 xxx.now.sh（或 xxx.vercel.app，看你想要哪个），如果无人占用，会自动验证成功。 如果你想绑定自己的域名，也是在输入框中输入你想要绑定的网址，点击右侧 Add即可。下方会提示Invalid Config，并给出两种绑定方式（A/CNAME + NS），但是不要听他的，而是请按照下面的方式： 验证方式 如果是根域名，请在你的DNS解析处添加 A记录，指向 76.76.21.21 如果是子域名，请在你的DNS解析处添加CNAME记录，指向 cname.vercel-dns.com 添加记录后等待片刻再刷新，下面显示两个对号即表明验证成功。 重定向如果你绑定了多个域名，可以点击域名卡片右上角的 Edit，将某个域名重定向至你的其他域名。 后话至此Vercel的部署过程就结束了。 :::warning 初次部署后再进入dashboard，可能会偶尔出现配置好的域名显示invalid config的现象，尽管DNS解析是正常的。经博主测试，此状态下网页仍能正常访问（已排除DNS缓存的问题），可能是Vercel面板的bug吧。::: 部署有问题可以到留言板留言，或者直接向 support@vercel.com 发邮件（不清楚能不能用中文），一般一到三天后会回复。","link":"/hexo-vercel/"},{"title":"Hexo：配置 SSH 公钥部署","text":"配置 git 使用 ssh 密钥git 支持 https 和 git 两种传输协议。其实两种方式都可以，但是如果使用https协议，每次pull、push都要输入密码（大部分电脑上），所以建议使用ssh密钥对认证，可实现免密且更加安全。下面将介绍Hexo如何配置 SSH 公钥部署。 示例在Windows环境下。 Step 1：生成密钥对- 进入 C:\\用户\\[你的用户名]/.ssh 文件夹，右键唤出 PowerShell - 输入 ssh-keygen，并一直敲击回车至密钥图生成，可以看到文件夹中多出了两个文件：id_rsa 和 id_rsa.pub 实例： 12345678910111213141516171819202122SerokSSR@Desktop-ABCDEFG ~\\.ssh&gt; ssh-keygen Generating public/private rsa key pair.Enter file in which to save the key (C:\\Users\\SerokSSR/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\SerokSSR/.ssh/id_rsa.Your public key has been saved in C:\\Users\\SerokSSR/.ssh/id_rsa.pub.The key fingerprint is:SHA256:fO7pVFqZ464nC8H6B3pTE8cwPx2mTM0G8KJt7Or2L8o SerokSSR@DESKTOP-ABCDEFGThe keys randomart image is:+---[RSA 2048]----+| ...+ || o.. * || .B.= . || o +..Bo. || S =o*. || ..*o= . || ...o=.. || .o+=+o. || +E*BBo |+----[SHA256]-----+ Step 2：配置远程仓库的公钥- 访问GitHub，点击 头像 -&gt; Settings -&gt; 左侧SSH and GPG keys -&gt; 右上New SSH key - 打开你刚才生成的 /.ssh/id_rsa.pub，把里面的内容全选复制到Key栏中，Title栏可不填 - 点击 Add SSH key，完成添加 Step 3：验证密钥是否生效控制台输入 ssh -T git@github.com，出现如下回复则密钥已生效。 123SerokSSR@DESKTOP-ABCDEFG ~\\.ssh&gt; ssh -T git@github.comHi SerokSSR! Youve successfully authenticated, but GitHub does not provide shell access. Step 4：添加 SSH 仓库在你的博客根目录下的 _config.yml，找到 deploy选项，将你仓库的ssh链接添加至此处。 实例： 1234deploy:- type: git repo: git@github.com:SerokSSR/snow.git branch: master Step 5：配置Hexo部署为了方便每次部署，可以在你的博客根目录下新建 deploy.sh，添加以下内容： 12345678#!echo &quot;Start&quot;hexo cleanhexo generatehexo deployecho &quot;Finish&quot;echo 按任意键继续read -n 1 然后每次部署就可以直接运行这个脚本，而不用每次都要敲一遍 hexo cl&amp;&amp;hexo g&amp;&amp;hexo d了。","link":"/hexo-ssh-deploy/"},{"title":"C++ STL：SET &amp; MULTISET","text":"定义 方式 效果 set &lt;数据类型名&gt; 集合名; 先定义一个容器，容器内无任何元素 set &lt;数据类型名&gt; 集合名(另一个集合名); 定义一个集合并用另一个集合初始化（只能是数据类型相同的集合，不能是数组） set &lt;数据类型名&gt; 集合名(另一个集合名.begin(), 另一个集合名.end()); 定义一个集合并用另一个集合初始化（只能是数据类型相同的集合，不能是数组） set &lt;数据类型名&gt; 集合名[集合数量]; 定义集合数组 set &lt;Elem&gt; 产生一个set，以 (operator &lt;) 为排序准则 set &lt;Elem, cmp&gt; 产生一个set，以cmp为排序准则 操作非变动性操作 操作 效果 c.size() 返回当前的元素数量 c.empty () 判断set是否为空，等同于 c.size() == 0，效率更高 c.max_size() 返回能容纳的元素最大数量 c1 == c2 判断c1是否等于c2 查找set和multiset都是平衡树，$O(\\log n)$ 级别查找。 操作 效果 count(elem) 返回元素值为elem的个数 find(elem) 返回元素值为elem的第一个元素，如果没有返回end() lower_bound(elem) 返回元素值为elem的第一个可安插位置，也就是元素值 &gt;= elem的第一个元素位置 upper_bound(elem) 返回元素值为elem的最后一个可安插位置，也就是元素值 &gt; elem 的第一个元素位置 equal_range(elem) 返回elem可安插的第一个位置和最后一个位置，也就是元素值 == elem的区间 赋值与迭代sets和multisets的迭代器是双向迭代器，对迭代器操作而言，所有的元素都被视为常数，可以确保你不会人为改变元素值，从而打乱既定顺序，所以无法调用变动性算法，如 remove()。 操作 效果 c1 = c2 将c2的元素全部给c1 c1.swap(c2) 将c1和c2 的元素互换 swap(c1, c2) 同上，全局函数 c.begin() 略 c.end() 略 c.rbegin() 略 c.rend() 略 安插和删除元素必须保证参数有效，迭代器必须指向有效位置，序列起点不能位于终点之后，不能从空容器删除元素。 操作 返回值 效果 c.insert(elem) pair &lt;iterator, bool&gt; 插入一个elem副本 c.insert(pos, elem) iterator 安插一个elem元素副本，返回元素的迭代器。pos为搜索起点，提升插入速度。 c.insert(beg,end) void 将区间[beg,end)所有的元素安插到c。 c.erase(elem) 无符号整数 删除与elem相等的所有元素，返回被移除的元素个数。 c.erase(pos) void 移除迭代器pos所指位置元素。 c.erase(beg,end) void 移除区间[beg,end)所有元素，返回 void。 c.clear() void 移除所有元素，将容器清空 set与multiset的异同 set::insert(key) 的返回值是一个 pair&lt;iterator, bool&gt;，其中pair中的bool成员表明了key被插入之前，set中是否已存在相同的key。如果set中已经存在相同key的元素，那么插入操作是会失败的，新的元素不会被插进去。而 multiset::insert(key) 的返回值只是一个iterator，插入操作总是会成功的。 multiset::count(key) 的返回值可能大于1。 multiset::size() 的返回值是multiset中元素的个数，而不是值的个数。比如，{1, 1, 2}的size是3，而不是2。 multiset::erase(key) 会将对应的key全部删掉，所以对{1, 1, 2}调用 erase(1) 之后，它就变成了{2}。 只要key存在于集合中，set::equal_range(key) 的返回值 pair&lt;iterator1, iterator2&gt; 总是会有 ++iterator1 == iterator2。但是对multiset来说就不一定了。","link":"/stl-set/"},{"title":"CF387D","text":"题意分析操作最少的次数，构成有趣图，注意无重边，有向边。 操作分为加边和删边。 有趣图定义 有一个中心，满足此点有自环，且与其他结点有双向边。 除中心点外的结点，满足出度 = 入度 = 2。 算法分析1、仔细分析有趣图的定义，发现如下性质： 中心的边数为 $(n-1)\\times 2+1$，也就是它与其他结点要有双向边再加自己的一个自环，无重边所以构造中心点时不可能做删除操作，只能加边或不操作。 其他结点的出入度为 2，排除掉与中心点连接的双向边，其点的度一定为一进一出。 2、如何判断结点的度满足一进一出。 图一，图二都是满足结点度一进一出。所以 $n$ 个结点需要 $n$ 条相连边（首尾）。 图三不满足，只有两条相连边 $(e_1,e_2)$ 或者选择 $(e_1,e_3)$ 即有用边,还需要添加 $n-2$ 边有用边，同时还要减掉 1 条边，即总边数减去有用边，也就是要删除的无用边。 方法1：拆点，一个点拆为进点和出点，建立二分图。 ​ 左边的点求匹配，最大匹配就是有用的边。 方法2：直接将图看成二分图，利用有向边每个点都求匹配。 3、枚举每个点做中心点。 中心点 V，计算维护中心需要的边 $(n-1)\\times 2+1-\\sum{V发出的边}$ 删除 V 点，也就是包含相应的边 剩下的图，计算最大匹配，满足一进一出的边数需要的操作（添加边 + 删除边）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int N = 550, INF = INT_MAX;vector&lt;int&gt; g[N];int c, n, m;int tag = 0, vis[N], match[N];bool mp[N][N];bool dfs(int u) { for(int i = 0; i &lt; g[u].size(); ++i) { int v = g[u][i]; if(v == c) continue; if(vis[v] == tag) continue; vis[v] = tag; if(match[v] == 0 or dfs(match[v])) { match[v] = u; return true; } } return false;}int best = INF;int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sum0 = 0; for(int i=1, u, v; i&lt;=m; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u].push_back(v); mp[u][v] = true; ++sum0; } for(int i=1; i&lt;=n; ++i) { memset(match, 0, sizeof match); c = i; int ans = 0; int sum1 = 0; for(int j=1; j&lt;=n; ++j) { if(j == c) { if(mp[c][c]) ++sum1; continue; } if(mp[j][c]) ++sum1; if(mp[c][j]) ++sum1; } ans += 2*(n-1) + 1 - sum1; //printf(&quot;ans1 = %d\\n&quot;, ans); //printf(&quot;sum1 = %d\\n&quot;, sum1); int sum2 = 0; for(int j=1; j&lt;=n; ++j) { ++tag; if(j == c) continue; if(dfs(j)) ++sum2; } ans += sum0 - sum1 - sum2 + n-1 - sum2; best = min(best, ans); //printf(&quot;ans2 = %d\\n&quot;, ans); //printf(&quot;sum2 = %d\\n&quot;, sum2); } printf(&quot;%d\\n&quot;, best); return 0;}","link":"/cf387d/"},{"title":"凝眉","text":"他和她走下车。站台上熙熙攘攘的人守望在那里。没有人向他们看上一眼。 他们停下脚步，看着列车消失在金色的反光里，只留下无底的空白。 “所以……新见和五反田他们呢？”高桥问道。 “他们？他们不会来了。”他想了想道。“他们来过这里。” 她点了点头。 “走吧。” 他握住她的手。 他们费力地拨开人群。等他惊觉的时候，那只手已经松开了。他张望着伸长了脖子，似乎想在人海中辨出她的身影，却像极了在水中捞月的猿。 出得车站，迎面便是阵阵狂风。雪浪排空，秋云怒卷。眼见得风越来越大，他跑向公交站，赶上了去往营口道的车。街上行人寥寥，许是都躲进路旁的小店了吧。 离码头不远的地方，他看到了一个女孩，头发披散在肩上，斜挎着包，朝着风来临的方向走去。他只是瞥了她一眼，很快就失去了兴致，目光投向前面的世纪钟和几幢小楼。 高桥匆匆地走着，不安地环顾着周遭的一切。她大致知道这是什么地方了。风卷着沙砾扫过，不舍昼夜。她略略低下头，眼中只有脚下的路。 他闭上眼，眼前突然又浮出她的音容。他抿起嘴，知道这里没有白来。他一定能遇见她。 地铁站门口的长椅上，一名穿着X中校服的男孩倒在那里。不断地，有的人指指点点，有的人掏出手机，更多的人就擦身而过，一如他们的来时。人们围成一圈一圈的波纹胀缩着，像吞吐的白鲸。 救护车很快赶到了。几个人没等停稳就跳下了车，确认那个男孩还活着，便麻利将他收拾好，三下五除二地抬了上去。车呜呜叫着开走了。 波纹抖动了几下，接着便是轰轰烈烈的溃败。 他跌跌撞撞地起身远去。尽管深一脚浅一脚地走着，他的足迹却惊人地笔直，就像大地在随着他的步履而偏移。 他捡起地上散落的酒瓶，正要往嘴里灌，又哐地摔碎到了地上。水流像蛇一样沿着砖缝汩汩爬去，留下属于他的未来。 雾开始落下来。 他偷偷走到她的身后，一把蒙住了她的眼。她象征地挣扎了几下。他很快松开手，向后退了几步，眼里映满了她的影子。 “还是找到这里了啊，”他笑着说。 她白了他一眼。 他揽住她的腰。皎皎清光透过楼梯侧的窗，洒进空无一人的走廊里，散着幽沁的香。 他和她坐在跑道边，说是要等着，等最后一片云霞沉寂在地平线下。时不时地，他们凑在对方的耳边，轻声低语；欢谑声里，沉沉的烟火灿烂着，像雪染成的白绫。风打在他和她的肩上。 那片云明明随风飘摇着，却迟迟没有离去。月亮不息地转动着。缓缓地，他和她之间像是有些什么，成片成片地生长着，拣尽寒枝。 像一束一束的光。 果然还是偏离了啊，他无声叹道。错过了那一瞬，就算过后再怎么努力，就算你已拥有了一切，你如履薄冰，你不敢高声语，你尽力维护着原样的展览馆。殊不知时间没有负半轴。你再也回不到从前。 他闭上眼。那时他想了太多，他不知道孰对孰错，他不着边际地猜着，就这样过去了。后来他迷途知返，却已无路可退。 “今天……月亮好好看。”他睁开眼，看看天，又看看她。她也望向天空，微蹙眉头，显得有些诧异。大概是没有感到什么分别吧。一湾再普通不过的月亮，撒着空灵的光。 她不着痕迹地点了点头。 他的目光没有移开。她怔了怔，略略偏过头，唇角勾起一个弧度，又回过头正视着他。 远处传来一声巨响。 他回过神，发觉视野的凝滞。她的眼里似乎闪过了一道意味难明的神采来。他没有看清，可即便他看清的话，他也一定会以为那盈盈秋水里，映着的是他自己的影子。 一如她方才的浅笑，一落在他的眼里，便似料峭雪峰陡然塌落，绽起了明媚的飞光。 贪、嗔、痴、怨，爱别离，求不得。 世界的走向尽管去变吧，他想。连过去都错过了，还谈什么未来呢。 他已经无路可退。 他堵住了她的唇。接下来的事已经从这个世界上抹去了，他试着撕开那层薄纱，也终究只能看到未来的投影。两个人滚在一起。一朵血梅葳蕤绽放。 生生繁华于枯荑，萋萋空翠自灵犀。辉星皓夜苍千顷，此宵风醉月舞萤。 他迷迷糊糊地睁开了眼，在一片山水里。满川的红叶簌簌飘落，尽是离人眼中血；他拼了命想要醒来，却像陷在了无垠的沼泽。他只好回到梦中，描绘了她的远去，宛若降兮北渚的帝子。后来他才发现，原来是梦里有个小人拦在他的面前，死命拽住了他的脚，怎么也不愿意长大。 他离开了那个地方，却不知是怎么做到的。一如来时。她早已不在他身旁。他觉得很可笑，明明是亲手缔结的世界，却如同活在梦中。 他原以为能找回他失去的东西的。可他反倒又丢失了好多；她和他的一部分永远地遗失在了那里，遗失在了那个无法企及的角落。他的脑中一片空白，任由身躯驱使他穿过影影绰绰的人群，已分辨不出哪个是她，哪个是熟悉的陌生人。就连残存的记忆，也被那一部分所吸引着，渐渐从他的意识里剥离。他说不上来自己究竟后不后悔，也许是不吧；他攥着唯一的烛火，走遍了无数的银幕，上穷碧落下黄泉。现在烛火也最后熄灭了。或许也是新的开始呢，他想。他拖着疲惫的身躯登上了来时的列车；随着车向前，一寸一寸的大地像是耗尽了最后的力量，轰然坍落，正如他刚刚所见的，沼底尽头的宫殿。一点一点的萤火在空中翻飞，散化为繁星点点，连同他的碎片，连同他和她的一切，连同那最后一丝烙印。他最后一次忆起她的身影，茕茕然在那里，迎上他的目光，嫣然一笑，胜过一切盛放的花。窗外像是有什么在呼啸着：他试图回想起，却早已飘散如烟。他不清楚何时何地，抑或是每时每地也未可知。阳光贪婪地闯了进来，不放过每一处罅隙，洒在她莹莹的脸上。她抿起唇。他倏地站起，眼中却已被水雾弥漫。 远处，站台已隐约可见。他探出车窗，像是要看些什么，却终于没有看清。他揉了揉眼，却想起无泪可流。 他沿着来时的路走去。路旁的烧烤摊上，他看见了新见、五反田、三谷，和其他几个人聚在一起，畅谈着过去，也畅谈着未来。 他们看见他的到来像是很惊讶。新见从隔壁桌搬了把凳子。他们团团围着坐了。 “你一个人回来的？高桥呢？”新见开口问道。 “高桥是谁？”他问。 “没事了，”新见道。“记错人了。” “……哦。”他没再说话，抓起烤翅啃了起来。其他人也恢复了先前的样子，觥筹交错，起坐喧哗。 “还是……要回去吗？”五反田问道。 “是啊。” “……和以前不太一样了。”三谷道。 “哦。” 沉默。 “……这是在威胁我吗？”他擦了擦额头，问道。新见点了点头，出人意料地。 “你非要说……算是吧。不过我们不拦着你。”新见又拿了串烤鱿鱼，“还是那句话，我们是真心在劝你。” “心领了，”他略一拱手。 “又是有非去不可的理由呵……”新见向后仰去。工藤擤了擤鼻子。 他们对视了一会。 “一直向那边走……走到头右拐。就在那里。”半晌，新见像是放弃了努力。“注意安全。路上不再像以前那样了。” “好。” 夜很快就深了。他们相对无言。 他站起身。 “希望这不是最后一次见面吧。”上原举起酒杯，微笑致意。他也笑着回礼。 “那么……再会。”他背上书包。 “再会，”他们齐声道。 他匆匆地走了。他知道有人在向着他拼命地挥手，求他千万别去回头。这都不要紧了。 他走着他的路。 路旁的景致从原野过到了黑白。他不知所措地望着前方，像是看到了那隙天边的裂痕，一针刺下便能渗出殷红的血。 他循环着刚才的会晤，其中一定有他遗漏了的东西。一张张面孔纤毫毕现，如在目前，像老式的放映机吱吱作响。他们倒是相信着未来，可最终却不是失去了自己的名字，就是去往了另一个世界。 他惊醒过来，已经站在路的终点了。前面是一堵砖墙，并不够高，却足以屏蔽他的目光。他在路口踌躇了许久，近乎能猜出墙后的场景了。那里只有最纯粹的白天与黑暗，只有最清白的绝望与梦想，只有最纷乱的花雨与黄沙。一定是的，毋庸置疑。 可他收回了心思，径直向右走去。另一个方向上，几个外国人举着摄像机，叽里咕噜地说着什么。章老师不断点头回应着，又重新扛起了金箍棒，周而复始。汗水浸湿了他的猴毛假发。 到那边先去找鲲吧，他想。他一定会带我去找他们的。还有C和Betsy……他们究竟走到了哪里？他们的时间又在何处停止？他们能不能触及心底的奢望？他们…… 我放下笔起身。远处，天塔像是响应着节约的号召，灭尽了全部的光亮，徒留名姓载孤舟；可年年相望的月亮却好像觉悟不高的样子，仍旧卖力地将别人施予的光又施予给每一个角落，照出了掩映的层云。广寒悠悠，遗世独立，羽化而登仙。 我坐回书桌，对着摊了整整一桌的草稿，却迟迟无法下笔。我想到笔下的一个个人物，他们在既定的旅途上孤独地跋涉着，却一直希冀着另外的一半，愿前路交织在一起。他们有的孑然一身，却并不孤独；可更多的纵是莺莺燕燕，孤独却已渗入骨髓。不过至少他们都以相同的方式来到了终点吧，无论孤独与否。他们本都有无限的可能。 我在纸张间左右横跳，眼前似乎看到了那位主人公，孤独地走在沼底的路上。其实……他已经消失在了他毁掉的那个地方吧。他终是要和五反田他们一起，就像1944年东京的住民，分不清哪一个会最终降临。想到这，我不禁笑了起来，眼里噙满了泪花。 高桥几个留在了沼底的尽头；章老师留在了中美合拍的现场；C和Betsy留在了一个又一个的迷宫：人人都有光辉的未来吧，又或许人人都没有了未来。白骨如山忘姓氏，无非公子与红妆。 我合上手稿，想起还有两个月就要退役了。我关灯躺在床上，沉沉睡去，梦中看见了初生的朝阳，携着金色的流光，照亮了无边的黑暗。 （完） 2020.11.8 2021.6.29 2021.9.8 2021.9.20 2022.7.14","link":"/ning-mei/"},{"title":"匹配：模板","text":"UOJ78 二分图最大匹配（DFS - KM）12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 550;int match[N], g[N][N], vis[N], link[N];int n, m, e, tag, ans = 0;bool dfs(int u) { for(int v=1; v&lt;=m; ++v) { if(!g[u][v] or vis[v] == tag) continue; vis[v] = tag; if(!match[v] or dfs(match[v])) { match[v] = u; return true; } } return false;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e); for(int i=1, u, v; i&lt;=e; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u][v] = true; } for(int i=1; i&lt;=n; ++i) { tag = i; if(dfs(i)) ++ans; } printf(&quot;%d\\n&quot;, ans); for(int i=1; i&lt;=m; ++i) link[match[i]] = i; for(int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, link[i]); return 0;} UOJ79 一般图最大匹配（带花树）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 550;int fa[N], match[N], pre[N], vis[N];int tag = 0, n, m, ans = 0;int flag[N];bool g[N][N];queue&lt;int&gt; q;void clear(queue&lt;int&gt; &amp;q) { queue&lt;int&gt; empty; swap(q, empty);}int belong(int u) { return fa[u] == u ? u : fa[u] = belong(fa[u]);}void path(int u) { while(u) { int v = match[pre[u]]; match[u] = pre[u]; match[pre[u]] = u; u = v; }}int lca(int u, int v) { ++tag; u = belong(u); v = belong(v); while(vis[u] != tag) { vis[u] = tag; u = belong(pre[match[u]]); if(v) swap(u, v); } return u;}void connect(int u, int v, int root) { while(belong(u) != root) { pre[u] = v; v = match[u]; if(flag[v] == 2) { q.push(v); flag[v] = 1; } if(belong(u) == u) fa[u] = root; if(belong(v) == v) fa[v] = root; u = pre[v]; }}bool bfs(int u) { memset(flag, 0, sizeof flag); memset(pre, 0, sizeof pre); for(int i=1; i&lt;=n; ++i) fa[i] = i; clear(q); q.push(u); flag[u] = 1; while(!q.empty()) { u = q.front(); q.pop(); for(int v=1; v&lt;=n; ++v) { if(!g[u][v]) continue; if(flag[v] == 0) { pre[v] = u; if(match[v] == 0) { path(v); return true; } q.push(match[v]); flag[v] = 2; flag[match[v]] = 1; } else { if(flag[v] == 2) continue; if(belong(u) == belong(v)) continue; int root = lca(u, v); connect(u, v, root); connect(v, u, root); } } } return false;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1, u, v; i&lt;=m; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u][v] = g[v][u] = true; } for(int i=1; i&lt;=n; ++i) if(match[i] == 0 and bfs(i)) ++ans; printf(&quot;%d\\n&quot;, ans); for(int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, match[i]); return 0;} UOJ80 二分图最大权匹配（BFS - KM）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 440;const LL INF = 0x3f3f3f3f3f3f3f3f;bool vis[N];int pre[N], link[N], res[N];int n, m, e;LL g[N][N], lx[N], ly[N], d[N], ans = 0;void bfs(int k) { int x, y = 0; LL min1 = INF, delta; memset(vis, false, sizeof vis); memset(pre, 0, sizeof pre); memset(d, 0x3f, sizeof d); link[y] = k; do { x = link[y], delta = INF, vis[y] = true; for(int i=1; i&lt;=m; ++i) { if(!vis[i]) { if(d[i] &gt; lx[x] + ly[i] - g[x][i]) { d[i] = lx[x] + ly[i] - g[x][i]; pre[i] = y; } if(delta &gt; d[i]) delta = d[i], min1 = i; } } for(int i=0; i&lt;=m; ++i) if(vis[i]) lx[link[i]] -= delta, ly[i] += delta; else d[i] -= delta; y = min1; } while(link[y]); while(y) link[y] = link[pre[y]], y = pre[y];}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e); m = max(n, m); for(int i=1; i&lt;=e; ++i) { int u, v; LL w; scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w); g[u][v] = w; lx[u] = max(lx[u], w); } for(int i=1; i&lt;=n; ++i) bfs(i); for(int i=1; i&lt;=m; ++i) { if(!g[link[i]][i]) continue; ans += g[link[i]][i]; res[link[i]] = i; } printf(&quot;%lld\\n&quot;, ans); for(int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, res[i]); return 0;}","link":"/match-template/"},{"title":"NOIP2020 游记","text":"（2021.4.29 补记） 这篇游记在去年十一月份开坑，一月份的时候正式写完。 还记得得知判决的那个晚上，我咕掉作业抱着手机坐了一整晚，还和家长起了一些争执。几个月以后再回来看，心态也平和了许多吧。可能这段经历不能带给我别的什么，也可能再过一段时间会为当时的选择而自怨自艾，为什么不最后冲一把，说不定就…… 不过没有如果了吧。到了现在早就没有回头路了，何况回头路上还布着更跌宕的坎坷。@SiRiehn_nx 能够逆天改命，又不代表你也可以，真以为自己行了啊。 上面这些可能更多是写给未来的自己的吧，提醒自己不要后悔，没必要再去填补句号的空白。 高二 OIer @SerokSSR，坐标 TJ。 退役了。 Once upon a time大概是 NOI Online 刚开始的时候吧，就想着该为 1= 做准备了。三场全都参加了，第一次忘写头文件，第二次抽屉原理不会，第三次才将将苟进了全国前 25%。 说实话是挺沮丧的，当时觉得省一没戏了，但是还是想努力一把。 Summer暑假报了 luogu 网课。之前一直没系统学过 DP，结果看提纲发现 DP 直接从状压开始讲，于是从 0 开始恶补了好一阵子，但是还是写不出方程来。 网校讲到后面的课基本上都听不大懂了，记得数论听了一半就去睡觉了。 要了基础组的深基，边补基础边学背包，暑假基本就这么过去了。 开学打算把竞赛暂时放一放，因为其实不太想报 -OH，只是想在退役前圆一个省一梦。 CSP-S1第一个月过去了，基本上是每周末如果作业写完了就写几道题，如果作业太多就咕掉。 去考初赛，以前一直是有分就行，所以没啥压力。 选择题似乎比较水很快做完了，然后看程序，一看这不是昨天 luogu 刚出的 nth_element，瞎分析了一波复杂度全写上了。 被 $O(n)$ 的 map 笑到了，但是题还是不会做。搞了一阵子发现是宽搜，怎么搜的还是看不懂。选项全是蒙的。 最后一个 DP 也没看懂，随便选了几个长得好看的写上了。 出来估分 60~70，听母上大人说有个小孩出来高兴地说太简单了 我：??? 最终得分 83，成了 rank4 可惜初赛分无一点用，复赛还是一道题不会做。 今年复赛考点换成 nk，初赛线都划到 44 了，有点可啪。 之后渐渐就是能不写的作业都不写了，每周末基本上两个整天都在学 OI。 CSP-S2和期中考试正好在同一周。Singercoder 直接把期中咕掉了，我想了想自己的 OI 水平，还是参加了，不过除了物理生物基本都没咋复习。上午考完，回家就对着电脑坐一下午。 听说过了一轮就可以去考 NOIP，所以也没特意准备。第二天上午背了背 Tarjan 板子，直接去考试了。 开场一看 T1 是个大模拟，觉得自己的码力问题不大（，就开始写 结果写了两个小时，1600 年之后还是一年一年跳的。过了大样例。结果跟脑子短路了一样，不开 T2 开始想 T1 优化。。。 然后就一直调不对了。 最后一小时扔掉调不出来的 T1 想 T2，草草读完题，互不相同也没注意到。$O(k\\times 2^k)$ 走人。 赛后出考场估分 80+40+20+0，以为还可以。 晚上 luogu 自测，发现 T1 年份边界全写挂了，T3 还没取模，T4 白送的 20 分暴力也没写。 当时就流眼泪了，捂着眼，我说停停。 脚造大样例，问候出题人。 周一浑浑噩噩地去上课。mrc 劝我赶快停课，我想了想确实，但是还是等一会吧。 心态快崩了，不过倒是没崩。 停课期中出分了，班级 rank3，年级在 rank5 左右。 可是人总是想得到没得到的东西的。 找杨鸽签了假条，周五正式开始停课。当时是 11.27，离 NOIP2020 还有刚好两周。 之后的日子也不清楚是怎么过来的。刷历年的题、写总结、写题解看题解，一天一天就这么过去了。 开始喜欢听古风歌了。耳机单曲了好一阵子的 风筝误 和 不见长安。 他还陷在那段隔世经年的梦 静静和衣睡去 不理朝夕 CSP 出分了，10+40+10+0=60 rank36，省三第一。已经有心理准备了，心情没太波动。 NOIP-1图书馆真的安静，Singercoder 和 zach0914 都不说话。 中午去踢球，后防被对面特长生冲烂了。 看了一天的 DP 题和题解，快放学的时候才知道期望的定义 回家把做过的题往脑子里塞，看到大概 8:00 左右。 然后开始看 KPL，想着 DYG 一定要赢啊。结果眼睛是看着比赛，脑子里想了很多乱七八糟的，紧张的要死。 打到 3:2 的时候十点多了，去睡觉。 一晚上没睡好。 NOIP早晨看了眼微博，DYG 4:2 AG，心情略微好了一点。 在门口集合的工夫和 zach0914 和 lth 说了说话。lth 掏出了刘汝佳开始看。 过了一会儿 Singercoder 也到了，一起进去。进考场看见了 SiRiehn_nx（当时还叫 zhltao），听他 fAKe 了几句。 CSP 的时候显示屏糊的要死，这回终于换了。 一坐在座位上反倒不那么紧张了，想着尽力就好吧。骑车来的，虽然有戴手套，不过还是冻僵了。 8:30 开考。T1 一看拓扑板子直接开始敲，手有点僵硬，而且中间有一段时间怎么也过不去样例，很慌，几乎把中间变量全输出了一遍，发现是次序写反了。然后大样例又没过。随手把 int 换成了 long long 竟然过了，当时感觉这题稳了。信心很足。用时 35min。 看 T2，觉得 NOIP 不可能考 KMP 的（，所以想怎么 DP。想不出来，上来开始大力模拟，敲了 30min 左右过了前两个样例，第三个本机跑了 2s，问题有点大。 打算把字母全相等的点先放一放，去看 T3。暴力都没有一点思路，想着 T4 估计会更难，必须得把这个的部分分拿下来。然后还是没有思路。 只好去看 T4，读题就读了好久。显然是我不可做的题，直接上爆搜，感觉细节不是一般的多，就没敲，回去把 T2 的相等情况写了。直接拿暴力改的，觉得没问题就没对拍。又看了一会儿 T3，还是没思路。 觉得必须得开 T4 了。枚举好像就很麻烦，最后用了一个递归生成状态，然后开了个 map&lt;vector&lt;int&gt;, vector&lt;int&gt; &gt; 判无解……看前两个样例都过了，就这样吧。现在一想感觉自己是个 zz，为啥不状压一下啊。 很快就中午了，感觉有点饿。忽然想到 T2 可以前缀和优化一点点，写上发现第三个点直接降到了 0.2s，这回应该很稳了吧。当时估了一下分，100+56+0+10，因为 T1 直接是板子觉得这回不太行，又去想 T3。 一想不管了，直接把暴力敲上。敲了 100 多行一运行直接爆栈了，一看只有半个多小时了，干脆全删了打了个随机数，开始检查。 剩 20 多分钟的时候发现 T2 的相等做法 WA 了……调了十分钟没调出来，横下心不管了。然后就一遍一遍地查 freopen 和路径。 考完一个一个去前面核对程序，结果我是我们考场倒数第二个。出来的时候，其他考场已经都走光了。当时脑子里就全是空白的，想着这样也挺好，千万不要听到别人讨论做法。 nk校园确实比某数字中学好看一万倍 考前一周，jzx 在给下一届的放 KMP 讲解视频。 我：这东西根本不用会吧 QAQ，NOIP 一辈子没考过 考试前一天，我们一群人在图书馆口胡押题。 我：拓扑 CSP 刚考完啊，也不会再考第二遍了吧 开过光的嘴。。。 忍不住上 luogu 看了看，看见第一题 1~m 的时候整个人都不好了。后来看见 CZ 说不卡这个又活了过来。高精卡不卡就无所谓了。 oitiku 90+48+0+30，测了一圈似乎都比我分高 /fad 很慌。 洛谷和 oitiku 的分一样。看了看讨论区，1= 应该是稳了吧 /qaq。不知道蓝勾有没有。 心情挺复杂的。明明已经完成目标圆满退役了，却总觉得少了点什么，心里空荡荡的，似乎既有不甘，又有不舍。OI 真的就像划过黑暗的流星，闪着荧烁的火光，可消失却只需短短一瞬。你甚至来不及准备。 我看着自己的排名，又无可救药地动起了心思，尽管理智告诉我希望渺茫。我想着该让自己冷静冷静了，于是打开电脑，写了这么一篇游记。 Future周围的人和我自己都在告诉我，说你应该认清自己，比起冲队，whk 才是更优解吧，无论是从性价比还是从实力。话是这么说，距离将它接受成现实可能还需要一段时间了。 最后祝我自己好运，祝 rsx(SiRiehn_nx)、lgh(Singercoder)、zsh(tyslsiZ) RP++, AK IOI. 谨以此文纪念我的 OI 生涯。 T1 出题人的双亲大概是溘然长逝了吧，连交换律都卡。90-&gt;60。靠这个做区分度是我没想到的。 60+48+0+30 = 138，弱省 rank10，无缘蓝勾。 就这样吧。 初中的直接从榜上消失了？CCF 属实迷惑操作，让人家参加结果连成绩证明都不给。 这 1= 线真的离谱……最终 rank7，以最后一名的成绩苟到了 1=。 怎么感觉要进队了（ 等等我好像比基准线高了？？？那岂不是说…… 果然。 TJ 分到了七个省队名额，而七个 1= 被数字中学和 nk 包揽了；因为我比基准线高，所以执行三分之一限制。也就是说有两个省二能进队；而我和 rsx 如果想进队，必须要考到自己学校的第二名。rsx 有一点点希望，而且他是高一，还有无限的可能。 而我…… 得知消息的那天晚上，刚好作业不多。我对着手机，坐了一整晚。 这大概是我离 Cu 最近的一次了。可我刚要反应过来，它却早已裂成了碎片。 后来想了想，我确实完全没有在 NOI 拿到 100+ 的能力。A 过最难的题是绿题（其他的不是板子就是教练带着做的），DP 和图上问题考场上永远是只会敲暴力。今年的题但凡阳间一点，可能就要复刻去年的结局了。就算侥幸进了队，也要押上半个高考，去赌一个渺茫的未来。 从 2018 年暑假入坑，到现在两年多了，可水平似乎从 18 年的普及开始就在原地踏步。只是多会了一些算法，犯病的概率减少了一些。见到带点思维难度的就直接投降。至今没有打过一场 CF。 还是不够强罢了。 甘心吗？当然不甘心。为什么这套题才考了一百分的就能进队，而我却没有了机会。难道这就是所谓的公平吗，whk 成绩越低越好？确实，即使没有校杀，最后的结局很可能也没有什么变化，可我仍然希望做出选择的人是自己。尽管可能他们才是对的吧。 可又能怎样呢。 都结束了吧。 高考加油。","link":"/noip2020-you-ji/"},{"title":"初级动态规划：LIS、LCS、背包","text":"LIS &amp; LCSP1020 导弹拦截1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n = 0;int a[N], b[N], s[N], ls[N];void add(int x, int v) { for(; x&lt;=n; x+=x&amp;(-x)) s[x] = max(s[x], v); }int query(int x) { int ans = 0; for(; x&gt;0; x-=x&amp;(-x)) ans = max(ans, s[x]); return ans;}int main() { //freopen(&quot;p1020_1.in&quot;, &quot;r&quot;, stdin); for(; scanf(&quot;%d&quot;, a+n+1) != EOF; ++n, b[n] = a[n]); sort(b+1, b+n+1); int t = unique(b+1, b+n+1) - (b+1); for(int i=1; i&lt;=n; ++i) a[i] = lower_bound(b+1, b+t+1, a[i]) - b; int ans = 0; for(int i=n; i&gt;0; --i) { int q = query(a[i]) + 1; add(a[i], q); ans = max(ans, q); } printf(&quot;%d\\n&quot;, ans); ans = 0; memset(s, 0, sizeof s); for(int i=1; i&lt;=n; ++i) { int q = query(a[i]-1) + 1; add(a[i], q); ans = max(ans, q); } printf(&quot;%d\\n&quot;, ans); return 0;} P1439 【模板】最长公共子序列12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, b[N], p1[N], p2[N], s[N];int lowbit(int x) { return x&amp;(-x);}void add(int x, int v) { for(; x &lt;= n; x += lowbit(x)) s[x] = max(s[x], v);}int query(int x) { int ans = 0; for(; x &gt; 0; x -= lowbit(x)) ans = max(ans, s[x]); return ans;}int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, p1+i); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, p2+i); for(int i=1; i&lt;=n; ++i) b[p1[i]] = i; for(int i=1; i&lt;=n; ++i) p2[i] = b[p2[i]]; int ans = 0; for(int i=1; i&lt;=n; ++i) { int q = query(p2[i]-1) + 1; add(p2[i], q); ans = max(ans, q); } printf(&quot;%d&quot;, ans); return 0;} 0-1 背包$$F(i,j)=\\begin{cases}F(i-1,j)&amp; j \\leq w_i\\\\\\max{F(i-1,j),F(i-1,j-w_i)+v_i}&amp; j &gt; w_i\\end{cases}$$ 注意二维转换成一维的时候，$j$ 要从后向前枚举，因为每次的新结果都是根据上一个结果来求得的，从后向前可避免重复取同一物品。 P2196 挖地雷1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 30;typedef pair &lt;int, vector&lt;int&gt; &gt; piv;vector&lt;int&gt; g[N]; int s1[N], n, w[N], in[N];vector&lt;int&gt; ss[N];piv ans;void outp(vector&lt;int&gt; &amp;ans) { for(vector&lt;int&gt;::iterator it = ans.begin(); it != ans.end(); ++it) printf(&quot;%d &quot;, *it); printf(&quot;\\n&quot;);}piv dfs(int x, vector&lt;int&gt; s) { if(s1[x]) { return (piv){s1[x], ss[x]}; } if(g[x].size() == 0) { s1[x] = w[x]; ss[x].clear(); ss[x].push_back(x); return (piv){s1[x], ss[x]}; } s1[x] = w[x]; ss[x].push_back(x); vector&lt;int&gt; st = ss[x]; for(vector&lt;int&gt;::iterator it = g[x].begin(); it != g[x].end(); ++it) { piv p = dfs(*it, s); if(p.first + w[x] &gt; s1[x]) { s1[x] = p.first + w[x]; ss[x] = st; ss[x].insert(ss[x].end(), p.second.begin(), p.second.end()); } } return (piv){s1[x], ss[x]};}int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, w+i); for(int i=1, a; i&lt;=n; ++i) { for(int j=i+1; j&lt;=n; ++j) { scanf(&quot;%d&quot;, &amp;a); if(a) g[i].push_back(j), ++in[j]; } } for(int i=1; i&lt;=n; ++i) { if(!in[i]) { piv p = dfs(i, ss[i]); if(p.first &gt; ans.first) { ans.first = p.first; ans.second.clear(); ans.second.insert(ans.second.end(), p.second.begin(), p.second.end()); } } } outp(ans.second); printf(&quot;%d&quot;, ans.first); return 0;} P1455 搭配购买套一个并查集。 Code：（2019.12.01） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int N = 11000; struct node { int c, d;} val[N], tmp[N];int n, m, w, fa[N], list[N], dp[N], t, ans = 0;bool flag[N];int root(int x) { return fa[x] == x ? x : fa[x] = root(fa[x]);}void operator +=(node &amp;A, node B) { A.c += B.c, A.d += B.d;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;w); for(int i=1; i&lt;=n; ++i) fa[i] = i; for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, &amp;val[i].c, &amp;val[i].d); for(int i=1; i&lt;=m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); int u1 = root(u), v1 = root(v); fa[u1] = v1; } for(int i=1; i&lt;=n; ++i) root(i); for(int i=1; i&lt;=n; ++i) tmp[fa[i]] += val[i]; memcpy(list+1, fa+1, n*4); std::sort(list+1, list+n+1); t = std::unique(list+1, list+n+1) - (list+1); for(int i=1; i&lt;=t; ++i) for(int j=w; j&gt;=tmp[list[i]].c; --j) dp[j] = std::max(dp[j], dp[j - tmp[list[i]].c] + tmp[list[i]].d); printf(&quot;%d\\n&quot;, dp[w]); return 0;} P1164 小A点菜这怎么会是橙题啊 注意DP的初值 dp[0] = 1，因为需特别考虑过程中「从0开始买菜」的情况。 循环中的i 表示已经考虑到了前i道菜。如果能买的起，就直接把 dp[j-a[i]] 转移过来，否则不变。 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int dp[11000], n, m, a[110];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); dp[0] = 1; for(int i=1; i&lt;=n; ++i) { for(int j=m; j&gt;=a[i]; --j) { dp[j] += dp[j-a[i]]; } } printf(&quot;%d\\n&quot;, dp[m]); return 0;} 完全背包与上面的01背包问题差别不大，只是多了一个条件：每个物品可以取无数次。 方法很简单，只要 $j$ 从前向后枚举即可。这样做其实是变相利用了它的后效性，使同一个物品可以被多次取到。 P1616 疯狂的采药12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int t1, m, dp[int(1e7+10)], t[int(1e4+10)], v[int(1e4+10)];int main() { scanf(&quot;%d%d&quot;, &amp;t1, &amp;m); for(int i=1; i&lt;=m; ++i) scanf(&quot;%d%d&quot;, t+i, v+i); for(int i=1; i&lt;=t1; ++i) { dp[i] = dp[i-1]; for(int j=1; j&lt;=m; ++j) if(i-t[j]&gt;=0) dp[i] = max(dp[i], dp[i-t[j]] + v[j]); } printf(&quot;%d\\n&quot;, dp[t1]); return 0;} 多重背包一种方法是转化成 01 背包处理。 首先找到最大的 $k$ 使得 $t=\\sum_{i=0}^{k}2^i(t &lt; c_i)$，也就是找到最大的小于 $c_i$ 的二的各个次幂和。这样之后，我们就可以通过不重复且有选择地使用 $2^0$到 $2^k$ 来表示出 1到 t所有的数。但是剩下的呢？我们将剩下的 $c_i-t$ 单独分成一个物品，因为 1到 t都可以表示，那么有了这个 $c_i-t$ 物品，就可以表示出所有数了。 例如，把 $21$ 分为 $[1,2,4,8,6]$，这样就可以从中不重复地选择来表示出 1到 $c_i$ 的所有数了。 P1776 宝物筛选123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110, M = 44000;int n, W, v[N], w[N], m[N], dp[M];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;W); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d%d&quot;, v+i, w+i, m+i); for(int i=1; i&lt;=n; ++i) { //1, 2, 4, 8, ... 2^k, m_i-2^(k+1)+1 int sum = 0; for(int j=0; sum + (1&lt;&lt;j) &lt;= m[i]; ++j) { sum += (1&lt;&lt;j); for(int l=W; l&gt;=w[i]*(1&lt;&lt;j); --l) dp[l] = max(dp[l], dp[l-w[i]*(1&lt;&lt;j)] + v[i]*(1&lt;&lt;j)); } for(int l=W; l&gt;=w[i]*(m[i] - sum); --l) dp[l] = max(dp[l], dp[l-w[i]*(m[i] - sum)] + v[i]*(m[i] - sum)); } printf(&quot;%d\\n&quot;, dp[W]); return 0;} P5020 [NOIP2018提高组]货币系统首先要想到这题可能并不是数论。 80分做法:考虑爆搜，枚举现有系统中的每个数能否被其他已选择的数表示出来。这里可以贪心的想，如果一个数能被另外几个数表示，那么删除它一定是更优解。 dfs() 部分可以换成背包，不过复杂度级别是差不多的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;bool us[N];int T, n, maxv, t, a[N];bool dfs(int s, int x, int p) { if(x &gt; n or s &gt; a[p]) return false; if(x == p or us[x]) return dfs(s, x+1, p); for(int i=0; i&lt;=maxv/a[x]; ++i) { if(s+a[x]*i == a[p]) return true; bool f = dfs(s+a[x]*i, x+1, p); if(f) return true; } return false;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;n); maxv = 0; for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, a+i); maxv = max(maxv, a[i]); } sort(a+1, a+n+1); t = unique(a+1, a+n+1) - (a+1); int ans = t; memset(us, false, sizeof us); for(int i=1; i&lt;=t; ++i) { if(dfs(0,1,i)) { us[i] = true; --ans; } } printf(&quot;%d\\n&quot;, ans); } return 0;} 满分做法：其实在80分基础上再多想一步就够了：我们不用枚举每个数的表示法来判断可不可以删。直接对所有数dp，如果一个数能用一种以上的方式表示出来，那么就删掉它。显然删掉这个数是无后效的。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;bool us[N]; int dp[26000];int T, n, maxv, t, a[N];int main() { scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;n); maxv = 0; for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, a+i); maxv = max(maxv, a[i]); } sort(a+1, a+n+1); t = unique(a+1, a+n+1) - (a+1); int ans = t; memset(dp, 0, sizeof dp); dp[0] = 1; for(int i=1; i&lt;=t; ++i) { for(int j=a[i]; j&lt;=maxv; ++j) { dp[j] += dp[j-a[i]]; } } for(int i=1; i&lt;=t; ++i) { if(dp[a[i]] &gt; 1) --ans; } printf(&quot;%d\\n&quot;, ans); } return 0;} 分组背包在枚举主件的前提下枚举附件。 P1064 金明的预算方案1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 33000, M = 65;typedef vector&lt;int&gt;::iterator IT;int n, m, p[M], v[M], dp[N];int g[M][2];vector&lt;int&gt; s;int main() { //freopen(&quot;P1064_5.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=m; ++i) { int q; scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;p[i], &amp;q); if(q == 0) s.push_back(i); else if(g[q][0]) g[q][1] = i; else g[q][0] = i; } for(IT it = s.begin(); it != s.end(); it++) { int i = *it; int a = g[i][0], b = g[i][1]; for(int j=n; j&gt;=v[i]; --j) { dp[j] = max(dp[j], dp[j-v[i]] + v[i]*p[i]); if(j-v[i]-v[a] &gt;= 0) dp[j] = max(dp[j], dp[j-v[i]-v[a]] + v[i]*p[i] + v[a]*p[a]); if(j-v[i]-v[b] &gt;= 0) dp[j] = max(dp[j], dp[j-v[i]-v[b]] + v[i]*p[i] + v[b]*p[b]); if(j-v[i]-v[a]-v[b] &gt;= 0) dp[j] = max(dp[j], dp[j-v[i]-v[a]-v[b]] + v[i]*p[i] + v[a]*p[a] + v[b]*p[b]); } } printf(&quot;%d\\n&quot;, dp[n]); return 0;} 装满背包一种特殊情况。 背包不一定装满时，$dp[j]$ 记录的是前i件物品放入空间为j的背包中的最大价值，要在一开始，让 $dp[]$ 中的每个值为 0。 背包装满时，注意要把 f[j]（表示刚好装满的最大价值）初始化为 f[0] = 0; f[1..n] = -INF;，这样就能使那些能够恰好装满背包的物品的值为正数，而那些不能恰好装满背包的物品的值就为负数，就容易区分了。 dp[n(背包最多承重)] == inf 的话，说明装不满；如果装满的话，dp[n] 即为最高价值。","link":"/dp-linear/"},{"title":"单调队列","text":"单调队列是一种特殊维护的队列。一般地，当一新值准备入队时，须先从后向前，将对后来答案没有了影响的点弹出，再从前向后，将所有超出了统计范围的点弹出。对于大多数问题，求解过程中会锁定很多答案区间，在线求最值。 P3088 拥挤的奶牛题面有 $N$ 头奶牛沿着一维的栅栏吃草，第 $i$ 头奶牛在目标点 $x_i$，它的身高是 $h_i$ 。当一头奶牛左边 $D$ 距离内而且右边 $D$ 距离内有身高至少是它的两倍的奶牛，它就会觉得拥挤。 请计算觉得拥挤的奶牛的数量。 解当一奶牛将要入队时： 从后往前，将身高小于该奶牛的弹出（--tail），因为将要进队的奶牛更加靠后，影响范围一定更大，对答案的贡献也一定更大。 从前往后，将与该奶牛距离已超过 $D$ 的奶牛弹出（++head） 将该奶牛入队。 与队头奶牛比较身高，若符合则打上标记，若左右两次统计均符合，则计入答案。 每次统计的是该奶牛左侧的合法性，从后到前再做一遍就可以了。 按照以上规则就可以统计答案了。显然该队列一定为单调递降队列。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N = 55000;struct node { int x, h;} a[N];int n, d, queue[N];bool l[N], r[N];bool cmp(node a, node b) { return a.x &lt; b.x;}int main() { freopen(&quot;p3088.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;d); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].h); sort(a+1, a+n+1, cmp); int head = 0, tail = 1; queue[head] = 1; for(int i=2; i&lt;=n; ++i) { while(head &lt; tail and a[queue[tail-1]].h &lt;= a[i].h) --tail; queue[tail++] = i; while(head &lt; tail and a[i].x - a[queue[head]].x &gt; d) ++head; if(a[queue[head]].h &gt;= (a[i].h &lt;&lt; 1)) l[i] = true; } head = 0, tail = 1; queue[head] = n; for(int i=n-1; i&gt;=1; --i) { while(head &lt; tail and a[queue[tail-1]].h &lt;= a[i].h) --tail; queue[tail++] = i; while(head &lt; tail and a[queue[head]].x - a[i].x &gt; d) ++head; if(a[queue[head]].h &gt;= (a[i].h &lt;&lt; 1)) r[i] = true; } int ans = 0; for(int i=1; i&lt;=n; ++i) if(l[i] and r[i]) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;} P3522 Temperature题面有 $n$ 个段，第 $i$ 个为 $[l_i, r_i]$，现要在几个连续的段中，每段中各取一个值，构成一序列，要求该序列不能下降，求序列的最大长度。 解以段的左端点维护单调序列。 当一新段将要入队时： 从后向前，将所有左点比新段的左点小的段弹出。 从前向后，将所有右点比新段的左点小的段弹出。 统计答案：用当前位置减去队头的上一段的位置 $\\because$ 队头的上一段已被弹出 $\\therefore$ 从队头的上一段的下一段起（可能已被弹出）至当前位置均属于合法序列 代码1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;const int N = 1100000;int max(int a, int b) { return a &gt; b ? a : b; }int n, l[N], r[N], queue[N], ans = -1;int main() { freopen(&quot;p3522.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, l+i, r+i); int head = 0, tail = 1; queue[head] = 0; for(int i=1; i&lt;=n; ++i) { while(head &lt; tail and l[i] &gt;= l[queue[tail-1]]) --tail; queue[tail++] = i; while(head &lt; tail and l[queue[head]] &gt; r[i]) ++head; ans = max(ans, i - queue[head-1]); } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/monotonous-queue/"},{"title":"图论","text":"图论算法一般都是揉在一起的，很难单独把算法拆开讲，所以直接上题目吧。分类是大致分的，其实有很多是交叉的。 二叉树二叉树的遍历有三种，分别为前序遍历，中序遍历和后序遍历，并且给定其中的两种遍历能够求出另一种遍历 (必须已知中序遍历)。 前序遍历：按 根 左 右 的顺序进行； 中序遍历：按 左 根 右 的顺序进行； 后序遍历：按 左 右 根 的顺序进行。 最短路 &amp; 生成树算法复杂度 多源最短路Floyd：严格 $O(n^3)$ 单源最短路Dijkstra： 朴素：严格 $O(n^2)$ 优先队列优化：均摊 $O((e+n) \\log n)$ Bellman-Ford： 最多松弛 $n-1$ 次 严格 $O(ne)$ SPFA： 即队列优化Bellman-Ford 最坏 $O(ne)$，最好 $O(1)$ 板子咕咕咕 如何卡掉 SPFA见 https://www.zhihu.com/question/292283275/answer/484871888 P1967 货车运输最大生成树，然后跑LCA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e4+10, M = 1e5+10, INF = 0x3f3f3f3f;struct node { int id, u, v, w, next;} e[M], e1[M];int h[N], tot = 0, tot1 = 0, n, m;int fa[N][15], dep[N], dis[N][15];int vis[N];bool edg[M];void add(int u, int v, int w) { e1[tot1] = e[tot] = {tot, u, v, w, h[u]}; h[u] = tot++; tot1++; e[tot] = {tot, v, u, w, h[v]}; h[v] = tot++;}int bc[N];int root(int u) { return bc[u] == u ? u : bc[u] = root(bc[u]);}bool cmp(node a, node b) { return a.w &gt; b.w;}void dfs(int u, int f, int vi) { vis[u] = vi; for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(v == f) continue; if(edg[i] or edg[i^1]) { dep[v] = dep[u] + 1; fa[v][0] = u; dis[v][0] = e[i].w; dfs(v, u, vi); } }}void lca(int x, int y) { if(dep[x] &lt; dep[y]) swap(x, y); int ans = INF; int t = dep[x] - dep[y]; for(int i=14; i&gt;=0; --i) { if(t &gt;= (1&lt;&lt;i)) { ans = min(ans, dis[x][i]); x = fa[x][i]; t -= (1&lt;&lt;i); } } if(x == y) { printf(&quot;%d\\n&quot;, ans); return; } for(int i=14; i&gt;=0; --i) { if(fa[x][i] != fa[y][i]) { ans = min(ans, dis[x][i]); ans = min(ans, dis[y][i]); x = fa[x][i]; y = fa[y][i]; } } //printf(&quot;lca:%d\\n&quot;, fa[x][0]); printf(&quot;%d\\n&quot;, min(ans, min(dis[x][0], dis[y][0])));}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); for(int i=1; i&lt;=m; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); } sort(e1, e1+tot1, cmp); for(int i=1; i&lt;=n; ++i) bc[i] = i; for(int i=0; i&lt;tot1; ++i) { int u = e1[i].u, v = e1[i].v; int u1 = root(u), v1 = root(v); if(u1 != v1) { edg[e1[i].id] = true; bc[v1] = u1; } } for(int i=1; i&lt;=n; ++i) { if(bc[i] == i) { dfs(i, 0, i); for(int j=0; j&lt;=14; ++j) { fa[i][j] = i; dis[i][j] = INF; } } } for(int i=1; i&lt;=14; ++i) { for(int j=1; j&lt;=n; ++j) { fa[j][i] = fa[fa[j][i-1]][i-1]; dis[j][i] = min(dis[j][i-1], dis[fa[j][i-1]][i-1]); } } int query; scanf(&quot;%d&quot;, &amp;query); for(int i=1; i&lt;=query; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if(vis[x] != vis[y]) { printf(&quot;-1\\n&quot;); continue; } lca(x, y); } return 0;} P1073 最优贸易分层图，最短路 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int N = 330000, M = 1650000;struct node { int u, v, w, next; node() {} node(int _u, int _v, int _w, int _next): u(_u), v(_v), w(_w), next(_next) {}} e[M &lt;&lt; 1];int h[N], tot = 0;inline void add(int u, int v, int w = 0) { e[tot] = node(u, v, w, h[u]); h[u] = tot++;}int n, m, w[N]; bool vis[N]; int dis[N];int main() { #ifdef DEBUG freopen(&quot;p1073_1.in&quot;, &quot;r&quot;, stdin); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;w[i]); } memset(h, -1, sizeof h); for(int i=1, x, y, z; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); if(z == 1) add(x, y), add(x+n, y+n), add(x+2*n, y+2*n); else { add(x, y), add(x+n, y+n), add(x+2*n, y+2*n); swap(x, y); add(x, y), add(x+n, y+n), add(x+2*n, y+2*n); } } for(int i=1; i&lt;=n; ++i) { add(i+n, i, w[i]); add(i, i+2*n, -w[i]); } queue&lt;int&gt; q; memset(dis, 0x3f, sizeof dis); q.push(n+1); vis[n+1] = true; dis[n+1] = 0; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = false; for(int i=h[u]; i!=-1; i=e[i].next) { int v=e[i].v; if(dis[v] &gt; dis[u] + e[i].w) { dis[v] = dis[u] + e[i].w; if(!vis[v]) { q.push(v); vis[v] = true; } } } } printf(&quot;%d\\n&quot;, -dis[n*3]); return 0;} P1119 灾后重建很重要的题目，考察了 Floyd的本质。 Floyd用 $dis[k][i][j]$ 表示 i 和 j 之间可以通过编号为 $1\\dots k$ 的节点的最短路径，显然，$dis[0][i][j]$ 就是原始邻接矩阵数据。 状态转移方程： $$dis[k][i][j]=min(dis[k-1][i][j],dis[k-1][i][k]+dis[k-1][k][j])$$ Floyd 的本质其实就是DP，只不过我们通常做题时利用了数据只会使用一次性的原理，把 dis 变成滚动数组，减少了一维，节省空间。 更多请见 https://www.cnblogs.com/fangwencai/p/4784914.html。 1234567//提前将邻接矩阵存在 dis 数组里，其他不连通的地方初始化成无穷大for(int k=1; k&lt;=n; ++k) //枚举中间点 for(int i=1; i&lt;=n; ++i) //枚举起点 if(i != k) //节省时间，如果一样就不往下走 for(int j=1; j&lt;=n; ++j) //枚举终点 if(i != j and j != k) //继续判断，如果有一样的就不往下走 dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); //状态转移方程，也就是所谓的松弛操作 只要我们能够利用 DP 特性，就能解决许多问题 再回来看这道题，文中说每个村子是不同时间修好的，而每个节点都按顺序给出，这不就是恰好相当于 Floyd的中间点吗？我们可以把 k轮 DP分开做，每输入一个点，就用这个点当中转站把最短距离更新一遍，也就是跑一遍 DP。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 220;int t[N];struct query { int id, x, y, t;} a[55000];int res[55000], n, m, dp[N][N];int main() { //freopen(&quot;P1119_2.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, t+i); } t[n+1] = 0x3f3f3f3f; memset(dp, 0x3f, sizeof dp); for(int i=1; i&lt;=n; ++i) dp[i][i] = 0; for(int i=1; i&lt;=m; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); ++u, ++v; dp[u][v] = dp[v][u] = w; } int q; scanf(&quot;%d&quot;, &amp;q); for(int i=1; i&lt;=q; ++i) { scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].t); a[i].id = i; ++a[i].x, ++a[i].y; } int cnt = 1; for(; a[cnt].t &lt; t[1]; ++cnt) { res[a[cnt].id] = -1; } for(int T=1; T&lt;=n; ++T) { for(int i=1; i&lt;=n; ++i) { for(int j=1; j&lt;=n; ++j) { dp[i][j] = min(dp[i][j], dp[i][T] + dp[T][j]); } } while(1) { if(cnt &gt; q) break; if(a[cnt].t &gt;= t[T] and a[cnt].t &lt; t[T+1]); else break; if(a[cnt].x &gt; T or a[cnt].y &gt; T or dp[a[cnt].x][a[cnt].y] == 0x3f3f3f3f) { res[a[cnt].id] = -1; } else { res[a[cnt].id] = dp[a[cnt].x][a[cnt].y]; } ++cnt; } } for(int i=1; i&lt;=q; ++i) printf(&quot;%d\\n&quot;, res[i]); return 0;} 判负环转自 @SingerCoder，%lgh 注意一定要判入队次数而不是松弛次数。 hack原理很简单：如果存在重边导致了多次松弛，那么对松弛次数的判断就会产生影响。解决方式就是判入队次数，虽然略慢，但是更稳。 Update[2020.7.26]：在写差分约束的时候想用spfa判无解，然后经过一系列的思考就有了下面这组新的hack数据： 1234567891011input:14 61 2 -31 3 -21 4 -12 3 -62 4 -53 4 -4output:NO 注意这组hack只对用链式前向星（而非vector）存边且判的是松弛次数（而非入队次数）的有效，而且该数据无重边无自环，比discuss里面的那个数据更有说服力。 首先hack原理就是对n号节点进行n-1轮松弛，每轮都有 $x( x \\in [1,n-1])$ 次松弛，这样就能产生 $n^2$ 级别的松弛次数。 但是判入队次数就hack不掉了，每轮的第一次松弛会让n节点入队，但n节点只有在下一轮才会出队；因此本轮的其余所有松弛全部无法导致入队。 P3385 [模板]负环1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 2e3 + 10, M = 6e3 + 10;struct node { int u, v, w, next;} e[M];int h[N], tot = 0;int T, n, m;inline void add(int u, int v, int w) { e[++tot] = {u, v, w, h[u]}; h[u] = tot;} int dis[N], vis[N];bool inq[N];inline void spfa() { queue&lt;int&gt; q; memset(dis, 0x3f, sizeof dis); memset(vis, 0, sizeof vis); memset(inq, false, sizeof inq); dis[1] = 0; q.push(1); inq[1] = true; ++vis[1]; while(!q.empty()) { int u = q.front(); q.pop(); inq[u] = false;//printf(&quot;%d\\n&quot;, u); for(int i = h[u]; i ; i = e[i].next) { int v = e[i].v; if(dis[v] &gt; dis[u] + e[i].w) { dis[v] = dis[u] + e[i].w; if(!inq[v]) { inq[v] = true; ++vis[v]; if(vis[v] &gt; n-1) { printf(&quot;YES\\n&quot;); return; } q.push(v); } } } } printf(&quot;NO\\n&quot;);}int main() { //freopen(&quot;P3385_2.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, 0, sizeof h); tot = 0; for(int i=1; i&lt;=m; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); if(w &gt;= 0) { add(u, v, w); add(v, u, w); } else add(u, v, w); //printf(&quot;%d &quot;, i); } spfa(); } return 0;} 基环树n 个点 n 条边 只有一个环 枚举断边 P5022 [NOIp2018TG]旅行","link":"/graph-theory/"},{"title":"图论：Tarjan","text":"前置概念时间戳：搜索时第几个搜索到这个点。如搜索顺序是1-&gt;2-&gt;3-&gt;6，则6的时间戳为4 对于无向图连通分量：对于图G来的一个子图中，任意两个点都可以彼此到达，这个子图就被称为图G的连通分量（一个点就是最小的连通分量） 最大连通分量：对于图G的一个子图，这个子图为图G的连通分量，且是图G所有连通分量中包含节点数最多的那个，即为G的最大联通分量 算法流程推荐看看这篇 简单应用缩点有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。孤立的一个点也是一个强连通分量。 如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量（SCC, Strongly Connected Components）。把每个强联通分量看成一个集合，把每个集合看成一个点，那么所有SCC就形成了一个DAG（有向无环图），就是著名的缩点。 Problem 根据题目意思，我们只需要找出一条点权最大的路径就行了，不限制点的个数。那么考虑对于一个环上的点被选择了，一整条环是不是应该都被选择，这一定很优，能选干嘛不选。很关键的是题目还允许我们重复经过某条边或者某个点，我们就不需要考虑其他了。因此整个环实际上可以看成一个点（选了其中一个点就应该选其他的点） 在处理了环后，我们就重新建立一张图，以每个环为节点（孤立一个点也算也算环的，其实也就是强联通分量了）。在这张图中我们要dp，显然对于任意边&lt;u,v&gt;，dp[v] = max(dp[v], dp[u] + new_weight[v])。 dp的时候拓扑排一下序，这也是DAGdp的常见trick了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4+10, M = 1e5+10;struct node { int u, v, nxt;} e[M];int h[N], tot = 0;int dfn[N], low[N], tag = 0, top = 0, num = 0;int n, m, w[N], ww[N], f[N], id[N], s[N], in[N];void tarjan(int u) { dfn[u] = low[u] = ++tag; s[++top] = u; for(int i = h[u], v; i; i = e[i].nxt) { v = e[i].v; if(!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if(!id[v]) low[u] = min(low[u], dfn[v]); } if(dfn[u] == low[u]) { ++num; while(s[top] != u) { id[s[top]] = num; ww[num] += w[s[top]]; top--; } id[s[top]] = num; ww[num] += w[s[top]]; top--; } }int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, w+i); for(int i=1; i&lt;=m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); if(u == v) continue; e[++tot] = {u, v, h[u]}; h[u] = tot; } for(int i=1; i&lt;=n; ++i) { if(!dfn[i]) tarjan(i); } memset(h, 0, sizeof h); for(int i=0, t=0; i&lt;tot; ++i) { int u = id[e[i].u], v = id[e[i].v]; if(u == v); else { e[++t] = {u, v, h[u]}; h[u] = t; ++in[v]; } } queue&lt;int&gt; q; for(int i=1; i&lt;=num; ++i) { if(!in[i]) q.push(i); } int ans = 0; for(int i=1; i&lt;=num; ++i) f[i] = ww[i], ans = max(ans, f[i]); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = h[u]; i; i = e[i].nxt) { int v = e[i].v; f[v] = max(f[v], f[u]+ww[v]); ans = max(ans, f[v]); --in[v]; if(!in[v]) q.push(v); } } printf(&quot;%d\\n&quot;, ans); return 0;} 找割点割点：去掉无向联通图的某个点后，此图不连通，该点为割点。 Problem 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;iostream&gt;using std::min;const int N = 22000, M = 110000;struct node { int u, v, next;} e[M &lt;&lt; 1];int h[N], tot;int dfn[N], low[N], tag;int res[N], ans, n, m, fa[N];void tarjan(int u, int fa) { dfn[u] = low[u] = ++tag; int sum = 0; for(int i = h[u], v; i; i = e[i].next) { v = e[i].v; if(v == fa) continue; if(dfn[v]) low[u] = min(low[u], dfn[v]); else { ++sum; tarjan(v, u); low[u] = min(low[u], low[v]); if(fa == -1) continue; if(low[v] &gt;= dfn[u]) res[u] = true; } } if(fa == -1 and sum &gt; 1) res[u] = true; }int main() { //freopen(&quot;p3388_4.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1, x, y; i&lt;=m; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); e[++tot] = (node) {x, y, h[x]}; h[x] = tot; e[++tot] = (node) {y, x, h[y]}; h[y] = tot; } for(int i=1; i&lt;=n; ++i) if(dfn[i] == 0) tarjan(i, -1); for(int i=1; i&lt;=n; ++i) if(res[i]) ++ans; printf(&quot;%d\\n&quot;, ans); for(int i=1; i&lt;=n; ++i) if(res[i]) printf(&quot;%d &quot;, i); return 0;}","link":"/graph-tarjan/"},{"title":"数论：不定方程整数解","text":"欧几里得算法又称辗转相除法，迭代求两数 gcd。 由 $(a, b) = (a, ka + b)$ 的性质，$\\gcd(a, b) = \\gcd(b, a\\bmod b)$。容易证明这么做的复杂度是 $O(\\log n)$。 注意：$\\gcd(0, a) = a$。 裴蜀定理裴蜀定理：设 $(a, b) = d$，则对任意整数 $x, y$，有 $d|(ax + by)$ 成立；特别地，一定存在 $x, y$ 满足 $ax + by = d$。 等价的表述：不定方程 $ax + by = c(a, b, c 为整数)$ 有解的充要条件为 $(a, b)|c$。 P4549 【模板】裴蜀定理裴蜀定理可以推广到多元方程。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() { int n; scanf(&quot;%d&quot;, &amp;n); int a; scanf(&quot;%d&quot;, &amp;a); int g = a; for(int i=2; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;a); if(a == 0) continue; if(a &lt; 0) a = -a; g = __gcd(g, a); } printf(&quot;%d\\n&quot;, g); return 0;} 扩展欧几里得（exgcd）裴蜀定理的推论：$a, b$ 互质等价于 $ax + by = 1$ 有解。 因此，要求不定方程 $ax+by=c$ 的解，只需求 $ax+by=d,d=\\gcd(a,b)$ 的解，然后扩倍（乘上 $\\frac{c}{d}$）即可。 求出任意一个解考虑使用欧几里德算法的思想，令 $a = bq + r$，其中 $r = a \\bmod b$，递归求出 $bx + ry = d$ 的一个解。 设求出 $bx + ry = d$ 的一个解为 $x = x_0, y = y_0$，考虑如何把它变形成 $ax + by = d$ 的解。 将 $a = bq + r$ 代入 $ax + by = d$，化简得 $$b(xq + y) + rx = d$$ 令$$xq + y = x_0, x = y_0$$上式成立。 故$$x = y_0, y = x_0 - y_0q$$为 $ax + by = d$ 的解。 注意边界情况：当 $b = 0$ 时，必有 $a = d$，此时令 $x = 1, y = 0$ 即可。 怎么求出所有解？先用exgcd 求出任意一个解 $x = x_0, y = y_0$，再求出 $ax + by = 0$ 的最小的解$$x = dx = b/(a, b), y = dy = -a/(a, b)$$所有解就是$$x = x_0 + kdx, y = y_0 + kdy,k\\in \\mathbb{Z}$$ P1082 同余方程1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; pll;ll a, b;pll exgcd(ll a, ll b) { if(b == 0) return {1,0}; pll p = exgcd(b, a%b); return {p.second, p.first-a/b*p.second};}int main() { scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b); ll x = exgcd(a,b).first; while(x &lt; 0) x+=b; while(x-b &gt; 0) x-=b; printf(&quot;%lld\\n&quot;, x); return 0;} P3951 [NOIP2017提高组]小凯的疑惑方法很多，这里提供一个比较好理解的扩欧做法。 首先已知题目必存在答案，那么设答案为 $k-1$ ，则 $ax+by=k$ 必有一组非负整数解 $(x,y)$ 假设 $ax+by=k-1$ 有非负整数解，那么该式必能化为 $$a(x-x_0)+b(y-y_0)=k$$其中$$ax_0+by_0=1$$ 注意到，若尽量使该式能够有解，则有两种情况，分别令 $x_0$ 或 $y_0$ 取其最小非负整数解 $x’$ 和 $y’’$（因为一方最小时另一方必为最大情况） 因此为了让原式无解，需保证 $x-x’&lt;0, y-y’’&lt;0$，即 $x&lt;x’,y&lt;y’’$ 因为要构造最大非负整数解，所以令 $x=x’-1,y=y’’-1$ 所得即为 $k$，答案即为 $a(x’-1)+b(y’’-1)-1$，就可以直接利用扩欧求解了。 不过其实还能进一步化简 有一个很显然的结论，$ax_0+by_0=1$ 是没有非负整数解的 然后把 $x,y$ 想象成分别在两个竖直的数轴上，可以发现，对于上面的两组解 $(x’,y’),(x’’,y’’)$，他们都是离水平面（原点）最近的解，所以他们在扩欧通解上是两组相邻的解 则 $$\\begin{aligned}ans&amp;=k-1\\\\&amp;=a(x’-1)+b(y’’-1)-1 \\\\&amp;=ax’-a+by’’-b-1 \\\\&amp;=ax’+by’+ab-a-b-1 \\\\&amp;=ab-a-b.\\end{aligned}$$","link":"/num-exgcd/"},{"title":"搜索与状压 DP","text":"DFS搜索和DP不分家，几乎所有的DP都能用搜索解决（虽然复杂度可能较劣）。不过，如果实在想不出正解，DFS不失为骗分的好手段。 主要的搜索算法有： DFS/BFS爆搜 双向BFS 启发式搜索（又称A*） 迭代加深搜索 IDA*（迭代加深+启发式） 记忆化搜索 剪枝 重要程度：1,7,6 &gt; 4,3 &gt; 5,2。 P3956 [NOIP2017普及组]棋盘搜索/DP的题一定要先看数据范围。这道题 $1 ≤ m ≤ 100, 1 ≤ n ≤ 1000$，朴素搜索显然不可行。 然后分析题目，到达一个点可能有多种途径，所以也不可以用vis数组优化。只剩记忆化搜索了。 简单证明一下正确性： 如果当前格子本来就有颜色，那么魔法一定可用 如果当前格子原本没有颜色，那么只要搜到这个格子，魔法其实只有一种情况就是不可用 记搜时注意剪枝条件一定要写满。比如 f &gt;= mem[x][y] 如果改成 f &gt; mem[x][y]，后果就会很严重。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int m, n, c[N][N], mem[N][N];int d[4][2] = {{0,1},{0,-1},{-1,0},{1,0}};int ans = 0x3f3f3f3f;void dfs(int x, int y, int f, int cc) { //f: 代价 //cc != -1 不能用魔法, 此处改成的颜色 //cc == -1 可以 if(f &gt;= mem[x][y] || f &gt;= mem[m][m]) return; mem[x][y] = f; if(x == m &amp;&amp; y == m) return; for(int i=0; i&lt;4; ++i) { int xx=x+d[i][0],yy=y+d[i][1]; if(xx&lt;1||xx&gt;m||yy&lt;1||yy&gt;m) continue; if(cc!=-1&amp;&amp;c[xx][yy]==cc||cc==-1&amp;&amp;c[xx][yy]==c[x][y]) { dfs(xx, yy, f, -1); } else if(cc!=-1&amp;&amp;c[xx][yy]!=cc&amp;&amp;c[xx][yy]!=-1||cc==-1&amp;&amp;c[xx][yy]!=c[x][y]&amp;&amp;c[xx][yy]!=-1) { dfs(xx, yy, f+1, -1); } else if(cc==-1&amp;&amp;c[xx][yy]==-1) { dfs(xx, yy, f+2, c[x][y]); } }}int main() { scanf(&quot;%d%d&quot;, &amp;m, &amp;n); memset(c, -1, sizeof c); memset(mem, 0x3f, sizeof mem); for(int i=1; i&lt;=n; ++i) { int x, y, cc; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;cc); c[x][y] = cc; } dfs(1, 1, 0, -1); printf(&quot;%d\\n&quot;, mem[m][m] == 0x3f3f3f3f ? -1 : mem[m][m]); return 0;} P3959 [NOIP2017 提高组]宝藏可能你会想到生成树，所以这里给出一个反例： 这张图从1号点开始的Prim便是错的。 如果跑Prim，从1号点开始的话，我们会先访问2，（此时花费为1），然后我们会访问3，此时花费为3 * 2，然后由于只有4号点未访问，这时3号的访问顺序为3，访问4号的代价是3 * 100 = 300，显然这种做法不是最优的，正确的答案应该是211（从1号点开始的最小花费为211）。 虽然直接跑Prim是错的，但是Prim的思想仍然重要，这一思想也在最短路等很多算法中有应用：用更新过的点去更新其他点。 我们设计一个不基于点的dfs函数，参数只需传递代价，每次迭代，先枚举访问过的点，再枚举一个未访问且未开通路径的点，进行松弛，将代价持续传递下去。计算代价需要记录点的深度，也要通过父节点传递下去。 这样我们就有了一个大概的思路，照着模拟，可以拿到至少70分。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;const int INF = 0x7f7f7f7f;int min(int a, int b) { return a &lt; b ? a : b; }int map[20][20];int dep[20], best, n, m, num;bool vis[20];void dfs(int x) { if(x &gt;= best) return; //注意这里的剪枝！ if(num == 0) { best = x; return; } for(int i=1; i&lt;=n; ++i) { if(vis[i]) { for(int j=1; j&lt;=n; ++j) { if(!vis[j] and map[i][j] &lt; INF) { vis[j] = true; --num; dep[j] = dep[i] + 1; dfs(x + map[i][j] * dep[j]); vis[j] = false; ++num; } } } }}int main() { memset(map, 0x7f, sizeof map); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=m; ++i) { int x, y, v; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;v); map[x][y] = map[y][x] = min(map[x][y], v); } best = INF; num = n; for(int i=1; i&lt;=n; ++i) { vis[i] = true; --num; dep[i] = 0; dfs(0); vis[i] = false; ++num; } printf(&quot;%d\\n&quot;, best); return 0;} 按当年的测试数据，在这段代码的基础上再进行足够细致的剪枝，可以拿到100分的好成绩。 状压 DP常用操作设全集为 $x$ for(int y = x; y; y = (y-1) &amp; x)：枚举 x 的每个子集 x^y：x 集合中刨去 y x&amp;y == y：y 是 x 的子集 P3959 宝藏对还是刚才那道题。 即便当时的测试数据水到乱搞都可以打满，但是搞懂正解仍然很有必要。 设计状态，令 $f_{j,i,S}$ 表示从起点到准备向外发边的点 $i$ 的距离为 $j$，准备要把集合 $S$ 中的点挖通。 转移时，枚举从节点 $i$ 打出的边 $(i,k)$，再枚举从 $k$ 要打通的子集 $S_2\\subset S$，那么 $$f_{j, i, S} = \\min_{k \\in S_2 \\subset S} (d[i][k] * (j + 1) + f_{j + 1, k, S_2 - {k}} + f_{j, i, S - S_2})$$ 转移顺序一定要想好。 最后取所有 $f_{0,i,U-{i}}$ 的最小值即可，其中 $U$ 是全集。 核心代码 12345678910111213141516171819202122232425262728293031323334//预处理集合中1的个数for (int i = 1; i &lt; mx; ++i) sz[i] = sz[i &amp; (i - 1)] + 1;//预处理 lowbitfor (int i = 0; i &lt; n; ++i) mn[1 &lt;&lt; i] = i;for (int i = 1; i &lt; mx; ++i) mn[i] = mn[i &amp; -i];for (int i = 0; i &lt; n; ++i) f[n - 1][i][0] = 0; //初值for (int j = n - 2; j &gt;= 0; --j) { //距离 for (int i = 0; i &lt; n; ++i) { //发边点 f[j][i][0] = 0; //初值 for (int S = 1; S &lt; (1 &lt;&lt; n); ++S) { if (((~S &gt;&gt; i) &amp; 1) //i不在集合S里 &amp;&amp; sz[S] &lt;= n - j - 1) //不会多挖 for (int S2 = S; S2; S2 = (S2 - 1) &amp; S) { //S的每个子集 int tmp = S2; for (int k = mn[tmp]; tmp; k = mn[tmp &amp;= ~(1 &lt;&lt; k)]) //S2里的每个点 if (mp[i][k] ^ INF) //存在待挖的边 f[j][i][S] = min(f[j][i][S], f[j + 1][k][S2 &amp; ~(1 &lt;&lt; k)] + f[j][i][S &amp; ~S2] + mp[i][k] * (j + 1)); } } }}int ans = INF;for (int i = 0; i &lt; n; ++i) ans = std::min(ans, f[0][i][(mx - 1) &amp; ~(1 &lt;&lt; i)]);","link":"/dp-graph/"},{"title":"图论：LCA","text":"LCA: Lowest common ancestor 最近公共祖先倍增求 LCA预处理向上跳 $2^k$ 步的结果数组 f[k][x]。 求的时候先把两个点跳到一个深度。这里有一个特判，如果重合直接返回这个点。 然后log值从大往小枚举，两个点一起不断向上跳，直至父亲相同，直接返回父节点。 可以 $O(n)$ 预处理log值，把单次查询复杂度降到 $O(常数)$。 复杂度：预处理 $O(n \\log n)$，查询 $O(1)$ 欧拉序求LCA欧拉序：dfs时的访问完整路径，回溯时也要把这个点算上。 易知欧拉序的长度是 $2n-1$，从边的角度考虑，每条边都是来回访问了两次，加上根节点的初始访问，$2(n-1)+1=2n-1$。 这里就是一个小性质，记 p[i] 为 $i$ 节点在欧拉序中第一次出现的位置，则对任意的 $u,v$，在 ol[p[u]..p[v]] 段内，使 p[ol[i]] 最小的 ol[i] 即为 lca(u,v)。 多次询问可用ST表预处理出最小值。 复杂度：预处理 $O(n \\log n)$，查询 $O(1)$ Tarjan求LCA树剖求LCA","link":"/graph-lca/"},{"title":"数论：整除问题","text":"整除分块与其说整除分块是一种算法，不如说它是一个技巧。有时我们需要计算这样的式子： $$\\sum_{i=1}^n f(i)\\lfloor\\frac{n}{i}\\rfloor$$ 根据经验，我们发现 $\\lfloor\\frac{n}{i}\\rfloor$ 只有 $O(\\sqrt n)$ 种取值。对于每种取值，$i$ 都会有一个连续的范围。假设函数 $f$ 的前缀和可以预处理后快速求出，那么我们可以枚举 $\\lfloor\\frac{n}{i}\\rfloor$ 的所有取值，并和 $f$ 的连续一段的和相乘。具体可以见代码： 1234567// s[i] 为函数 f(i) 的前缀和 int ans = 0;for(int i=1, j; i&lt;=n; i=j+1) { j = n/(n/i); ans += (s[j]-s[i-1])*(n/i);}printf(&quot;%d\\n&quot;, ans); 杂题P4942 小凯的数字我们知道，一个数模 $9$ 等于他的各位和模 $9$。这一结论可以推广至将某数截成若干节，每段合起来也符合这个规律，题目便转化成求 $\\sum_{i=l}^{r} i\\pmod 9$。用 __int128 也可以过，但是更好是把除以二挪到前面，使其符合乘法取模分配率，注意奇偶。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;int a[15], b[15];int main() { int q; scanf(&quot;%d&quot;, &amp;q); for(int i=1; i&lt;=q; ++i) { LL l, r; scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r); if((r-l+1) %2 == 0) printf(&quot;%lld\\n&quot;, ((r-l+1)/2)%9*(l+r)%9); else printf(&quot;%lld\\n&quot;, ((l+r)/2)%9*(r-l+1)%9); } return 0;}","link":"/num-theory/"},{"title":"尺取法","text":"尺取法，又称滑动窗口或双指针，是一种在序列上寻找最优解的方法．对于序列的每个左端点 $l$，让右端点 $r$ 尽可能延伸至最远，得到一个答案区间，$r$ 已到达最远后将与 $l$ 有关的信息弹出，对于多个答案区间找出最优解．复杂度通常为线性． 不过一些时候这样不能保证求得的是最优解，这时就需要其他思路，或者使用莫队（根号算法）暴力求解． HDU5178 Pairs题面有 $n$ 个值 $x_1, x_2, \\dots,x_n$，求使得 $|x_b-x_a|\\leqslant k,a&lt;b$ 的数对 $(a,b)$ 的个数． 解分析可知 $a&lt;b$ 这一条件只是确保无重复，次序其实对于最终答案没有影响． 考虑先对 $x$ 排序（因原题目有绝对值，无影响），for​ $l$ 尺取出最远的 $r$， 则 $(l,r]$ 间的每个数均与 $l$ 构成合法数对． 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;algorithm&gt;const int N = 110000;typedef long long LL;int T, n;LL k, x[N];int main() { freopen(&quot;hdu5178.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%lld&quot;, &amp;n, &amp;k); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, x+i); std::sort(x+1, x+n+1); LL ans = 0; for(int l=1, r=2; l&lt;=n; ++l) { for(; r &lt;= n and x[r] - x[l] &lt;= k; ++r); ans += r - l - 1; } printf(&quot;%lld\\n&quot;, ans); } return 0;} HDU6119 小小粉丝度度熊类似 CF1041D Glider 题面给出 $n$ 个已签到的天数区间，$m$ 张补签卡，求可获得的最大连续签到时长。 解尺取模板。 天数区间可重叠，须进行合并。 需要注意的是，当已确定最长合法区间 $[l,r]$ 后（即下一个区间与 $r$ 的距离大于剩余的补签卡数量，连不上），应把剩余补签卡全部应用到 $r$ 之后的天数上得到更优解。 代码边界条件较多。 $R$ 为已加入队列的最后一个区间，判断的是区间 $R+1$ 的合法性。 特判第一个区间，开始时 $sum$ 直接加上第一个已签到区间的长，使用 $0$ 张补签卡。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110000;struct node { int l, r;} a[N], b[N];bool flag[N];bool cmp(node a, node b) { return a.l &lt; b.l; }int n, m;int max(int a, int b) { return a &gt; b ? a : b; }int main() { freopen(&quot;hdu6119.in&quot;, &quot;r&quot;, stdin); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) { for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, &amp;b[i].l, &amp;b[i].r), flag[i] = false; sort(b+1, b+n+1, cmp); for(int i=2; i&lt;=n; ++i) { if(b[i-1].r &gt;= b[i].l) { b[i].l = b[i-1].l; b[i].r = max(b[i].r, b[i-1].r); flag[i-1] = true; } } int tot = 0; for(int i=1; i&lt;=n; ++i) { if(flag[i]) continue; a[++tot].l = b[i].l; a[tot].r = b[i].r; } int sum = a[1].r - a[1].l + 1, f = 0, ans = 0; for(int L = 1, R = 1; L &lt;= tot; ++L) { for(; R + 1 &lt;= tot and f + a[R+1].l - a[R].r - 1 &lt;= m; ++R) sum += a[R+1].r - a[R].r, f += a[R+1].l - a[R].r - 1; ans = max(ans, sum + m - f); sum -= a[L+1].l - a[L].l; f -= a[L+1].l - a[L].r - 1; } printf(&quot;%d\\n&quot;, ans); } return 0;} HDU1937 Finding Seats题面电影院有 $R$ 行 $C$ 列，用 '.' 表示空座，'X' 表示不可选。 要求选择至少 $K$ 个空座位 $(x_i, y_i)$，使得$$(\\max x_i -\\min x_i)\\cdot(\\max y_i -\\min y_i),1\\leqslant i \\leqslant K$$最小。 解二维尺取。 枚举题目所求长方形的上下界，尺取求出左右最短距离。用二维前缀和简化空位查找。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 330;int row, c, k;char str[N];int s[N][N];int query(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];}int main() { freopen(&quot;hdu1937.in&quot;, &quot;r&quot;, stdin); while(true) { scanf(&quot;%d%d%d&quot;, &amp;row, &amp;c, &amp;k); if(row == 0 and c == 0 and k == 0) break; for(int i=1; i&lt;=row; ++i) { scanf(&quot;%s&quot;, str+1); int sum = 0; for(int j=1; j&lt;=c; ++j) { sum += (str[j] == '.' ? 1 : 0); s[i][j] = s[i-1][j] + sum; } } int ans = 0x7fffffff; for(int up = 1; up &lt;= row; ++up) { for(int down = up; down &lt;= row; ++down) { for(int l=1, r=1; l&lt;=c; ++l) { for(; r&lt;=c; ++r) { if(query(up, l, down, r) &gt;= k) { ans = min(ans, (down - up + 1) * (r - l + 1)); break; } } } } } printf(&quot;%d\\n&quot;, ans); } return 0;} HDU5358 First One题面有一数列 $a_1, a_2, \\dots, a_n$，求$$\\sum_{i=1}^{n} \\sum_{j=i}^{n} (i + j)(\\lfloor \\log_2 \\sum_{k=i}^{j} a_k \\rfloor + 1)$$的值。特别地，$\\log_20=0$。 解观察上式，对于 $\\lfloor\\log\\rfloor$ 来说，它的一个值可对应很多个真数，考虑分块。 枚举 $\\lfloor \\log_2 \\sum_{k=i}^{j} a_k \\rfloor$ 的每一个值（1~34）。 令$$v =\\lfloor \\log_2 \\sum_{k=i}^{j} a_k \\rfloor$$ $$sum = \\sum_{k=i}^{j}a_k$$ 则$$sum \\in [2^{v-1},2^v)$$用尺取求出部分和在此范围的区段 $[i,j]$，求出结果加入计数器。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 110000;typedef long long LL;LL cl[40], a[N], s[N];int T, n;int main() { freopen(&quot;hdu5358.in&quot;, &quot;r&quot;, stdin); cl[0] = -1, cl[1] = 1; for(int i=2; i&lt;=34; ++i) cl[i] = ((cl[i-1] + 1) &lt;&lt; 1LL) - 1; scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, a+i); for(int i=1; i&lt;=n; ++i) s[i] = s[i-1] + a[i]; LL ans = 0; for(LL k=1; k&lt;=34; ++k) { LL l = 0, r = 0; for(LL i=1; i&lt;=n; ++i) { for(l = max(l, i); l &lt;= n and s[l] - s[i-1] &lt;= cl[k-1]; ++l); for(r = max(l, r); r &lt;= n and s[r] - s[i-1] &lt;= cl[k]; ++r); ans += k * (i * (r-l) + (l+r-1) * (r-l) / 2); } } printf(&quot;%lld\\n&quot;, ans); } return 0;} HDU6103 Kirinriki题面有两字符串 $A,B$（从 $1$ 编号），长度均为 $n$，定义$$dis(A,B) = \\sum_{i=1}^n|A_i-B_{n-i}|$$字符之差定义为其 ASCII 码的差。 对于一字符串 $S$，找出它的两个不重叠连续子串，他们的 $dis$ 不大于 $m$，求最长合法子串长度。 解寻找单调性，易得$$\\forall S’ \\subseteq S,T’\\subseteq T:dis(S’,T’)\\leqslant dis(S,T)$$因此子串越长越好。 又$\\because$ $\\forall$ 两个合法子串，其必关于母串的某一位置（或某两位置之间）对称，考虑枚举这一中心点，分上面的两种情况。 注意到对于每个子串，其长度越大越好，同时又有约束上界，可对称尺取。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string.h&gt;int abs(int x) { return x &gt; 0 ? x : -x; }int max(int a, int b) { return a &gt; b ? a : b;}int T, n, m;char s[22000];int main() { freopen(&quot;hdu6103.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;m); scanf(&quot;%s&quot;, s+1); int n = strlen(s+1), ans = 0; for(int i=1; i&lt;=n; ++i) { int f = 0; for(int l1 = i-1, r1 = i-1, l2 = i+1, r2 = i+1; l1 &gt; 0 and l2 &lt;= n; --l1, ++l2) { for(; r1 &gt; 0 and r2 &lt;= n and f + abs(s[r1] - s[r2]) &lt;= m; --r1, ++r2) f += abs(s[r1] - s[r2]); ans = max(ans, r2 - l2); f -= abs(s[l1] - s[l2]); } } for(int i=1; i&lt;=n; ++i) { int f = 0; for(int l1 = i, r1 = i, l2 = i+1, r2 = i+1; l1 &gt; 0 and l2 &lt;= n; --l1, ++l2) { for(; r1 &gt; 0 and r2 &lt;= n and f + abs(s[r1] - s[r2]) &lt;= m; --r1, ++r2) f += abs(s[r1] - s[r2]); ans = max(ans, r2 - l2); f -= abs(s[l1] - s[l2]); } } printf(&quot;%d\\n&quot;, ans); } return 0;} POJ2739 Sum of Consecutive Prime Numbers尺取水题。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;cmath&gt;using namespace std;bool prime(int x) { if(x &lt; 2) return false; int m = int(sqrt(x)); for(int i=2; i&lt;=m; ++i) if(x % i == 0) return false; return true;}int x, p[11000];int main() { int tot = 0; for(int i=1; i&lt;=10000; ++i) { if(prime(i)) p[++tot] = i; } while(true) { scanf(&quot;%d&quot;, &amp;x); if(x == 0) break; int f = 0, ans = 0; for(int l=1, r=1; l&lt;=tot; ++l) { for(; r &lt;= tot and f + p[r] &lt;= x; ++r) f += p[r]; if(f == x) ++ans; f -= p[l]; } printf(&quot;%d\\n&quot;, ans); } return 0;} CF1198A MP3题面给出 $n,I$。 $n$ - 数列 $a_1,a_2,…,a_n$ 选定一个区间 $[l,r]$，并进行操作，使$$v_i =\\begin{cases}l&amp;v_i&lt;l\\\\v_i&amp;l\\leqslant v_i \\leqslant r\\\\r&amp;v_i&gt;r\\end{cases}$$要求经过处理后，数列中不同的数的个数 $\\leqslant 2^{\\lfloor 8I/n\\rfloor}$，且使数列中被更改的位置的总数最小，求这个最小值。 解原题面较长，需耐心看题。 可先将原数列排序并离散化，记下每种数的出现次数，用前缀和优化求和。因顺序已预先排好，直接尺取 $[l,r]$，使区间内的值最大化，用总数相减得出答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N = 440000; int a[N], b[N], cnt[N], s[N], n, I, t; int power(int x) { int ans = 1, base = 2; for(; x; x &gt;&gt;= 1) { if(x &amp; 1) ans *= base; if(ans &gt; t) return ans; base *= base; } return ans;} int main() { freopen(&quot;cf1198a.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;I); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, a+i), b[i] = a[i]; if(8*I &gt; n*((int)log2(n) + 1)) { printf(&quot;0\\n&quot;); return 0; } sort(b+1, b+n+1); t = unique(b+1, b+n+1) - (b+1); int K = power(8*I/n); for(int i=1; i&lt;=n; ++i) { int p = lower_bound(b+1, b+t+1, a[i]) - b; ++cnt[p]; } for(int i=1; i&lt;=t; ++i) s[i] = s[i-1] + cnt[i]; int ans = 0x7fffffff; for(int l=1, r; l&lt;=t; ++l) { r = min(l + K - 1, t); ans = min(ans, s[t] - (s[r] - s[l-1])); } printf(&quot;%d\\n&quot;, ans); return 0;} CF180E Cubes题意简述现有一数列 $a_1,a_2,…,a_n (1\\leqslant a_i \\leqslant m)$（更准确地翻译的话，现有一排小方块，第 $i$ 个方块的颜色为 $a_i$），求在最多删去 $k$ 个位置的数后，所能获得的最长连续子段的长度，要求该子段中所有数均相同． 解释 可以不删数． $1 \\leqslant n \\leqslant 2 \\times 10^5$，$1 \\leqslant m \\leqslant 10^5$，$0 \\leqslant k &lt;n$． 样例#1：删去 $5th$ 和 $6th$． 样例#2：删去 $4th$ 和 $7th$． 样例#3：不变． 解答枚举每种颜色，这样问题就可被简化为对于每种颜色，求出其修改后的最长合法子段，可用尺取法求解。 尺取法与单调队列有关，应用范围比较小，要求原问题在满足条件的情况下，长度越长，答案越好。利用双指针 $l,r$ 及队列思想，对于同一个 $l$ 让 $r$ 尽可能延伸至最远，得到一个答案区间，$r$ 已到达最远后将与 $l$ 有关的信息弹出，对于多个答案区间找出最优解。 更详细的解释请看这里 代码将原数列分块，对每种颜色建立链表，枚举时直接访问。 链表的每个节点存储该颜色块的左右端点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 220000, M = 110000;struct node { int l, r, next;} a[N];int tmp[M], n, m, k, h[M];int main() { freopen(&quot;cf180e.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); int f = 0, tot = 0, ans = 0; for(int i=1, c; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;c); if(f == c) a[tot].r = i; else { a[++tot] = (node) {i, i, c, 0}; if(h[x]) a[tmp[c]].next = tmp[c] = tot; else h[x] = tmp[x] = tot; f = c; } } for(int i=1; i&lt;=m; ++i) { if(h[i] == 0) continue; // 无该颜色 int L = h[i], R = h[i], f = 0, sum = a[h[i]].r - a[h[i]].l + 1; for(; L; L = a[L].next) { for(; a[R].next and f + a[a[R].next].l - a[R].r - 1 &lt;= k; R = a[R].next) f += a[a[R].next].l - a[R].r - 1, sum += a[a[R].next].r - a[a[R].next].l + 1; ans = max(ans, sum); // 统计 sum -= a[L].r - a[L].l + 1; // 弹出 f -= a[a[L].next].l - a[L].r - 1; } } printf(&quot;%d\\n&quot;, ans); return 0;} CF939E Maximize!题面对于一个只包含正整数的 multiset $S$，你需要支持以下 $2$ 种操作： $1$ 找出 $S$ 的一个子集 $s$，使 $max(s)-mean(s)$ 最大，并输出这个最大值。保留十位小数。 $2$ $x$ 加入一个新数 $x$ 到 $S$ 中，保证加入的数是递增的。 解思维题。 $max$ 越大越好，$mean$ 越小越好。 结论一：子集 $s$ 中必包含 $\\max S$。 结论二：$\\forall x \\in S, x\\notin s,mean(s) &gt; x:mean(s) &lt; mean(s\\cup{x})$​ 。 证明略。 代码略丑。 为防止 WA，特判了较小的情况，维护的也略微麻烦一点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;const int N = 550000;typedef double LF;int Q, s[N];int main() { freopen(&quot;cf939e.in&quot;, &quot;r&quot;, stdin); int tot = 0, f = 0; LF sum = 0, lastans = 0, lasttype = 0; scanf(&quot;%d&quot;, &amp;Q); while(Q--) { int type; scanf(&quot;%d&quot;, &amp;type); if(type == 1) { scanf(&quot;%d&quot;, &amp;s[++tot]); lasttype = type; } else { if(lasttype == 2) { printf(&quot;%.10lf\\n&quot;, lastans); continue; } if(tot == 1) { printf(&quot;%.10lf\\n&quot;, (LF)0); lastans = 0; lasttype = 2; continue; } if(tot == 2) { lastans = s[2] - (s[1] + s[2]) / 2.0; printf(&quot;%.10lf\\n&quot;, lastans); lasttype = 2; sum = s[1], f = 1; continue; } for(int i=f+1; i&lt;tot; ++i) { if((LF)(sum + s[tot]) / i &gt; (LF)s[i]) f = i, sum += s[i]; else break; } lastans = s[tot] - (sum + s[tot]) / (f+1); printf(&quot;%.10lf\\n&quot;, lastans); lasttype = type; } } return 0;}","link":"/ruler-method/"},{"title":"数论：逆元","text":"什么是逆元？若 $ax \\equiv 1 \\pmod b$，则称 $x$ 是 $a$ 关于模 $b$ 的逆元，常记做 $a^{-1}$。 上式等价于 $ax + by = 1$，因此，一种求逆元的方法就是利用扩欧解方程 $ax + by = 1$。 显然，逆元不一定存在：其存在的充要条件为 $(a, b) = 1$。 推论：$p$ 是质数，$p$ 不整除 $a$，则 $a$ 模 $p$ 的逆元存在。 结论：在 $[0, b)$ 的范围内，$a$ 关于模 $b$ 的逆元（若存在）是唯一的。 证明：反证法，若 $a$ 有两个逆元 $0 &lt; x_1 &lt; x_2 &lt; b$，即 $ax_1 ≡ ax_2 ≡ 1 \\pmod b$，那么有 $b|a(x_2 - x_1)$ 成立。又由于 $(a, b) = 1$，因此 $b|(x_2 - x_1)$。其中 $0 &lt; x_2 - x_1 &lt; b$，产生了矛盾。 求解逆元$$ax\\equiv 1 \\pmod p$$ 扩欧上面已经提到过了，直接解方程 $ax + py = 1$ 即可。这个方法十分容易理解，而且对于单个查找效率不错，尤其是在模数比较大的时候。 这个做法在 $a,p$ 互质，但 $p$ 不是质数时也可以使用。其他方法均要求 $p$ 必须为素数。 快速幂这个做法要利用费马小定理：若 $p$ 为素数，$a$ 为正整数，且 $a,p$ 互质，则有$$a^{p-1} \\equiv 1 \\pmod {p}$$ 因此， $$\\begin{aligned}ax&amp;\\equiv 1 &amp;\\pmod p\\\\\\Rightarrow ax&amp;\\equiv a^{p-1} &amp;\\pmod p\\\\\\Rightarrow x &amp;\\equiv a^{p-2} &amp;\\pmod p\\end{aligned}$$ 用快速幂算出 $a^{p-2} \\pmod p$ 的值，这个数就是它的逆元了。 递推用于求连续的数对于同一模数的逆元。 P3811 【模板】乘法逆元首先有 $1^{-1}\\equiv 1 \\pmod p$。 然后设 $p=ki+r(1&lt;r&lt;i&lt;p)$，即 $k$ 是 $\\frac{p}{i}$ 的商，$r$ 是余数。 再将这个式子放到模 $p$ 意义下，有 $$k\\times i+r \\equiv 0 \\pmod p$$ 两边乘上 $i^{-1}r^{-1}$，有 $$\\begin{aligned}k\\times r^{-1}+i^{-1}&amp;\\equiv 0 &amp;\\pmod p\\\\\\Rightarrow{}i^{-1}&amp;\\equiv -k\\times r^{-1} &amp;\\pmod p\\\\\\Rightarrow{}i^{-1}&amp;\\equiv -\\lfloor \\frac{p}{i} \\rfloor*(p \\bmod i)^{-1} &amp;\\pmod p\\end{aligned}$$ 于是，我们就可以递推求得逆元了。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;long long inv[int(3e6+10)]; int n, p;int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;p); inv[1] = 1; for(int i=2; i&lt;=n; ++i) { inv[i] = p-(p/i)*inv[p%i]%p; } for(int i=1; i&lt;=n; ++i) printf(&quot;%lld\\n&quot;, inv[i]); return 0;} 阶乘首先有这样一个结论：$\\frac{1}{n!}=\\frac{1}{n}\\times\\frac{1}{(n-1)!}$，即 $(n-1)!$ 的逆元等于 $n!$ 的逆元乘 $n$。 因此，我们求出 $n!$ 的逆元然后逆推，可以求出 $1!,2!,\\dots,n!$ 的逆元；又 $\\frac{1}{n!}\\times(n-1)!=\\frac{1}{n}$，$n!$ 的逆元乘上 $(n-1)!$ 可以得到 $n$ 的逆元。","link":"/num-inv/"},{"title":"未来","text":"“When you have that last piece of the jigsaw, everything will, I hope, be clear. . . .” 「引子」 我听着《我们仍不知道那年中美合拍的日子》，突然，章老师走了进来。我打开空气净化器，看了看垃圾桶里闪闪发光的律师函。 总之，故事就这样开始了。 「初雪」 六老师签售会当天，现场热闹的很。 “六爷爷……孙悟空到底有几个女朋友啊？” “所以我经常说，”章承恩回头望了望摄像机。“戏说不是胡说，改编不是乱编。……一个民族……文化……谢罪……拿着棒子这么走……” 这时，“啊——”的一声惨叫传来。六水线旁，一名男子倒在地上，已经没有了气息。 —— “死者名叫戴杉并，29 岁，在金猴皮鞋厂工作，不过似乎并不是他的主业。在他的电脑里，我们找到了很多线索表明这位海军上将……”三谷（Mitani）汇报道。 “行了行了，”我不耐烦地打断道，“我名侦探江户川（Edogawa）可不是来听你 × × 的。说吧，名单上还有谁？” “你怎么知道……”三谷失声道。 “喂喂，”我敲了敲桌子，“就你这智商还想干这事？告诉你吧，作者看你蠢成这样，特意派我来带你走向人生巅峰的。所以，现在——” 「正宫」 那天，我听闻杨洁导演去世了，准备好挽联，前去吊唁。 灵堂的气氛非常肃穆。那边六老师竟也换上了一袭黑衣，毕恭毕敬地垂下头，低声道： “今年下半年……中美合拍……杨洁导演满意……多多支持。” 我沉痛地走出灵堂，外面的天已经黑了。天上的几颗星星闪着明灭的冷光。 我低头看了看手表：十三时二十六分。 难道是……？！ 我缓而又缓地回过头。气势恢宏的大堂已经了无踪影。一望无际的原野上，章老师和几个吊唁的人似乎也意识到了什么，震悚地踅向四周。 突然，一道白痕闪了光，现了一个人，急匆匆地跑了过来。我看到他那惊愕之下掩着的笑意的脸，不禁一声哀叹： “唉！又是这个蠢货！” 就在这时，高速跑动的他像是被什么绊了一下，“咚”地一声趴在了地上。 额……我不得不承认的是，虽然作者的确缺乏才华（很多时候都要靠我自己的演技），但在关键问题的处理上却是一点也不含糊。 我一边想着，一边向人群走去。 「Q&A」 只听得章老师对着全国人民破口大骂道： “等我回去以后，一个一个给你们寄律师函……对了，今年下半年……” :::default Question：人类的本质是什么？ Wrong Answer：复读机 Accepted：人类的本质是什么？ ::: 「设计实验」 （好像又扯远了……说正事） “必须灭杜！”桌对面的一个人大声喊道。我回过神来。 我皱起眉。那个名叫马三傻（Ma Wasabi）的人又来了。 旁边的那个人似乎也毫无兴致，一脸心不在焉地附和着。 “……灭杜使我成为一个完整的人。？” “……啊？对对对，一点也不能剩。”上原（Uehara）答道。 “咦，怎么不见时川（Tokikawa）来？”我向邻座的新见（Shimmi）问道。他摇摇头。 “不知道。许是睡过头了吧。” 话虽这么说，但一个小时后，时川还没有下来。我因闲得无聊，便打开「神奇动物园」。这是一款专为睿智人群设计的高端手游，画面精良，很适合用来打发时间。 “时川还不下来？”工藤（Kudo）不耐烦道。 “要不上去看一下吧，”我提议道。 我同工藤到得他的房间口，敲了敲门。没有应声。 “等我给他打个电话。”工藤拿出寻呼机。电话铃响到第十三下时，他摇头。“没有人接。” 我们没有办法，只好找来了服务人员。我推开门：这里并没有人。 “他的背包还在，应该是没准备长时间外出的。”工藤道。 我点点头。看来也不会有什么发现了。“走吧，”我说道。 工藤和我正要离开之时，我的目光落在了浴室的门框上。门的合页上，圆珠笔迹的刻痕： + '5' (18) 65 ？ 我决定不再多想。 &amp;emsp; 我们回到大厅。 “找到了吗？”五反田（Gotanda）问道。工藤摇头。 “已经十二点了，”高桥（Takahashi）道。“要不先吃饭吧。” &amp;emsp; 餐桌上的气氛非常肃穆。大家都默默吃着，seldom next 的两个人小声低语。时川到底去了哪里呢？ 这时，店员端来了两面金黄的油炸哥布林。十数双筷子顿时一齐扑了过去。我没有动。 “天一……不来一块？”新见狼吞虎咽地吃着。 “奇怪，”我喃喃道，“总觉得有什么不对。” “哪里不对了？我告诉你，完整的哥布林可是稀世珍品，难不成你想吃被滚木碾过一遍的？”他自谓幽默地笑笑，“快点吧，凉了就不好吃了。” 我取下一片，仔细检查一番；没有 clue。看来我的第六感最近也变得不准了啊，我苦笑着夹起放入嘴中。 ——我呸呸几口吐了出来。“哥布林有毒！” 旁边的人惊诧地看了我一眼，随即也下意识地做了。 “什么？……有毒？” “我们吃着什么事都没有呵……哪里有毒了？” 但我既不要无谓的辩解了。循着水木（Mizuki）惊惧的目光，工藤满口白沫地倒在了桌上，一下最后的抽搐。 「端口Ｉ」 警察匆忙赶到现场。 “初步判断死者应该是死鱼（Diefish）氰化物中毒，”法医汇报道，“不过具体原因还要等解剖结果。” 他点点头。 &amp;emsp; 警察和服务员简单地交谈了几句，走了。房间里笼罩着一团滞重的沉默。 “S 失踪了，Q 死了，”我自言自语道，“下一个就是我了。” 「DNS错误！」 然而这个世界已不存在规则了。 「Loading . . .」 “好嗨哟！”有人在我耳边喊道。 “嗨ニマ啊，要动手赶快！”我不满道。 “好的好的，”那人说着掏出一卷绳子。“我打算勒死你。不过分吧？” “能换个更舒服的吗？这个绳子勒着好疼。”我问道。 他摇了摇头。“恐怕没有机会了。” “喂！”已经喘不过气的我奋力嚷道。“剧本可不是这么写的！” “我知道，”他平静地说。“你还有什么要说的吗？” “你……”我很生气。 我边生气边想着明天早上吃什么。 「你们家的网炸了？」 “江户川先生昨天晚上被人不改剧本就弄死了。”我悲伤地告诉了另外的几个人。 大家都非常惋惜。 「460？再见」 两个月后。 我和高桥，新见，五反田四个人准时上了火车。 “出口竟然没被堵死，”我对新见说道。 “是啊；话说也真是的，十二个人最后就剩下了四个，连盘身份局都凑不齐……真是无聊。”新见摇头。 “对了，马三傻是怎么死的来着？”五反田（他似乎一直对这件事念念不忘）第 9102 次问道。 “唉，只有他死的最惨啊。你说是不是？”新见满脸泪光地笑了起来。 “没有办法……”我鼻子一酸。“他那天本来想去地沟弄点早点吃，结果刚一出门就让火车给撞死了……”我不由自主地哭了起来；高桥，新见，五反田也不甘示弱，一瞬间，整个车厢里哀嚎声，哭声，抽泣声，抹泪声揉作一团，是一浪高过一浪，过了好久，车厢里还回荡着一股海风的味道。 “三谷被人用诺基亚砸死了；R 上电梯时被从后面推了一下，掉到电梯井里摔死了；Y ……”五反田回忆道。 “对了，”高桥突然叫道，“还记得时川吗？” “他可能永远都不会回来了。”我推开窗。 “为什么？”新见问道。只听得五反田似有似无的抽泣声。 “他去了另一个地方。”半晌，我长吁一口气。“一个更值得的 occasion。” “比我们要去的这个地方更值得？”高桥问道。我用力点了点头。 之后的很长一段时间里没有人说话。 我久久地望向窗外。又是在这不经意的一刹，透过窗玻璃的反光，高桥指着我，对着正要说出什么惊天秘密似的新见使了个眼色。 我叹了口气。他们果然早已知道了一切。我所为之付的一番心血，并诩诩然以为天衣无缝的计划，不过是跳梁小丑罢了；一切都发生在那么短短的，不到十秒的时间里，可对我来说却像极了一生。 我的视线依然投在远方。看着看着，我渐渐不明白有多少东西可以称得上是变化了。世界本来就没有形状。 我想说些什么，但终究说不出口。我便一直是个如此懦弱的人。 即使是踏上这辆撞死了马三傻的火车。 “还有多长时间到？”高桥看了看手表。 “很快，”我答道。 “诶我突然有个想法，”五反田打起精神，“如果我们到站了还不下车，那么它会载我们到哪里？” “向前。” “Forever?” “Yes.” “可是……是你创造了这一切吧？” 我默然。新见好像打开了「神奇动物园」。 “Give him a rest 吧，”高桥说，“那些事不必再提了。” 我出神地望着车厢的一点。 “吱——”传来汽笛的轰鸣声。 “我们到了，”新见说。 太阳钻了出来。一阵熹微，暖融融地照在我们的脸上。 “I say . . . 我们应该给自己取个新名字吧？”五反田提议道，“毕竟西湖六月初嘛。我呢，就叫 MRC 好了。” “我叫大辣鸡。”新见若有所思道。 “我叫大肥猪。”高桥毫不犹豫地说出了自己的心声。 “所以……你呢？”所有人的目光望向我。我惊了一下，笑容凝结在脸上。就在那边。 我眨了眨眼；一切如故。 原来我们是到了这里啊，我想道。不过也无所谓了。 新见和五反田 paradox 地对视着。 “天一有事吗……”高桥迟疑了一下，问道。 “没事没事，”我摆摆手，“刚才想事来着。” 太阳沉了下去。最初的一道光。 “高桥？”我唤道。她侧过脸。 “怎么啦？” “早晨来临了。” （BGM :ノルウェイの森） （WOW） （&lt;・)))&gt;&lt;&lt;）","link":"/future/"},{"title":"沼","text":"&amp;emsp;&amp;emsp;沼底的尽头，是一片覆压百万里的金色宫殿。大殿的外墙上，布满了交通错落的铭文，似是在昭示着什么。 &amp;emsp;&amp;emsp;一天，一个女孩闯入了这里。一阵和煦的金光顿时笼罩了她；俄而散去，四下无痕。 &amp;emsp;&amp;emsp;没过了几个小时，又进来了一个男孩，像是在呼唤着什么（或是呼唤着谁）。金光一如既往地扩散开来；一道道刻痕爆裂而开，流转着金黄的光珠，跳动着淡蓝的光焰—— &amp;emsp;&amp;emsp;但一切终又重归了平静。唯一不同的是男孩进入的那座殿堂，蒙上了雪一般的白色，白得灼痛了双眼—— &amp;emsp;&amp;emsp;殿中央，一个男孩旁边躺着一个女孩。在渐渐模糊的视野里，他们站起了身，向沼底的深处走去。突然地，一座一座的宫殿轰然倒下，杳然无踪，连瓦砾都浸没在夕阳里。 &amp;emsp;&amp;emsp;他们的面前是一片水原。 &amp;emsp;&amp;emsp;“没有再向前的路了呢，”男孩道。 &amp;emsp;&amp;emsp;“那⋯⋯要不就在这里？”女孩问道。 &amp;emsp;&amp;emsp;男孩没有回答。空无一物的海面上，反射着太阳的光辉。 &amp;emsp;&amp;emsp;“这里⋯⋯没有我能回去的地方了。” &amp;emsp;&amp;emsp;女孩的心微微一颤。 &amp;emsp;&amp;emsp;黑云压了下来。男孩看向她的眼睛；那双湛蓝的天空里，像是有两束晶莹的泪在燃烧。 &amp;emsp;&amp;emsp;“你回去吧，”男孩在岸边坐下。冰冷的寂静刺穿了黑暗。“你还有更重要的东西。” &amp;emsp;&amp;emsp;“——那你呢？” &amp;emsp;&amp;emsp;“我？……雨女无瓜。” &amp;emsp;&amp;emsp;女孩再次担忧地看了他一眼，转过身去。五彩斑斓的黑洇染了苍穹，等男孩回过神来，已是孤身一人。 &amp;emsp;&amp;emsp;他向前迈了一步。一座巨浪打在他脚下，险些将他卷为齑粉。要是她还在这里的话，说不定已经被撕碎了呢，他想。 &amp;emsp;&amp;emsp;他轻轻咬了咬唇，刚挤出的笑容粉碎在脸上。他自知最多也就能到这里了，还是回去为好。 &amp;emsp;&amp;emsp;他拾起石子掷向水中；石子弹跳着沉了下去。 &amp;emsp;&amp;emsp;黑夜却还不急着到来。太阳迸发出血红的光芒，向西方吃力地转动着。 &amp;emsp;&amp;emsp;男孩在水底见到了他的朋友。一只巨大的鲲。 &amp;emsp;&amp;emsp;“还要在这里待多久？”男孩试探着问道。 &amp;emsp;&amp;emsp;“多久？”鲲摇了摇尾巴，“我不知道。” &amp;emsp;&amp;emsp;“……真的没打算离开嘛？” &amp;emsp;&amp;emsp;“离开？离开幹什么？”鲲又摇了摇尾巴，脸上露出奇异的神色来。男孩平静地看向他。 &amp;emsp;&amp;emsp;“——没事了。” &amp;emsp;&amp;emsp;男孩侧过头去，脸上始终没有浮现过可以称之为表情的东西。四下的水雾扩散开来，像狰狞的水母的触手一样，箍紧了沼底的天空。 &amp;emsp;&amp;emsp;自非亭午夜分，不见曦月。 &amp;emsp;&amp;emsp;女孩坐在大殿的中央，看着周遭的残壁在烈火中熔释。火光给她的脸染成了金色；凤凰在她的脑畔上盘旋，就像穿行在无边的旷野，有着挣脱一切的力量。 &amp;emsp;&amp;emsp; “如何？”她问道。 &amp;emsp;&amp;emsp;“还好吧，”他没有抬头，“就是还得再适应一点时间。需要重铸的事情太多了。” &amp;emsp;&amp;emsp;“或许吧，”她附和道。 &amp;emsp;&amp;emsp;她的目光望向窗外：雪花从天中飘落，给葱茏的树叶抹上了一层白霜。 “抱歉了。” 男孩点了点头。 她的瞳孔一缩。若是重开一次，她想，这些话本不应该被说出来的。她会不会…… 男孩和他都在等待着什么。她定定地望向他。 四面的风静了下来。 &amp;emsp;&amp;emsp;女孩回到了水原——or she expected so。一团团死掉的水嘶叫着从湖底的罅隙里鱼贯而出，取而代之的，是一条条岩浆的河；大地像饼干一样脆生生地从中间裂开，散落出无数如粉如沙的碎片，点缀在覆压百万里的橘红的海洋中，就像一口沸腾的锅，把晚霞也煮成了一般颜色。 &amp;emsp;&amp;emsp;她回过头：来时的路早已淹没在了递归的沼泽里。 &amp;emsp;&amp;emsp;女孩迟疑了一下，随即向着东方走去。月亮追赶着太阳，终于将它逼到了地平线下。 &amp;emsp;&amp;emsp;她一次也没有回头。","link":"/numa/"},{"title":"年轻人不讲武德","text":"缘起健身房的年轻后生不讲武德偷袭马老师，把马保国老师的眼睛给蹭了一下 音译啊朋友们好啊，我是浑元形意太极门掌门人马保国。 刚才有个朋友，问我马老师发生甚么事了，我说怎么回事，给我发了几张截图。我一看，嗷，原来是左天，有两个年轻人，30多岁，一个体重90多公斤，一个体重80多公斤。塔们说，诶，有一个说是，我在健身房练功，颈椎练坏了，马老师你能不能教教我浑元功法，矮…帮助治疗一下我的颈椎病。我说可以。 我说你在健身房练死劲儿，不好用，塔不服气。诶，我说小朋友，你两个手来折我一个手指头，塔折不动，他说你这没用，我说我这个有用，这是化劲儿。传统功夫是讲化劲儿的，四两拨千斤。二百多斤的英国大力士都握不动我的一个手指头，啊。他非跟我试试，我说可以。 诶，我一说，他啪就站起来了。很快啊！然后上来就是一个左正蹬，一个右鞭腿，一个左刺拳，我全部防出防出去了啊。防出去以后，自然就是，传统功夫以点到为止。右拳放到他鼻子上没打他，我笑一下准备收拳，因为这时间，按传统功夫的点到为止，他已经输了。如果这一拳发力，一拳就把他鼻子打鸪鹧了。放在鼻子上没有打他，他也承认，我先打到他面部。他不知道拳放在了鼻子上，他承认我先打到他面部，啊！我收拳的时间不打了，他突然袭击，左刺拳来打我脸，啊。我大E了啊，没有闪。矮…他的左拳给我眼，啊右眼，蹭了一下。但没关系啊，他也说，啊，他截图也说了，两分多钟以后，当时流眼泪了，捂着眼，我说婷婷，然后两分钟钟以后，两分多钟以后，诶…就好了。 我说小伙子你不讲武德，你不懂。马老师对不起对不起我不懂规矩，啊，他说他是乱打的。他可不是乱打的啊，蹬蹬，鞭腿，左刺拳，训练有素。后来他说他练过三四年泰拳，啊，看来是有备而来！这两个年轻人不讲武德，来，骗，来，偷袭，我69岁的老同志。这好吗？这不好。我劝，这位年轻人耗子尾汁，好好反思，以后不要再犯这样的聪明，小聪明，啊，呃…武林要以和为贵，要讲武德，不要搞窝里斗。谢谢朋友们！ 后续一些已经搜不到的视频。 一 武 林 高 手白鼠。 二 中 华 武 德台词混剪。 三 马和耗子（完整版） 四 马保国 × 王者荣耀：国服蒙恬 国服婉儿五 8848“耗子尾汁”手机六 ⚡吉 祥 三 马⚡联动。 七 比三鞭更强！马保国的松活弹抖闪电五连鞭！原片。 收尾","link":"/mabaoguo/"},{"title":"浅谈 Splay（一）","text":"1. 右旋（Right Rotation）观察每个节点的变化，其中每个节点都有指向其父节点的指针没有画出。 ①②③处节点连接有变化。 （1）$Q$ 的左子树修改为 $P$ 的右子树的内容即 $B$ 成为 $Q$ 的左子树， $B$ 的父节点是 $Q$ 。 12q-&gt;left = p-&gt;right; p-&gt;right-&gt;father = q; 注意 P​ 可能没有右子树（即不存在 P-&gt;right 节点）。 修改如下： 12q-&gt;left = p-&gt;right; if(p-&gt;right != NULL) p-&gt;right-&gt;father = q; （2）$P$ 的右子树修改为 $Q$ ，且同时 $Q$ 的父节点修改为 $P$ 。12p-&gt;right = q; q-&gt;father = p; 注意 Q 和 P 的左右子树有变化，所以 Q,P 的信息需要重新维护。 1update(q); update(p); //先Q后P （3）$R$ 的子树应该修改为 $P$需要判断 $Q$ 是 $R$ 的哪种子树，左子树则 $P$ 给 $R$ 的左子树，否则给右子树。 全局变量 $root$ 记录树根。 特判 $Q$ 有可能就是树根（即 $R$ 不存在）； 12345678if(r == NULL) { p-&gt;father = NULL; root = p; return;}if(q == r-&gt;left) { r-&gt;left = p; p-&gt;father = r;} else { r-&gt;right = p; p-&gt;father = r;} 整理一下，不管 Q​ 有无父节点，P 的父节点均修改为 Q 的父节点。 123456p-&gt;father = r;//记录树根if(r == NULL) { root = p; return; }//判断P连到R的那颗子树if(q == r-&gt;left) r-&gt;left = p; else r-&gt;right = p; Code : 12345678910111213141516171819202122void right_rotate(node *p) { node *q = p-&gt;father; //记录p的父节点 node *r = q-&gt;father; //记录p的父节点的父节点 //操作1 q-&gt;left = p-&gt;right; if(p-&gt;right != NULL) p-&gt;right-&gt;father = q; //操作2 p-&gt;right = q; q-&gt;father = p; //维护节点信息（注意此处可暂不维护P） update(q); //update(p); //操作3 p-&gt;father = r; if(r == NULL) { root = p; return; } if(q == r-&gt;left) r-&gt;left = p; else r-&gt;right = p;} 2、左旋（Left Rotation）同理右旋，只是①②不同。 Code : 12345678910111213141516171819202122void left_rotate(node *p) { node *q = p-&gt;father; //记录p的父节点 node *r = q-&gt;father; //记录p的父节点的父节点 //操作1 q-&gt;right = p-&gt;left; if(p-&gt;left != NULL) p-&gt;left-&gt;father = q; //操作2 p-&gt;left = q; q-&gt;father = p; //维护节点信息 update(q); //update(p); //操作3 p-&gt;father = r; if(r == NULL){ root = p; return; } if(q == r-&gt;left) r-&gt;left = p; else r-&gt;right = p;} 3、双旋不断旋转 $X$ 节点，为了保证复杂度，需要连续旋转两次且旋转的次序不同。 定义 $X$ 的父节点为 $Y$，$Y$ 的父节点为 $Z$。 （1）$X$ 和 $Y$ 同时是其父节点的左子树或者同时是各自父节点的右子树（即同侧）。这时我们要进行两次旋转，**先旋转 $Y$，再旋转 $X$**。 同左旋转演示图如下： 同右旋转演示图如下： （2）$X$ 和 $Y$ 是其父节点的左、右子树，不同侧（即一左一右或一右一左）。这时我们只要 旋转两次 X​ 即可。 （3）判断 $X$ 节点如何旋转。$X$ 是其父节点的左子树则右旋，否则左旋。 $X$ 若是它父节点左子树返回 true，否则返回 false： 123456789bool getlr(node *p) { return (p-&gt;father-&gt;left == p);} //选择合适的旋转方式void rotate(node *p) { if(getlr(p)) right_rotate(p); else left_rotate(p);} 4、旋转到根将 $X$ 旋转到根是 splay 的关键，为了保证复杂度，只要对 $X$ 节点操作，操作后就要将其旋转到根。 如何旋转到根： 一步旋转就可以到根，进行单旋； 两步或两步以上，可以不断使用双旋。 设计函数 splay(p,q) 将 $P$ 旋转到 $Q$ 下方。 q == NULL 表示 $P$ 旋转到了根； while $P$ 至少两次旋转才能到达：双旋； if $P$ 还差一步满足条件：单旋。 Code : 1234567891011121314void splay(node *p, node *tar) { while(p-&gt;father != tar and p-&gt;father-&gt;father != tar) { if(getlr(p) == getlr(p-&gt;father)) { rotate(p-&gt;father); rotate(p); } else { rotate(p); rotate(p); } } if(p-&gt;father != tar) rotate(p); update(p); //优化（避免重复维护）}","link":"/about-splay/"},{"title":"网络流：Dijkstra 求费用流","text":"注：下文中的边权 $w$ 均表示费用 $f$。 Dijkstra 不能求有负权边的最短路，所以我们可以对网络 $G$ 中的每一个点设置一个势函数 $h(u)$，以满足在与原图等价的新图中的边权非负。 最短路在任意残留网络中的任意边 $(u,v)$ 都需要满足：$$w_{u, v}+h(u) - h(v)≥0$$令图 $G$ 的等价图为 $G’$，其对应的边 $(u,v)$ 的权值为$$w’{u,v} = w{u,v} + h(u) - h(v)$$因此，对于原图中的任意一条路径 $(u_1,u_2,\\dots,u_k)$，它在 $G$ 中的权值为$$w_{u_1,u_2}+w_{u_2,u_3}+\\dots+w_{u_{k-1},u_k}$$在 $G’$ 中的权值可化简为$$w_{u_1,u_2} + w_{u_2,u_3} + \\dots + w_{u_{k-1}, u_k} + h(u_1)-h(u_k)$$所以，在 $G’$ 求出的路径都可以对应到 $G$ 上。 令 $d_{u}$ 为图 $G$ 中源点 $s$ 到点 $u$ 的最短路径，图 $G’$ 中为 $d’_{u}$，显然有 $$d_{u,v} = d’_{u,v}-h(u)+h(v)$$所以我们只需要求 $G’$ 的最短路径，就能对应回原图的最短路径。 势函数初值如果网络 $G$ 初始边权非负，则令 $h(u)=0$ ，否则可令 $h(u) = dis[u]$（用 SPFA 解决）。 证明略。 维护每次增广后，令 $h(u)=h(u)+dis[u]$ 即可。 证明：对于残余网络上的任意边 $(u,v)$，均有$$dis[u]+w_{u,v}+h(u)-h(v)≥dis[v]$$移项，得$$w_{u,v}+(h(u)+dis[u])-(h(v)+dis[v]) \\geq 0$$证毕。 P3381 ［模板］最小费用最大流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlineconst int N = 5500, M = 55000, INF = 0x3f3f3f3f;struct point { int u, val; point(int _u = 0, int _val = 0): u(_u), val(_val) {} bool operator &lt; (const point &amp;o) const { return val &gt; o.val; } };priority_queue &lt;point&gt; q;struct node { int u, v, w, f, next; node() {}} e[M &lt;&lt; 1];int head[N], tot = 0;il void add(int u, int v, int w, int f) { e[tot].u = u, e[tot].v = v, e[tot].w = w, e[tot].f = f; e[tot].next = head[u]; head[u] = tot++;}int h[N], dis[N], flow[N], pre[N];int n, m, s, t;int maxflow = 0, mincost = 0;il bool dijkstra() { memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); memset(pre, -1, sizeof pre); dis[s] = 0; q.push(point(s, 0)); while (!q.empty()) { int u = q.top().u, val = q.top().val; q.pop(); if (val &gt; dis[u]) continue; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].v; if (e[i].w and dis[v] &gt; dis[u] + e[i].f + h[u] - h[v]) { pre[v] = i; flow[v] = min(flow[u], e[i].w); dis[v] = dis[u] + e[i].f + h[u] - h[v]; q.push(point(v, dis[v])); } } } return dis[t] != INF;}il void check() { for (int p = pre[t]; p != -1; p = pre[e[p].u]) { e[p].w -= flow[t]; e[p^1].w += flow[t]; } maxflow += flow[t]; mincost += (dis[t] - h[s] + h[t]) * flow[t]; for(int i=1; i&lt;=n; ++i) h[i] += dis[i];}int main() { freopen(&quot;p3381.in&quot;, &quot;r&quot;, stdin); memset(head, -1, sizeof head); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i=1, u, v, w, f; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;w, &amp;f); add(u, v, w, f); add(v, u, 0, -f); } while (dijkstra()) check(); printf(&quot;%d %d\\n&quot;, maxflow, mincost); return 0;}","link":"/network-flow-dijkstra/"},{"title":"涉江","text":"&amp;emsp;&amp;emsp;E 座的尽头是一扇窗。她喜欢伏在那里的窗棂上，很多个课间。窗外是一幢天井；三面环楼，夐不见曦。 &amp;emsp;&amp;emsp;天井的中央是一台鱼池。一到每年新生入学的时候，鱼们便如笋般冒了出来，流水潺潺，清荣峻茂；整个学校也像鱼池一样变得活络了起来。人们的脸上总是挂着笑容；鱼池旁也缀上了很多人影，来来往往的。 &amp;emsp;&amp;emsp;她的背后是一道走廊，连结着初中部和高一年级。原则上，高一的饮水机坏了，才会有人从这里经过，就比如这几天；那边的机器更高端，相传有四个水龙头。她听高三的学长们说，原先这里本是熙熙攘攘，那一年却突然间就变了天。或许今后也会有那一年吧。走廊里时常有行为艺术家们走过，小嘴抹蜜，应节而舞，免不了一群男女从旁指点，逼逼赖赖。也有三三两两的女生们，攒聚喁喁。偶尔天亮的时候，也会有许多男同，两两联会，而姐妹相称。 &amp;emsp;&amp;emsp;但这些都与她无关。她相信未来，相信辰星在无边的旷野，正如大多数人一样。她可能还没有想到过那样的一天，雪花浸满了每一个角落。空自，她守望着梦乡。 &amp;emsp;&amp;emsp;楼下有一群人走过，为首的迨着球。教室里传来九日的声响。他似乎看见了她。她的思绪仍然飘在远方，漠然颔首。 &amp;emsp;&amp;emsp;他们走上楼来。他一迳向 E 座的尽头走去。值勤的女生认出了他，嘴唇微微动了动，遽把脸扭了过去，没有作声。他也照着做了。那扇窗静静地在那里；窗闩没有扣严，被一阵狂风吹散了。他正要上前，风却一瞬间弱了下去。太阳拐了一个弯；和煦的光洒遍了他和她的窗。微风摩挲着窗扇，像一只系在法线上的蝴蝶。兰麝香仍在，珮环声渐远。","link":"/she-jiang/"},{"title":"网络流：模板","text":"P3376 网络最大流（Dinic）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 11000, M = 110000;const int INF = 0x7fffffff;struct node { int u, v, w, next;} e[M &lt;&lt; 1];int cur[N], h[N], tot;int dfn[N], ans, n, m, s, t;void add(int u, int v, int w) { e[tot] = node({u, v, w, h[u]}); cur[u] = h[u] = tot++;}bool bfs() { memset(dfn, 0, sizeof dfn); queue&lt;int&gt; q; dfn[s] = 1; q.push(s); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and !dfn[v]) { dfn[v] = dfn[u] + 1; q.push(v); if(v == t) return true; } } } return false;}int dfs(int u, int low) { if(u == t) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next) { int v = e[i].v; cur[u] = i; if(e[i].w and dfn[v] == dfn[u] + 1) { int f = dfs(v, min(w, e[i].w)); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}void dinic() { while(bfs()) { memcpy(cur, h, sizeof cur); ans += dfs(s, INF); }}int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); memset(h, -1, sizeof h); for(int i=1, u, v, w; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, 0); } dinic(); printf(&quot;%d\\n&quot;, ans); return 0;} P3381 最小费用最大流（单路增广）Dijkstra12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlineconst int N = 5500, M = 55000, INF = 0x3f3f3f3f;struct point { int u, val; point(int _u = 0, int _val = 0): u(_u), val(_val) {} bool operator &lt; (const point &amp;o) const { return val &gt; o.val; } };priority_queue &lt;point&gt; q;struct node { int u, v, w, f, next; node() {}} e[M &lt;&lt; 1];int head[N], tot = 0;il void add(int u, int v, int w, int f) { e[tot].u = u, e[tot].v = v, e[tot].w = w, e[tot].f = f; e[tot].next = head[u]; head[u] = tot++;}int h[N], dis[N], flow[N], pre[N];int n, m, s, t;int maxflow = 0, mincost = 0;il bool dijkstra() { memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); memset(pre, -1, sizeof pre); dis[s] = 0; q.push(point(s, 0)); while (!q.empty()) { int u = q.top().u, val = q.top().val; q.pop(); if (val &gt; dis[u]) continue; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].v; if (e[i].w and dis[v] &gt; dis[u] + e[i].f + h[u] - h[v]) { pre[v] = i; flow[v] = min(flow[u], e[i].w); dis[v] = dis[u] + e[i].f + h[u] - h[v]; q.push(point(v, dis[v])); } } } return dis[t] != INF;}il void check() { for (int p = pre[t]; p != -1; p = pre[e[p].u]) { e[p].w -= flow[t]; e[p^1].w += flow[t]; } maxflow += flow[t]; mincost += (dis[t] - h[s] + h[t]) * flow[t]; for(int i=1; i&lt;=n; ++i) h[i] += dis[i];}int main() { memset(head, -1, sizeof head); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i=1, u, v, w, f; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;w, &amp;f); add(u, v, w, f); add(v, u, 0, -f); } while (dijkstra()) check(); printf(&quot;%d %d\\n&quot;, maxflow, mincost); return 0;} SPFA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 5500, M = 110000, INF = 0x3f3f3f3f;struct node { int u, v, w, f, next;} e[M];int h[N], tot = 0;void add(int u, int v, int w, int f) { e[tot] = {u, v, w, f, h[u]}; h[u] = tot++;}int pre[N], flow[N], dis[N];bool vis[N];int n, m, s, t, maxflow, mincost;bool spfa() { memset(pre, -1, sizeof pre); memset(vis, false, sizeof vis); memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); queue&lt;int&gt; q; q.push(s); vis[s] = true; dis[s] = 0; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = false; for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and dis[v] &gt; dis[u] + e[i].f) { dis[v] = dis[u] + e[i].f; pre[v] = i; flow[v] = min(flow[u], e[i].w); if(!vis[v]) { q.push(v); vis[v] = true; } } } } return dis[t] != INF;}void check() { for(int p = pre[t]; p != -1; p = pre[e[p].u]) { e[p].w -= flow[t]; e[p^1].w += flow[t]; } mincost += dis[t] * flow[t]; maxflow += flow[t];}int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); memset(h, -1, sizeof h); for(int i=1, u, v, w, f; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;w, &amp;f); add(u, v, w, f); add(v, u, 0, -f); } while(spfa()) check(); printf(&quot;%d %d\\n&quot;, maxflow, mincost); return 0;} LOJ115 无源汇有上下界可行流（超级源汇）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlineconst int N = 220, M = 11000, INF = 0x3f3f3f3f;struct node { int u, v, w, next;} e[M * 6];int head[N], cur[N], tot = 0;il void add(int u, int v, int w) { e[tot] = (node) {u, v, w, head[u]}; head[u] = tot++;}int h[N], n, m, ss, tt;il bool bfs() { //分层 memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int&gt; q; q.push(ss); h[ss] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = head[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and !h[v]) { h[v] = h[u] + 1; if(v == tt) return true; q.push(v); } } } return false;}int dfs(int u, int low) { if(u == tt) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next, cur[u] = i) { int v = e[i].v; if(e[i].w and h[v] == h[u] + 1) { int f = dfs(v, min(w, e[i].w)); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}int tflow = 0, sflow = 0;il void dinic() { for(int i = head[ss]; i != -1; i = e[i].next) sflow += e[i].w; //出流量 while(bfs()) dfs(ss, INF); for(int i = head[tt]; i != -1; i = e[i].next) tflow += e[i].w; //入流量 if(sflow == tflow) { //满流 printf(&quot;YES\\n&quot;); for(int i=0; i&lt;tot; i+=6) printf(&quot;%d\\n&quot;, e[i+1].w + e[i+5].w); //反边流量和 } else printf(&quot;NO\\n&quot;); }int main() { freopen(&quot;loj115.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(head, -1, sizeof head); ss = 0, tt = n+1; for(int i=1, u, v, l, h; i&lt;=m; ++i) { //建图 scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;h); add(u, tt, l); add(tt, u, 0); add(ss, v, l); add(v, ss, 0); add(u, v, h-l); add(v, u, 0); } dinic(); return 0;} 有源汇有上下界（转无源汇，然后断边）最大流（顺流增广）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 220, M = 22000, INF = 0x3f3f3f3f;struct node { int u, v, w, next;} e[M];int head[N], cur[N], tot = 0;void add(int u, int v, int w) { e[tot] = (node) {u, v, w, head[u]}; head[u] = tot++; e[tot] = (node) {v, u, 0, head[v]}; head[v] = tot++;}int h[N], in[N], n, m, s, t, ss, tt, sflow = 0, tflow = 0;bool bfs(int s, int t) { memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int&gt; q; q.push(s); h[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = head[u], v; i != -1; i = e[i].next) { v = e[i].v; if(e[i].w and !h[v]) { h[v] = h[u] + 1; if(v == t) return true; q.push(v); } } } return false;}int dfs(int u, int low, int t) { if(u == t) return low; int w = low; for(int i = cur[u], v; i != -1; i = e[i].next, cur[u] = i) { v = e[i].v; if(e[i].w and h[v] == h[u] + 1) { int f = dfs(v, min(w, e[i].w), t); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}int main() { //freopen(&quot;loj116.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); ss = 0, tt = n+1; memset(head, -1, sizeof head); for(int i=1, u, v, l, h; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;h); in[u] -= l; in[v] += l; add(u, v, h-l); } for(int i=1; i&lt;=n; ++i) { if(!in[i]); else if(in[i] &gt; 0) { sflow += in[i]; add(ss, i, in[i]); } else { add(i, tt, -in[i]); } } add(t, s, INF); while(bfs(ss, tt)) tflow += dfs(ss, INF, tt); if(sflow != tflow) { printf(&quot;please go home to sleep\\n&quot;); return 0; } for(int i = head[ss]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; for(int i = head[tt]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; int sum = e[--tot].w; e[tot-1].w = e[tot].w = 0; while(bfs(s, t)) sum += dfs(s, INF, t); printf(&quot;%d\\n&quot;, sum); return 0;} 最小流（逆流增广）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 220, M = 22000, INF = 0x3f3f3f3f;struct node { int u, v, w, next;} e[M];int head[N], cur[N], tot = 0;void add(int u, int v, int w) { e[tot] = (node) {u, v, w, head[u]}; head[u] = tot++; e[tot] = (node) {v, u, 0, head[v]}; head[v] = tot++;}int h[N], in[N], n, m, s, t, ss, tt, sflow = 0, tflow = 0;bool bfs(int s, int t) { memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int&gt; q; q.push(s); h[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = head[u], v; i != -1; i = e[i].next) { v = e[i].v; if(e[i].w and !h[v]) { h[v] = h[u] + 1; if(v == t) return true; q.push(v); } } } return false;}int dfs(int u, int low, int t) { if(u == t) return low; int w = low; for(int i = cur[u], v; i != -1; i = e[i].next, cur[u] = i) { v = e[i].v; if(e[i].w and h[v] == h[u] + 1) { int f = dfs(v, min(w, e[i].w), t); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}int main() { //freopen(&quot;loj116.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); ss = 0, tt = n+1; memset(head, -1, sizeof head); for(int i=1, u, v, l, h; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;h); in[u] -= l; in[v] += l; add(u, v, h-l); } for(int i=1; i&lt;=n; ++i) { if(!in[i]); else if(in[i] &gt; 0) { sflow += in[i]; add(ss, i, in[i]); } else { add(i, tt, -in[i]); } } add(t, s, INF); while(bfs(ss, tt)) tflow += dfs(ss, INF, tt); if(sflow != tflow) { printf(&quot;please go home to sleep\\n&quot;); return 0; } for(int i = head[ss]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; for(int i = head[tt]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; int sum = e[--tot].w; e[tot-1].w = e[tot].w = 0; while(bfs(s, t)) sum += dfs(s, INF, t); printf(&quot;%d\\n&quot;, sum); return 0;}","link":"/network-flow-template/"},{"title":"陌上","text":"&amp;emsp;&amp;emsp;多少次咫尺之隔的希望 &amp;emsp;&amp;emsp;却终是目送着的离开 &amp;emsp;&amp;emsp;__最美好的时候__（） &amp;emsp;&amp;emsp;？ &amp;emsp;&amp;emsp;多少次经意又不经意 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;自然而又矫情 &amp;emsp;&amp;emsp;踌躇在触手可及的门口 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;隔的是无限的冰凌 &amp;emsp;&amp;emsp;缓慢而痛彻心扉 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;冷漠而撕心裂肺 &amp;emsp;&amp;emsp; &amp;emsp;&amp;emsp;就算你冷若冰霜 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;就算残存的桥被时间的流冲淡 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;就算寒冰封冻了每一处角落 &amp;emsp;&amp;emsp;不再颤动 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;我 &amp;emsp;&amp;emsp;洇痕 &amp;emsp;&amp;emsp; &amp;emsp;&amp;emsp;就算悸动的心被死寂的水销毁 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;就算迟来的阳光等不到花开的日子 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;就算此时相望不相闻 &amp;emsp;&amp;emsp;溱与洧 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;方涣涣兮 &amp;emsp;&amp;emsp;明天 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; &amp;emsp;&amp;emsp;愿往来翕忽的鱼儿 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;离开涸辙的田野 &amp;emsp;&amp;emsp;愿熙熙攘攘的行人 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;离开郁孤台的障翳 &amp;emsp;&amp;emsp;愿逐月华 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;流照君 &amp;emsp;&amp;emsp; &amp;emsp;&amp;emsp;纵使过往的种种想要钦定了未来 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;纵使层迭的细沙似已磨灭了你我 &amp;emsp;&amp;emsp;（不甘、仗剑、人） &amp;emsp;&amp;emsp;斩的 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;就是命运 &amp;emsp;&amp;emsp; &amp;emsp;&amp;emsp;纵使真的到达了最黑暗的时刻 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;纵使远方的洪流咆哮着向着未来 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;纵使湛蓝的天空里爱恨交盏 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;纵使 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;山无棱 &amp;emsp;&amp;emsp; &amp;emsp;&amp;emsp;如果再相遇 &amp;emsp;&amp;emsp;我想 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;陪你一起&amp;emsp;飞过彷徨 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;看最初的一道光 &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;凤凰于飞&amp;emsp;覆照殷红 &amp;emsp;&amp;emsp;夕阳","link":"/mo-shang/"},{"title":"网络流：消圈算法","text":"注：下文中的权均表示费用。 消圈定理在某个流 $f$ 中，如果其残余网络中没有负圈（剩余流量为 $0$ 的边视为不存在），那它一定是当前流量下的最小费用，否则一定不是。 证明假设一个网络，所有边的容量都是 $1$。 如果流量走上路的话，其残余网络（黑箭头）变为： 因为上路的边的流量占满了，所以现在上路只有反边。 显然 $A \\rightarrow C \\rightarrow t \\rightarrow B \\rightarrow A$ 为负圈，沿此负圈增广（每条边的流量＋1），环上每个点的入流量仍然等于出流量（原流为可行流）。 流量在圈中增广，总的流量既没有增加，也没有减少，只不过是流量从费用更少的地方流过 （$A \\rightarrow C \\rightarrow t$），从费用大的地方退流而已（$t \\rightarrow B \\rightarrow A$），流过的流量和退掉的流量是相等的，实质上只是将从 $A$ 流出的流量的方向改变，使得费用更小。 网络流的反边给了我们一个很好的反悔机制，使得我们可以对任意一个流 $f$，通过消负圈（可能不止一个），来得到它当前流量下的最小费用流。 可以看到，沿着负圈增广之后，已经没有负圈存在了，已经达到了当前流量下的最小费用流（也就是最小费用最大流）。所以只要有负圈，就可以增广达到更小费用。 应用求最小费用最大流时，可以先跑出一条可行最大流，然后通过不断消圈调整出最小费用。 更广泛用于残余网络寻找更优解。 POJ2175 Evacuation Plan题面原题面很长。 给出已达到最大流的残余网络，求出其是否已达到最小费用，如果未达到则找出更优方案。 思路消圈模板，建出网络后利用 SPFA，如果一个节点被更新了 $n$ 次则说明图中一定存在负环。题目中没有说必须是最优解，因此只要将负圈上的流量调整 $1$ 即可。 注意一个节点被更新 $n$ 次不代表其一定在负权圈内。正确做法是从这个节点 $v$ 开始不断捯它的前驱，如果发现某个节点 $u$ 被访问了两遍，则说明 $u$ 一定在负权圈内，再根据 $u$ 去捯前驱调整负权圈。 图解好像有几个地方标错了QAQ 凑合看吧 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlinetemplate &lt;typename T&gt; il T abs(T x) { return x &gt; 0 ? x : -x; }const int N = 110, M = N * N &lt;&lt; 1, INF = 0x3f3f3f3f;struct coor { int x, y, z;} a[N], b[N];struct node { int u, v, w, f, next;} e[M];int h[N &lt;&lt; 1], tot = 0;bool vis[N &lt;&lt; 1];int n, m, s, t;int cnt[N &lt;&lt; 1], pre[N &lt;&lt; 1];il void add(int u, int v, int w, int f) { e[tot] = (node) {u, v, w, f, h[u]}; h[u] = tot++;}int bp[N][N], dis[N &lt;&lt; 1], p[N][N], occ[N];deque&lt;int&gt; q;bool cyc[N &lt;&lt; 1];il void check(int v) { do { cyc[v] = true; v = e[pre[v]].u; } while(!cyc[v]); int u = v; do { --e[pre[v]].w; ++e[pre[v]^1].w; v = e[pre[v]].u; } while(u != v); for(int i=1; i&lt;=m; ++i) for(int j = h[n+i]; j != -1; j = e[j].next) if(e[j].v != t) bp[e[j].v][i] = e[j].w; printf(&quot;SUBOPTIMAL\\n&quot;); for(int i=1; i&lt;=n; ++i) { for(int j=1; j&lt;=m; ++j) printf(&quot;%d &quot;, bp[i][j]); printf(&quot;\\n&quot;); }}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z); for(int i=1; i&lt;=m; ++i) scanf(&quot;%d%d%d&quot;, &amp;b[i].x, &amp;b[i].y, &amp;b[i].z); for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) scanf(&quot;%d&quot;, &amp;p[i][j]), occ[j] += p[i][j]; memset(h, -1, sizeof h); s = 0, t = n+m+1; for(int i=1; i&lt;=n; ++i) { add(s, i, a[i].z, 0); add(i, s, 0, 0); } for(int i=1; i&lt;=n; ++i) { for(int j=1; j&lt;=m; ++j) { int f = abs(a[i].x - b[j].x) + abs(a[i].y - b[j].y) + 1; add(i, n+j, INF, f); add(n+j, i, p[i][j], -f); } } for(int i=1; i&lt;=m; ++i) { add(n+i, t, b[i].z - occ[i], 0); add(t, n+i, occ[i], 0); } memset(dis, 0x3f, sizeof dis); q.push_front(s); vis[s] = true; ++cnt[s]; dis[s] = 0; while(!q.empty()) { int u = q.front(); q.pop_front(); vis[u] = false; for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and dis[v] &gt; dis[u] + e[i].f) { pre[v] = i; dis[v] = dis[u] + e[i].f; if(!vis[v]) { if(!q.empty() and dis[v] &gt;= dis[q.front()]) q.push_back(v); else q.push_front(v); vis[v] = true; ++cnt[v]; if(cnt[v] == t+1) { check(v); return 0; } } } } } printf(&quot;OPTIMAL\\n&quot;); return 0;} 算法证明中的图片引自 Sengxian’s Blog。","link":"/network-flow-deloop/"},{"title":"网络流：最大流","text":"EK增广路方法是很多网络流算法的基础。其思路是每次找出一条从源到汇的能够增加流的路径，调整流值和残留网络 ，直到没有增广路为止。 EK 算法就是不断的找最短路，找的方法就是每次找一条边数最少的增广（即最短路径增广）。 最多要增广多少次？可以证明，最多 O(VE)​ 次增广，可以达到最大流。 如何找到一条增广路？先明确什么是增广路。增广路是一条从s到t的路径，路径上每条边残留容量都为正。把残留容量为正的边设为可行的边，那么我们就可以用简单的 BFS 得到边数最少的增广路。 如何增广？BFS 得到增广路之后，这条增广路能够增广的流值，是路径上最小残留容量边决定的。把这个最小残留容量 MinCap 值加到最大流值 Flow 上，同时路径上每条边的残留容量值减去 MinCap；最后，路径上每条边的反向边残留容量值要加上 MinCap。这样每次增广的复杂度为 O(E)，总复杂度就是 O(VE2)。事实上，大多数网络的增广次数很少，因此 EK 算法能处理绝大多数问题。 为什么增广路径上每条边的反向边残留容量值要加上 MinCap？残留网络 = 容量网络 - 流量网络 容量网络不改变的情况下，由于增广好比给增广路上通了一条流，路径上所有边流量加 MinCap 之后，相对应的残留网络就发生相反的改变。因为建立了反向边，如果这条路径不是最理想的就会回流，避免了这种情况。这是网络流里很重要的一点。 图例 DinicBFS 分层 与EK一样，我们仍要通过 bfs 来判断图中是否还存在增广路，但是 Dinic 算法里的 bfs 略有不同。这次，我们不用记录路径，而是给每一个点分层，对于任意点 i，从 s 到 i 每多走过一个点，就让层数多 1。一次分层后可以找到多条增广路，从而提高效率。 分完层效果是这样的：（蓝色的数字是每个点层数） DFS 增广有了每个点的层数编号，对任意点 u 到点 d 的路径如果有 $dep[d]=dep[u]+1$，我们就可以判断该路径在增广路上。 比如说，我们首先找 s-&gt;1-&gt;4-&gt;t： 第二次，s-&gt;1-&gt;5-&gt;t： 第三次，s-&gt;1-&gt;3-&gt;t： 还有第四条，s-&gt;2-&gt;3-&gt;t： PS：Dinic 在跑二分图匹配时比匈牙利快很多。 P3376 网络最大流12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 11000, M = 110000;const int INF = 0x7fffffff;struct node { int u, v, w, next;} e[M &lt;&lt; 1];int cur[N], h[N], tot;int dfn[N], ans, n, m, s, t;void add(int u, int v, int w) { e[tot] = node({u, v, w, h[u]}); cur[u] = h[u] = tot++;}bool bfs() { memcpy(cur, h, sizeof cur); memset(dfn, 0, sizeof dfn); queue&lt;int&gt; q; dfn[s] = 1; q.push(s); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and !dfn[v]) { dfn[v] = dfn[u] + 1; q.push(v); if(v == t) return true; } } } return false;}int dfs(int u, int low) { if(u == t) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next) { int v = e[i].v; cur[u] = i; if(e[i].w and dfn[v] == dfn[u] + 1) { int f = dfs(v, min(w, e[i].w)); if(f == 0) dfn[v] = 0; e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}void dinic() { int flow; while(bfs()) while(flow = dfs(s, INF)) ans += flow;}int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); memset(h, -1, sizeof h); for(int i=1, u, v, w; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, 0); } dinic(); printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/maximum-flow/"},{"title":"还在用 STL 排序？","text":"使用 C 库函数很多人都不知道的是，其实 C 语言也是自带排序函数的，就是位于 &lt;stdlib.h&gt; 库中的 qsort 函数声明： 1void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) 其中 base - 指向要排序的数组的第一个元素的指针 nitems - base 指向的数组中元素的个数 size - 数组中每个元素的大小（以字节为单位） compar - 用来比较两个元素的函数 与 &lt;algorithm&gt; 中的 std::sort 略有差异，尤其是在 compar 函数的定义上。 其形参必须是 const void* 型（可以理解为，在 compar 函数内部会将 const void* 型转换成实际类型）。 如果返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面； 如果返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定； 如果返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。 在 C11 标准中，新增了另一个排序函数 qsort_s ，但在无编译开关的情况下无法使用。 另外，虽然它的名字叫 qsort ，但目前还没有任何一个 C 标准规定其必须通过快排实现（） 实测在整数排序下，效率与 STL 相差无几，都在 140ms/1.20MB 左右。 Code (C) : 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;const int N = 1e5 + 10;int cmp(const void *a, const void *b) { return (*(int*)a - *(int*)b);}int main() { int n, i, a[N]; scanf(&quot;%d&quot;, &amp;n); for (i=0; i&lt;n; ++i) scanf(&quot;%d&quot;, a+i); qsort(a, n, sizeof(int), cmp); for (i=0; i&lt;n-1; ++i) printf(&quot;%d &quot;, a[i]); printf(&quot;%d\\n&quot;, a[n-1]); return 0;} 使用 PB_DSPB_DS，又称平板电视，是一个冷门但功能极为强大的 GNU-cpp 扩展库，但在 OI 中（尤其是省选以下）极少用到。 该库中提供了大量数据结构（虽然不开O2的话几乎都会T掉），以树形结构为主，拿出来基本个个都可以排序 堆： （未开 O2，248ms/5.23MB ） 1234567891011121314#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;using namespace __gnu_pbds;__gnu_pbds::priority_queue &lt; int, greater&lt;int&gt;, pairing_heap_tag &gt; q;int n;int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=0, a; i&lt;n; ++i) scanf(&quot;%d&quot;, &amp;a), q.push(a); for(int i=0; i&lt;n; ++i) printf(&quot;%d &quot;, q.top()), q.pop(); return 0;} 由于 pb_ds 中的 tree 相当于 set 而不是 multiset ，因此比手写快排还长，不再展示。","link":"/still-using-stl-sort/"},{"title":"高级动态规划：区间、树形","text":"区间 DPP1880 [NOI1995]石子合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 220;int ans, dp[N][N], n, a[N], s[N];int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, a+i); s[i] = s[i-1] + a[i]; } for(int i=1; i&lt;=n; ++i) { s[i+n] = s[i+n-1] + a[i]; } memset(dp, 0x3f, sizeof dp); for(int i=1; i&lt;=2*n; ++i) dp[i][i] = 0; for(int l=2; l&lt;=n; ++l) { for(int i=1, j=l; j&lt;=2*n; ++i, ++j) { for(int k=i; k&lt;j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + s[j] - s[i-1]); } } } ans = 0x3f3f3f3f; for(int i=1; i&lt;=n; ++i) { //printf(&quot;%d &quot;, dp[i][i+n-1]); ans = min(ans, dp[i][i+n-1]); } printf(&quot;%d\\n&quot;, ans); memset(dp, 0, sizeof dp); for(int i=1; i&lt;=2*n; ++i) dp[i][i] = 0; for(int l=2; l&lt;=n; ++l) { for(int i=1, j=l; j&lt;=2*n; ++i, ++j) { for(int k=i; k&lt;j; ++k) { dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + s[j] - s[i-1]); } } } ans = 0; for(int i=1; i&lt;=n; ++i) { ans = max(ans, dp[i][i+n-1]); } printf(&quot;%d\\n&quot;, ans); return 0;} P1063 能量项链1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 220;int n, h[N], t[N], dp[N][N];int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;h[i]); h[i+n] = h[i]; } for(int i=1; i&lt;2*n; ++i) t[i] = h[i+1]; for(int l=2; l&lt;=n; ++l) { for(int i=1, j=l; j&lt;=2*n; ++i, ++j) { for(int k=i; k&lt;j; ++k) { dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + h[i] * t[k] * t[j]); } } } int ans = 0; for(int i=1; i&lt;=n; ++i) { ans = max(ans, dp[i][i+n-1]); } printf(&quot;%d\\n&quot;, ans); return 0;} P3146 [USACO16OPEN]248 G123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int n, dp[300][300], ans = 0;int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;dp[i][i]); } for(int l=2; l&lt;=n; ++l) { for(int i=1, j=l; j&lt;=n; ++i, ++j){ for(int k=i; k&lt;j; ++k) { if(dp[i][k] == dp[k+1][j]) dp[i][j] = max(dp[i][j], dp[i][k]+1); } ans = max(ans, dp[i][j]); } } printf(&quot;%d\\n&quot;, ans); return 0;} 树形 DP树形DP三大问题：树的最大独立集 树的重心 树的最长路径 P1352 没有上司的舞会1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef vector&lt;int&gt;::iterator IT;const int N = 6e3 + 10;int fa[N]; vector&lt;int&gt; g[N];int n, r[N];inline int fin() { for(int i=1; i&lt;=n; ++i) if(!fa[i]) return i;}int f[N][2];// 0/1void dfs(int u) { f[u][0] = 0; f[u][1] = r[u]; for(IT it = g[u].begin(); it != g[u].end(); ++it) { dfs(*it); f[u][0] += max(f[*it][0], f[*it][1]); f[u][1] += f[*it][0]; }}int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, r+i); for(int i=1; i&lt;n; ++i) { int l, k; scanf(&quot;%d%d&quot;, &amp;l, &amp;k); fa[l] = k; g[k].push_back(l); } int rt = fin(); dfs(rt); printf(&quot;%d&quot;, max(f[rt][0], f[rt][1])); return 0;} P2014 [CTSC1997]选课1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 330;vector&lt;int&gt; g[N];int n, m; int dp[N][N];void dfs(int u) { for(vector&lt;int&gt;::iterator it = g[u].begin(); it != g[u].end(); it++) { dfs(*it); for(int j=m+1; j&gt;1; --j) { for(int k=0; k&lt;j; ++k) dp[u][j] = max(dp[u][j], dp[*it][k] + dp[u][j-k]); } }}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) { int k; scanf(&quot;%d%d&quot;, &amp;k, &amp;dp[i][1]); g[k].push_back(i); } dfs(0); printf(&quot;%d\\n&quot;, dp[0][m+1]); return 0;}","link":"/dp-series/"},{"title":"第三次写雪","text":"好多好多的雪，一片一片的，有大有小。 它们挤在空气里。 有时候风停了，它们盘旋一会儿，便无可抗拒地被拉向地心，覆在枯兀的树枝旁，盖在黑褐色的山丘上。 有时候风大了，它们集结成束，近乎平行地面地飞着。密密麻麻的细丝轻轻颤动，像填满罅隙的琴弦。 它们还是要落在地上，躺在毫无新意的地方。规则的六角形，在触到固体的刹那，便化为了飞灰。它们在严冬的苍白的太阳里升腾，变成交叠的球团，又回到没有棱角的松仁。 我看到临别的雪花，恋恋不舍地吻着空气，像我所奢望的那样。","link":"/3rd-snow/"},{"title":"雪（精选集）","text":"（主线剧情：星, 梦, 昙 -&gt; 未来 -&gt; 黎明之烬 -&gt; 涉江 &amp; 凝眉） （外传：《水生》） 最新：凝眉纪念初中时候的一段故事吧。顺便把这个系列收个尾。大概就结束了。 他和她坐在跑道边，说是要等着，等最后一片云霞沉寂在地平线下。时不时地，他们凑在对方的耳边，轻声低语；欢谑声里，沉沉的烟火灿烂着，像雪染成的白绫。风打在他和她的肩上。 一 星, 梦, 昙 Director 放下了望远镜，凝视着那隙天边的裂痕，在远方，缩成一团光影。在他的身后，几筒烟花飞向空中，绽出几点荧烁的火光。 时空的网交错在一起，织成了天上的星。 二 未来 我的视线依然投在远方。看着看着，我渐渐不明白有多少东西可以称得上是变化了。世界本来就没有形状。 三 黎明之烬 黑暗包围了你和高桥。你紧紧地牵着她的手，and so did she。你的眼前出现了一池水潭：那是世界的原点，也是世界的尽头。 四 沼 他拾起石子掷向水中；石子弹跳着沉了下去。 黑夜却还不急着到来。太阳迸发出血红的光芒，向西方吃力地转动着。 五 涉江 她可能还没有想到过那样的一天，雪花浸满了每一个角落。空自，她守望着梦乡。 六 凝眉 时不时地，他们凑在对方的耳边，轻声低语；欢谑声里，沉沉的烟火灿烂着，像雪染成的白绫。","link":"/snow/"},{"title":"现代诗诗集：B-A","text":"诗集《B-A》，灵感来源于磁带的 AB 面，如你所见。总共八篇，每面四首。顺序当然不是随便排的。 诗集《B-A》，内容很杂，熔铸了最近对一些事情的思考，小到自我，大到人类。事情有大有小，篇幅有长有短，道理有的浅显有的隐晦，谜语有的有标答有的不设标答。 有人说，语言是思想的载体。而我则说，语言是思想的源泉。诗集《B-A》，在文学性上下了一番工夫。 诗集《B-A》，名字是率性而起，内容则精雕细琢，尽量不赘一字。 诗集《B-A》，和之前的所有作品一样，在探索中纂成，既是作者的摸索，也是读者的物色。希望它拥有触动人心的力量，使你沉浸在全开放的寻味之旅中，入口回绵。 诗集《B-A》，全文链接(2021.11.29)。 A 面：古船 | 摘走月亮的人 | 汪洋 | 梁山泊 B 面：雪 | 鲨鱼 | 盐 | [EXTRA]: 梁博《日落大道》","link":"/poems-b-a/"},{"title":"网络流：最小割","text":"将图 $G$ 分为 $A$ 和 $B$ 两个点集，$A$ 和 $B$ 之间的边的集合称为无向图的割集。带权图的割 (Cut) 就是割集中的边权之和。 S - T 最小割特别地，对于一个网络，在满足 $源点 s \\in 点集{S}, 汇点 t \\in 点集{T}(S\\cap T= \\varnothing)$ 的情况下，从 S 到 T 的边的权值和被称为 S 到 T 的割。 通俗地说，如果把你家和自来水厂之间的水管网络砍断了一些，那么自来水厂无论怎么放水，水都无法到达你们家，自然就停水了，砍掉的水管就是割。 砍水管的人自然希望花的力气越小越好。在所有割中，权值和最小的称为最小割。对于一个给定的 S - T 网络，如何求出它的最小割呢？ 最大流最小割定理网络的最大流等于最小割。 这个定理看起来很简单，但是真去思考的话其实挺麻烦的。 证明 Step 1：任意一个流都小于等于任意一个割自来水公司随便给你家通点水，构成一个流，随便砍几刀砍出一个割，那么由于容量限制，每一根的被砍的水管子流出的水流量都小于管子的容量。每一根被砍的水管的水本来都要到你家的，现在流到外面，加起来得到的流量还是等于原来的流。而管子的容量加起来就是割，所以流小于等于割。 由于上面的流和割都是任意构造的，所以任意一个流小于任意一个割，即$$\\forall F \\leqslant \\forall C$$ Step 2：构造出一个流，使它等于一个割当达到最大流时，根据增广路定理，残留网络中 s 到 t 已经没有通路了。因此，若把残余网络中 s 能到的的点的集合设为 S，不能到的点集为 T ，构造出一个割集 $C[点集S,点集T]$，所有由 S 发往 T 的边必然满流。并且，这些满流边的流量和就是当前的流，即最大流。把这些满流边作为割，就构造出了一个和最大流相等的割。 Step 3：最大流等于最小割设上一步构造出流和割分别为 $F_m$ 和 $C_m$。 又 $\\forall F \\leqslant \\forall C$ $\\therefore \\forall F \\leqslant F_m=C_m \\leqslant \\forall C$。 网络流等价定理综合最大流最小割定理和增广路定理，可以得到这样的结论： 对于一个网络流图 $G=(V,E)$，其中有源点 $s$ 和汇点 $t$ ，那么下面三个条件是等价的： 流 $f$ 是图 $G$ 的最大流； 残留网络 $G$ 不存在增广路； 在 $G$ 中必存在一个割 $C[S,T]$，使得 $f=C[S,T]$。 读者自证不难 证明 1 =&gt; 2（即增广路定理）利用反证法，假设流 $f$ 是图 $G$ 的最大流，但是残留网络中还存在有增广路 $p$，其流量为 $f_p$，则有流 $f’=f+f_p&gt;f$。这与 $f$ 是最大流产生矛盾。 证明 2 =&gt; 3（即最大流最小割定理）总结一下上面的证明。 假设残留网络 $G_f$ 不存在增广路，所以在残留网络 $G_f$ 中不存在路径从 $s$ 到达 $t$。我们定义 $S$ 集合为当前残留网络中 $s$ 能够到达的点，同时定义 $T=V-S$，此时构成一个割 $C(S,T)$。 且 $u∈S,v∈T$，有 $f(u,v)=c(u,v)$。若 $f(u,v)&lt;c(u,v)$，则有 $G_f(u,v)&gt;0$，$s$ 可以到达 $v$，与 $v \\in T$ 矛盾。 因此有 $f(S,T)= \\sum f(u,v)=\\sum c(u,v)=C(S,T)$。 证明 3 =&gt; 1：由于 $f$ 的上界为最小割，当 $f$ 到达割的容量时，显然就已经到达最大值，因此 $f$ 为最大流。 这样就说明了为什么找不到增广路时，所求得的一定是最大流。 最大权闭合子图在一个图中，我们选取一些点构成集合，记为 V，且集合中的出边（即集合中的点的向外连出的弧），所指向的终点也在 V 中，则我们称 V 为闭合图。在所有闭合图中，集合中点的权值之和最大的 V，称为最大权闭合子图。 栗子 上图中最大权闭合子图为 {3,4,5}。 最大权闭合子图权值和构图构建一个超级源点 s，一个超级汇点 t，所有的点按权值的正负连接到 s 和 t 上，转换成一个边权值有向图，如下图： （注：点权为 0 的点可以忽略，对结果没有影响） 前置知识 该带边权有向图的 S - T 最小割，割集中所有的边，都与 s 或 t 相连接。 显然，因为不与 s,t 相连的边，权值都是 INF，最小割不可能割在 INF 的边上。 该图中的每一个简单割产生的两个子图，我们记含有点 s 的是图 S，含有点 t 的是图 T，则图 S 是最大权闭合子图。 简单割内不包含边权为 INF 的边，即不含有连通两个图的边（除了连接在 t 点上的边之外）；即，图 S 中没有边与图 T 连通，那么，所有的边都只能连接在图 S 之内，即为闭合图。 记割集中，所有连接在 s 上的边的权值和为 $x_1$，所有连接在 t 上的边的权值和为 $x_2$，则割集中所有边权值和为 $x=x_1+x_2$。 记图 S 中所有点的权值和为 $w$，记其中正权值之和为 $w_1$，负权值之和为 $- w_2$，故 $w = w_1 - w_2$。 因此，$$w+x=w_1-w_2+x_1-x_2$$又，$$x_2 = w_2$$因为图 S 中所有负权值的点必然连接到 t 点，而图 S 必然要与 t 分割开，故割集中，连接在 t 点上的边权值和就是图S中所有负权值点的权值之和取负。因而，$$w+x=w_1+x_1$$显然，$w_1 + x_1$ 是整个图中所有正权值之和，记为 $sum$，则$$w=sum-x$$即，图 S 中所有点的权值和 = 整个图中所有正权值之和 - 割集中所有边权值和。因为 $sum$ 为定值，只要我们取最小割，则图 S 中所有点的权值和就是最大的，即此时图 S 为最大权闭合子图。 栗子 解法 先记录整个图中，所有正点权值的和； 建立对应流网络，求最大流，最大流在数值上等于最小割，故我们得到了流网络的 s-t 最小割； 所有正点权值的和减去 s-t 最小割，即得最大权闭合子图的权值和。 P2762 太空飞行计划问题Hint这里大概讲一下转换成最大流以后怎么输出。 一个结论就是假如我们跑的是 Dinic 那么我们最后一次网络流（这一次网络流并没有起任何作用，只是确认了无更多残余流量可以退出了）中，所有被分到层的都一定被选上了。 没有更多残余流量其实意味着这个图已经被割成了两部分，一个实验如果有层数意味着它没有被割掉（被选上了），一个仪器如果有层数意味着它已经被割掉了（也是被选上了）。 于是只要在最后输出所有有层数的点就行了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 110, INF = 0x3f3f3f3f;char tools[10000];class node { public: int u, v, w, next;} e[N * N];int head[N], cur[N], tot = 0;void add(int u, int v, int w) { e[tot] = {u, v, w, head[u]}; head[u] = tot++; e[tot] = {v, u, 0, head[v]}; head[v] = tot++;}int h[N], n, m, s, t;bool bfs() { memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int&gt; q; q.push(s); h[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = head[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and h[v] == 0) { h[v] = h[u] + 1; if(v == t) return true; q.push(v); } } } return false;}int dfs(int u, int low) { if(u == t) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next, cur[u] = i) { int v = e[i].v; if(e[i].w and h[v] == h[u] + 1) { int f = dfs(v, min(w, e[i].w)); if(f == 0) h[v] = 0; e[i].w -= f; e[i^1].w += f; w -= f; if(w == 0) break; } } return low - w;}int maxflow = 0, sum = 0;void dinic() { int flow; while(bfs()) while(flow = dfs(s, INF)) maxflow += flow;}int main() { //freopen(&quot;shut2.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;m, &amp;n); memset(head, -1, sizeof head); s = 0, t = n+m+1; for(int i=1, w; i&lt;=m; ++i) { scanf(&quot;%d&quot;, &amp;w); add(s, i, w); sum += w; memset(tools, '\\0', sizeof tools); cin.getline(tools, 10000); int ulen = 0, tool; while(sscanf(tools + ulen, &quot;%d&quot;, &amp;tool) == 1) { add(i, tool + m, INF); if(tool == 0) ulen++; else { while(tool) { tool /= 10; ulen++; } } ulen++; } } for(int i=1, w; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;w); add(i+m, t, w); } dinic(); for(int i=1; i&lt;=m; ++i) if(h[i]) printf(&quot;%d &quot;, i); printf(&quot;\\n&quot;); for(int i=1; i&lt;=n; ++i) if(h[i+m]) printf(&quot;%d &quot;, i); printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, sum - maxflow); return 0;} 全局最小割可参考这篇文章。 Code (POJ 2914, 未优化版)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 550;int g[N][N];int dis[N];bool flag[N], vis[N];int n, m, s, t;int main() { while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) { memset(g, 0, sizeof g); for(int i=1, a, b, c; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); ++a, ++b; g[a][b] += c; g[b][a] += c; } int ans = 0x3f3f3f3f; memset(flag, false, sizeof flag); for(int o=1; o&lt;n; ++o) { s = t = 0; memset(vis, false, sizeof vis); memset(dis, 0, sizeof dis); for(int p=1; p&lt;=n; ++p) { int v = -1; for(int i=1; i&lt;=n; ++i) if(!flag[i] and !vis[i] and (v == -1 or dis[v] &lt; dis[i])) v = i; if(v == -1) break; vis[v] = true; s=t, t=v; for(int i=1; i&lt;=n; ++i) if(!flag[i] and !vis[i]) dis[i] += g[t][i]; } flag[t] = true; ans = min(ans, dis[t]); if(ans == 0) break; for(int i=1; i&lt;=n; ++i) { if(flag[i]) continue; g[s][i] += g[t][i]; g[i][s] += g[i][t]; } } printf(&quot;%d\\n&quot;, ans); } return 0;}","link":"/minimum-cut/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"DFS","slug":"dfs","link":"/tags/dfs/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"Hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"PWA","slug":"pwa","link":"/tags/pwa/"},{"name":"应用程序","slug":"应用程序","link":"/tags/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"name":"部署","slug":"部署","link":"/tags/%E9%83%A8%E7%BD%B2/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Butterfly","slug":"butterfly","link":"/tags/butterfly/"},{"name":"Aplayer","slug":"aplayer","link":"/tags/aplayer/"},{"name":"码风","slug":"码风","link":"/tags/%E7%A0%81%E9%A3%8E/"},{"name":"Vercel","slug":"vercel","link":"/tags/vercel/"},{"name":"SSH","slug":"ssh","link":"/tags/ssh/"},{"name":"GitHub","slug":"github","link":"/tags/github/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"STL","slug":"stl","link":"/tags/stl/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"匹配","slug":"匹配","link":"/tags/%E5%8C%B9%E9%85%8D/"},{"name":"小说","slug":"小说","link":"/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"DAG","slug":"dag","link":"/tags/dag/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"LCA","slug":"lca","link":"/tags/lca/"},{"name":"尺取法","slug":"尺取法","link":"/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"图书馆","slug":"图书馆","link":"/tags/%E5%9B%BE%E4%B9%A6%E9%A6%86/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"PB_DS","slug":"pb-ds","link":"/tags/pb-ds/"},{"name":"最小割","slug":"最小割","link":"/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"}],"categories":[{"name":"算法","slug":"algorithm","link":"/categories/algorithm/"},{"name":"Hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"小说 &amp; 随笔","slug":"hitokoto","link":"/categories/hitokoto/"},{"name":"动态规划","slug":"algorithm/dp","link":"/categories/algorithm/dp/"},{"name":"未来","slug":"hitokoto/future","link":"/categories/hitokoto/future/"},{"name":"数论","slug":"数论","link":"/categories/%E6%95%B0%E8%AE%BA/"},{"name":"算法","slug":"数论/algorithm","link":"/categories/%E6%95%B0%E8%AE%BA/algorithm/"},{"name":"图书馆","slug":"图书馆","link":"/categories/%E5%9B%BE%E4%B9%A6%E9%A6%86/"},{"name":"网络流","slug":"algorithm/network-flow","link":"/categories/algorithm/network-flow/"},{"name":"陌上","slug":"hitokoto/陌上","link":"/categories/hitokoto/%E9%99%8C%E4%B8%8A/"}]}