{"pages":[{"title":"分类","text":"","link":"/categories/"},{"title":"AS FOR ME","text":"Shiro: /'ʃɪrɒ/ or しろ 游戏热爱者 创作者 OIer Freshman | PKU INFP-T 与 ENFP-T 反复横跳 村上春树 | 汪曾祺 | 现当代中国文学 方大同 | 许嵩 | 周杰伦、陶喆 | 千禧后华语流行 现居天津 | 来自天津 | 咸鱼批发公司 | 学生","link":"/about/"},{"title":"友人帐","text":".linkpage ul{color:rgba(255,255,255,.15);}.linkpage ul:after{content:\" \";clear:both;display:block}.linkpage ul li{float:left;width:48%;position:relative;transition:.3s ease-out;border-radius:5px;line-height:1.3;height:90px;display:block;min-width: 15rem;}.linkpage ul li:hover{background:rgba(230,244,250,.5);cursor:pointer}.linkpage ul li a{padding:0 10px 0 90px}.linkpage ul li a img{width:60px;height:60px;object-fit:cover;border-radius:50%;position:absolute;top:15px;left:15px;cursor:pointer;margin:auto;border:none}.linkpage ul li a h4{color:#333;font-size:18px;margin:0 0 7px;padding-left:90px}.linkpage ul li a p{font-size:12px;color:#999;padding-left:90px}.linkpage ul li a h4,.linkpage ul li a p{cursor:pointer;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;line-height:1.4}.linkpage ul li a:hover h4{color:#51aded}.linkpage h3{margin:15px -25px;padding:0 25px;border-left:5px solid #51aded;background-color:#f7f7f7;font-size:25px;line-height:40px} 小嘉的部落格一个爱折腾的Java开发工程师 Lete乐特人生只有一次，大胆的生活！！ Heo爱折腾的设计师 YlovexLN井底之蛙，虽不知大海之宽阔，却知晓天空之蓝！ Jared h🤪🤪🤪 小N同学青石落晚巷 故人未还乡 Sitoi活到老，学到老 大白萝卜一只爱吃兔子的萝卜🥕 HelloWorld不知道呢┑(￣Д ￣)┍ Colsrch愿多年以后，我可以酌一杯清酒，烂醉如泥，梦中回到我们的曾经。 ConstOwn能与你一起成长，我荣幸之至。 PluShine分享小白也能看懂的博客教程 煎鱼的海人之帅，莫过于煎鱼 圣文のblog学深夜的习，读清晨的书 Sakura` Blogs或苦或甜都不要辜负 忧郁的派大星越学习，越发现自己的无知 hfzvictory深自缄默，如云漂泊 王稻草就是很喜欢啊 曦秋的小屋 西交的学术小垃圾 羿潇贤鱼为之则易，不为则难。 Khighness炒菜 K 殿下 SeaYJ’s Blog放弃向他人证明自己，放弃向自己证明自己！ Yin Guai音夬的摸鱼小站 MirrororsA Miracle Has Taken Place 🚗 btwoa我仍相信人间滚烫 我的信息 1234site: Shiro's Shelfurl: https://snow.js.org/image: https://snow.js.org/img/share.jpgdesc: 辉星皓夜苍千顷，此宵风醉月舞萤 交换友链请先添加本站，并按如下格式在留言板留言。 有无独立域名均可；有一定数量的原创文章。 不定期检查友链。如果被误清理，请重新申请。 请提供站点的名称、链接、描述与图标。","link":"/friends/"},{"title":"友链清理记录","text":"友链被对方单向删除：安河桥北以北bx%%%g.cn；纵饮孤独z%%d.site； 网站无法访问：保温杯的小站fu%%%%%ye.ga； 博客文章抄袭：笔记b%%%te.cn； 对方暂时未更换链接： site: 栖枝 perch url: https://520526.xyz image: https://cdn.jsdelivr.net/gh/tperch/jsd/ico/20200505043817.jpg desc: 用心创造设计，改变生活 site: 幕光倾城 image: https://s1.ax1x.com/2020/05/15/YymjXQ.jpg url: https://www.meilinfeng.top desc: 钝学累功，勤能补拙 从本站撤下搬到洛谷上了### OIers site: SerokSSR url: https://www.luogu.com.cn/user/125032 image: https://cdn.jsdelivr.net/gh/SerokSSR/cdn2/k16.png desc: 九死南荒吾不恨，兹游奇绝冠平生 site: SiRiehn_nx url: https://www.luogu.com.cn/user/232125 image: https://cdn.luogu.com.cn/upload/usericon/232125.png desc: 从开始的连名带姓到最后的连名带姓 site: SingerCoder url: https://www.luogu.com.cn/user/239241 image: https://pic1.zhimg.com/v2-e2eea91387bfbe1cc181ec5db67b429c_xl.jpg desc: In solitude, where we are least alone. 暂时无法接通 site: Aurora’s url: https://blog.th**––is52.cn image: https://cdn.jsdelivr.net/gh/52assert/CDN/img/2020**–0711202438.jpg desc: 偷偷厉害 万物尽可期待！ site: Ky**––in url: https://ww––how image: https://ww–***–atar.jpg desc: 学习不易，努力努力~ site: Qing Sh*––eng url: https://www.on––esite.pro desc: 努力的小白 image: https://www.o––nes–*–ite.pro/img/avatar.png site: Z*––AN url: https://zeh––yz/ image: https://gitee–***–er/images/PT0.jpg desc: 没有撤退可盐！ site: 木叶*–– | Daimon’s Blog url: https://blo––agluntan.cn image: http://q––.qlogo.cn/g?b=qq&amp;nk=2247481637&amp;s=100 desc: 生命不息–*–腾不止！","link":"/errors/"},{"title":"留言板","text":"","link":"/messageboard/"},{"title":"标签","text":"","link":"/tags/"}],"posts":[{"title":"","text":"","link":"/undefined/"},{"title":"2022 全创作概念辑《湖水》","text":"2022 全创作概念辑《湖水》：整轨分轨并行式首创 “游走于黑白分界，于幻梦再现真实”，如你所见，概念辑《湖水》。 概念辑《湖水》，内容很杂，熔铸了对切近的思考，小到谎言与真挚的搏斗、大到短视与杞人的争执。事情有大有小，篇幅有长有短，道理有的浅显有的隐晦，谜语有的有标答有的不设标答。 有人说，语言是思想的载体。而我则说，语言是思想的源泉。概念辑《湖水》，在文学性上下了一番工夫。 概念辑《湖水》，名字是率性而起，内容则精雕细琢，尽量不赘一字。 概念辑《湖水》，和之前的所有作品一样，在探索中纂成，既是作者的摸索，也是读者的物色。希望它拥有触动人心的力量，使你沉浸在全开放的寻味之旅中，入口回绵。 概念辑《湖水》，Introducing… 整轨：水生 分轨：古船 | 透明的颜色 | 汪洋 | 梁山泊 | 黑夜 | 雪","link":"/album-loch/"},{"title":"Butterfly：添加全局吸底 Aplayer 播放器","text":"以下步骤在 Butterfly主题上可以正常生效。如果你使用的是其他主题，可以根据情况自行适配。 配置播放器 解决与 hexo-tag-aplayer 的兼容问题 如果你没有安装过 hexo-tag-aplayer 插件，请直接跳过该步骤。 如果你安装过 hexo-tag-aplayer，请在 Hexo 的配置文件中修改以下设置： 123aplayer: meting: true asset_inject: false 开启主题的 aplayerInject 选项 在主题配置文件中，enable和per_page均设为true： 1234# Inject the css and script (aplayer/meting)aplayerInject: enable: true per_page: true 插入 Aplayer 代码 插入到主题配置文件的 inject.bottom。 示例代码： 1234inject: ... bottom: - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;000PeZCQ1i4XVs&quot; data-server=&quot;tencent&quot; data-type=&quot;artist&quot; data-fixed=&quot;true&quot; data-mini=&quot;true&quot; data-listFolded=&quot;false&quot; data-order=&quot;random&quot; data-preload=&quot;none&quot; data-autoplay=&quot;true&quot; muted&gt;&lt;/div&gt; 参数解释： option default description data-id require song id / playlist id / album id / search keyword data-server require music platform: netease, tencent, kugou, xiami, baidu data-type require song, playlist, album, search, artist data-autoplay false audio autoplay data-theme #2980b9 main color data-loop all player loop play, values: ‘all’, ‘one’, ‘none’ data-order list player play order, values: ‘list’, ‘random’ data-preload auto values: ‘none’, ‘metadata’, ‘auto’ data-volume 0.7 default volume, notice that player will remember user setting, default volume will not work after user set volume themselves data-mutex true prevent to play multiple player at the same time, pause other players when this player start play data-lrctype 0 歌词来源方式，一般不更改 data-listfolded false indicate whether list(指播放列表，不是播放器) should folded at first data-listmaxheight 340px list max height data-storagename metingjs localStorage key that store player setting :::warning 注意： data-id、data-server 和 data-type 必须配置 data-fixed 和 data-mini 参数不要更改 ::: 运行Hexo就可以看到网页左下角出现了Aplayer。 如果你想切换页面时音乐不中断，请把主题配置文件的 pjax 设为 true。 UI 调整 调整右下角回到顶部等按钮 按照上面的步骤设置完成后，浏览器左下角会出现 Aplayer。在手机端浏览博客时，如果展开播放器，会将右下角按钮遮住。 在Butterfly配置文件中，调整 rightside-bottom 选项： 12# the position of bottom right button; default unit: px (右下角按鈕距離底部的距離，默認單位為 px)rightside-bottom: 80px 调整 TOC 目录按钮 打开文章页面时，你会发现打开 Toc 目录的按钮被遮挡了。我们需要修改 CSS 来改变按钮的位置。 请在主题配置文件中，将这段代码添加到 inject 去： 123inject: head: - '&lt;style type=&quot;text/css&quot;&gt;#toggle-sidebar {bottom: 80px}&lt;/style&gt;' 调整 Aplayer 收回方式 如果你觉得Aplayer占地太大，影响正常阅读，可以设置Aplayer收回时将音乐Cover也隐藏掉，只留下右侧的箭头栏。 请在主题配置文件中，将这段代码添加到 inject 去： 123inject: head: - '&lt;style type=&quot;text/css&quot;&gt;.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}&lt;/style&gt;' 调整 APlayer 歌词显示 Aplayer的歌词默认在底部正中显示，也会遮挡一些内容。当然我们可以通过调整相应内容高度的方式来解决，但是如果可以设置歌词默认不显示，效果可能会更好。 解决方案：修改Butterfly配置文件中的 CDN.meting_js 配置，将CDN链接替换即可。 1234567CDN: ... # aplayer aplayer_css: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css aplayer_js: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js- meting_js: https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js+ meting_js: https://cdn.jsdelivr.net/gh/SerokSSR/cdn/meting.min.js","link":"/butterfly-aplayer/"},{"title":"C++ STL：SET &amp; MULTISET","text":"定义 方式 效果 set &lt;数据类型名&gt; 集合名; 先定义一个容器，容器内无任何元素 set &lt;数据类型名&gt; 集合名(另一个集合名); 定义一个集合并用另一个集合初始化（只能是数据类型相同的集合，不能是数组） set &lt;数据类型名&gt; 集合名(另一个集合名.begin(), 另一个集合名.end()); 定义一个集合并用另一个集合初始化（只能是数据类型相同的集合，不能是数组） set &lt;数据类型名&gt; 集合名[集合数量]; 定义集合数组 set &lt;Elem&gt; 产生一个set，以 (operator &lt;) 为排序准则 set &lt;Elem, cmp&gt; 产生一个set，以cmp为排序准则 操作 非变动性操作 操作 效果 c.size() 返回当前的元素数量 c.empty () 判断set是否为空，等同于 c.size() == 0，效率更高 c.max_size() 返回能容纳的元素最大数量 c1 == c2 判断c1是否等于c2 查找 set和multiset都是平衡树，$O(\\log n)$ 级别查找。 操作 效果 count(elem) 返回元素值为elem的个数 find(elem) 返回元素值为elem的第一个元素，如果没有返回end() lower_bound(elem) 返回元素值为elem的第一个可安插位置，也就是元素值 &gt;= elem的第一个元素位置 upper_bound(elem) 返回元素值为elem的最后一个可安插位置，也就是元素值 &gt; elem 的第一个元素位置 equal_range(elem) 返回elem可安插的第一个位置和最后一个位置，也就是元素值 == elem的区间 赋值与迭代 sets和multisets的迭代器是双向迭代器，对迭代器操作而言，所有的元素都被视为常数，可以确保你不会人为改变元素值，从而打乱既定顺序，所以无法调用变动性算法，如 remove()。 操作 效果 c1 = c2 将c2的元素全部给c1 c1.swap(c2) 将c1和c2 的元素互换 swap(c1, c2) 同上，全局函数 c.begin() 略 c.end() 略 c.rbegin() 略 c.rend() 略 安插和删除元素 必须保证参数有效，迭代器必须指向有效位置，序列起点不能位于终点之后，不能从空容器删除元素。 操作 返回值 效果 c.insert(elem) pair &lt;iterator, bool&gt; 插入一个elem副本 c.insert(pos, elem) iterator 安插一个elem元素副本，返回元素的迭代器。pos为搜索起点，提升插入速度。 c.insert(beg,end) void 将区间[beg,end)所有的元素安插到c。 c.erase(elem) 无符号整数 删除与elem相等的所有元素，返回被移除的元素个数。 c.erase(pos) void 移除迭代器pos所指位置元素。 c.erase(beg,end) void 移除区间[beg,end)所有元素，返回 void。 c.clear() void 移除所有元素，将容器清空 set与multiset的异同 set::insert(key) 的返回值是一个 pair&lt;iterator, bool&gt;，其中pair中的bool成员表明了key被插入之前，set中是否已存在相同的key。如果set中已经存在相同key的元素，那么插入操作是会失败的，新的元素不会被插进去。而 multiset::insert(key) 的返回值只是一个iterator，插入操作总是会成功的。 multiset::count(key) 的返回值可能大于1。 multiset::size() 的返回值是multiset中元素的个数，而不是值的个数。比如，{1, 1, 2}的size是3，而不是2。 multiset::erase(key) 会将对应的key全部删掉，所以对{1, 1, 2}调用 erase(1) 之后，它就变成了{2}。 只要key存在于集合中，set::equal_range(key) 的返回值 pair&lt;iterator1, iterator2&gt; 总是会有 ++iterator1 == iterator2。但是对multiset来说就不一定了。","link":"/stl-set/"},{"title":"About CODESTYLE","text":"Commit 命名规范 feat: 一个新功能 fix: 一个 bug 修复 docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等 style: 不影响代码逻辑的修改，比如空格、格式缩进、删除分号等 refactor: 代码重构 perf: 提升性能的改动 test: 增加或修改测试 chore: 改变构建流程、或者增加辅助工具、依赖库等 码风 凡继承自 C 语言的库，均使用 &lt;xxx.h&gt; 而不是 &lt;cxxx&gt; 。 以下情况中，运算符前后 一定 不加空格： for 循环括号内内容较短时（e.g. for(int i=1; i&lt;=n; ++i) ） 运算符前后关系较密切时 以下情况中，运算符前后 一般 不加空格： 变量名长度为 1 时 以下情况中，运算符前后 很可能 不加空格： 考试即将结束时 以下情况中，运算符前后 不可能 不加空格： 除以上情况之外的所有情况 typedef long long ll 。 e.g. （ 2-SAT 模板节选） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int N = 2e6 + 10;struct node { int u, v, next; node() {} node(int _u, int _v, int _next): u(_u), v(_v), next(_next) {}} e[N];int h[N], tot = 0;void add(int u, int v) { e[++tot] = node(u, v, h[u]); h[u] = tot;}int dfn[N], low[N], tag = 0;int id[N], num = 0;stack&lt;int&gt; s;int n, m;void tarjan(int u) { dfn[u] = low[u] = ++tag; s.push(u); for(int i = h[u]; i; i = e[i].next) { int v = e[i].v; if(dfn[v]) { if(!id[v]) low[u] = min(low[u], dfn[v]); } else { tarjan(v); low[u] = min(low[u], low[v]); } } if(dfn[u] == low[u]) { id[u] = ++num; for(; s.top() != u; s.pop()) id[s.top()] = num; s.pop(); }}int main() { freopen(&quot;p4782.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1, _i, a, _j, b, u, v; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;_i, &amp;a, &amp;_j, &amp;b); u = (_i-1)*2 + a, v = (_j-1)*2 + b; add(u^1, v); add(v^1, u); } for(int i=0; i&lt;(n&lt;&lt;1); ++i) if(!dfn[i]) tarjan(i); for(int i=0; i&lt;(n&lt;&lt;1); i+=2) { if(id[i] == id[i^1]) { printf(&quot;IMPOSSIBLE\\n&quot;); return 0; } } printf(&quot;POSSIBLE\\n&quot;); for(int i=0; i&lt;(n&lt;&lt;1); i+=2) printf(&quot;%d &quot;, id[i] &lt; id[i^1] ? 0 : 1); return 0;}","link":"/about-codestyle/"},{"title":"Hexo：为你的博客配置 PWA","text":"本文以 Butterfly 主题为范例。 使用这个方法之前，请先卸载掉其它的 PWA 插件，并安装 Gulp 和 WorkBox。 12npm install gulp-cli -gnpm install workbox-build gulp --save-dev 本文参考利用 Workbox 实现博客的 PWA和Butterfly进阶教程。 写在前面 渐进式网络应用程式（英语：Progressive Web Apps，简称：PWA）是一种普通网页或网站架构起来的网络应用程式，但它可以以传统应用程式或原生移动应用程式形式展示给用户。这种应用程式形态视图将目前最为现代化的浏览器提供的功能与行动装置的体验优势相结合。 当你的网站实现了 PWA，那就代表了 用户可以添加你的博客到电脑/手机的桌面，以原生应用般的方式浏览你的博客 用户本地可以自动生成缓存，二次访问速度大大加快 用户可以离线浏览你的博客 下面的 PWA实现方法借助了 Gulp插件，在站点有内容更新时，可以弹窗提醒用户刷新页面。 开启主题相关设置 以 Butterfly 主题为例，在 butterfly.yml 中开启 PWA 选项 实例： 12345678pwa: enable: true manifest: /manifest.json # 清单文件，下文将介绍如何生成 theme_color: &quot;#fff&quot; # 应用程序顶栏的背景色 apple_touch_icon: /img/pwa/apple-touch-icon.png # 添加至苹果移动设备的主屏幕后显示的图标，尽量使用 png 格式 favicon_32_32: /img/pwa/32.png # 32 * 32 像素，网页图标 favicon_16_16: /img/pwa/16.png # 16 * 16 像素，网页图标 mask_icon: /img/pwa/safari-pinned-tab.svg # 苹果电脑 Touch Bar 区域显示的收藏栏封面图，须使用 svg 格式 图片尺寸要求： apple_touch_icon：192 * 192 像素 mask_icon：viewBox的值必须是 0 0 16 16 如果你的主题没有内置PWA，下面附有Butterfly主题的PWA部分，可以根据你所用的主题调整下面的Pug模板，编译后插入到html生成模板的head处。 12345678910111213link(rel=&quot;manifest&quot; href=url_for(theme.pwa.manifest))if(theme.pwa.theme_color) meta(name=&quot;theme-color&quot; content=theme.pwa.theme_color)if(theme.pwa.theme_color) meta(name=&quot;msapplication-TileColor&quot; content=theme.pwa.theme_color)if(theme.pwa.apple_touch_icon) link(rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=url_for(theme.pwa.apple_touch_icon))if(theme.pwa.favicon_32_32) link(rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=url_for(theme.pwa.favicon_32_32))if(theme.pwa.favicon_16_16) link(rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=url_for(theme.pwa.favicon_16_16))if(theme.pwa.mask_icon) link(rel=&quot;mask-icon&quot; href=url_for(theme.pwa.mask_icon) color=&quot;#5bbad5&quot;) 配置 manifest.json 创建 manifest.json，路径应与配置文件中所填路径相同。 实例及配置说明： 1234567891011121314151617181920{ &quot;name&quot;: &quot;Serok's Blog&quot;, // 应用全称 &quot;short_name&quot;: &quot;Seeker&quot;, // 应用简称 &quot;theme_color&quot;: &quot;#49b1f5&quot;, // 应用主题色 &quot;background_color&quot;: &quot;#49b1f5&quot;, // 加载应用时的背景色 &quot;display&quot;: &quot;minimal-ui&quot;, // 首選顯示模式 //更多顯示模式：&quot;fullscreen&quot;, &quot;standalone&quot;, &quot;browser&quot; &quot;scope&quot;: &quot;/&quot;, &quot;start_url&quot;: &quot;/&quot;, &quot;icons&quot;: [ // 指定 icons 參數，用來適配不同設備 // 需為 png 格式，至少包含一个 192 * 192 像素的圖標 { &quot;src&quot;: &quot;https://snow.js.org/image/pwaicons/192.png&quot;, // 建议采用绝对路径 &quot;sizes&quot;: &quot;192x192&quot;, &quot;type&quot;: &quot;image/png&quot; } ], &quot;splash_pages&quot;: null // 自定義启动动画} default Hexo采用的是严格 Json规范，因此 manifest.json 文件配置好后，需删除文件中的所有注释。 安装插件 在命令行中输入 1npm install workbox-build gulp --save-dev 创建 gulpfile.js 文件 在博客的根目录下，创建一个 gulpfile.js 文件 123456789101112131415161718const gulp = require(&quot;gulp&quot;);const workbox = require(&quot;workbox-build&quot;);gulp.task('generate-service-worker', () =&gt; { return workbox.injectManifest({ swSrc: './sw-template.js', swDest: './public/sw.js', globDirectory: './public', globPatterns: [ &quot;**/*.{html,css,js,json,woff2}&quot; ], modifyURLPrefix: { &quot;&quot;: &quot;./&quot; } });});gulp.task(&quot;build&quot;, gulp.series(&quot;generate-service-worker&quot;)); 创建 sw-template.js 文件 在博客的根目录下，创建一个 sw-template.js 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const workboxVersion = '5.1.3';importScripts(`https://storage.googleapis.com/workbox-cdn/releases/${workboxVersion}/workbox-sw.js`);workbox.core.setCacheNameDetails({ prefix: &quot;Serok's Blog&quot;});workbox.core.skipWaiting();workbox.core.clientsClaim();workbox.precaching.precacheAndRoute(self.__WB_MANIFEST,{ directoryIndex: null});workbox.precaching.cleanupOutdatedCaches();// Imagesworkbox.routing.registerRoute( /\\.(?:png|jpg|jpeg|gif|bmp|webp|svg|ico)$/, new workbox.strategies.CacheFirst({ cacheName: &quot;images&quot;, plugins: [ new workbox.expiration.ExpirationPlugin({ maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 }), new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }) ] }));// Fontsworkbox.routing.registerRoute( /\\.(?:eot|ttf|woff|woff2)$/, new workbox.strategies.CacheFirst({ cacheName: &quot;fonts&quot;, plugins: [ new workbox.expiration.ExpirationPlugin({ maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 }), new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }) ] }));// Google Fontsworkbox.routing.registerRoute( /^https:\\/\\/fonts\\.googleapis\\.com/, new workbox.strategies.StaleWhileRevalidate({ cacheName: &quot;google-fonts-stylesheets&quot; }));workbox.routing.registerRoute( /^https:\\/\\/fonts\\.gstatic\\.com/, new workbox.strategies.CacheFirst({ cacheName: 'google-fonts-webfonts', plugins: [ new workbox.expiration.ExpirationPlugin({ maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 }), new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }) ] }));// Static Librariesworkbox.routing.registerRoute( /^https:\\/\\/cdn\\.jsdelivr\\.net/, new workbox.strategies.CacheFirst({ cacheName: &quot;static-libs&quot;, plugins: [ new workbox.expiration.ExpirationPlugin({ maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 }), new workbox.cacheableResponse.CacheableResponsePlugin({ statuses: [0, 200] }) ] }));workbox.googleAnalytics.initialize(); 注意：把 prefix 修改为你博客的名字（最好用英文）。 上面的文件涵盖了大多数资源的缓存策略。如果你想缓存其他类型的资源（例如一些国内的镜像 CDN 库），或者想使用其他的缓存方式，请自行查看相关文档并添加。 添加 js 进主题 配置 butterfly.yml, 添加需要的 css 和 js 12345inject: head: - '&lt;style type=&quot;text/css&quot;&gt;.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}&lt;/style&gt;' bottom: - '&lt;div class=&quot;app-refresh&quot; id=&quot;app-refresh&quot;&gt; &lt;div class=&quot;app-refresh-wrap&quot;&gt; &lt;label&gt;✨ 网站已更新最新版本 👉&lt;/label&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;location.reload()&quot;&gt;点击刷新&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t=&quot;light&quot;===document.documentElement.getAttribute(&quot;data-theme&quot;)?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:&quot;已更新最新版本&quot;,backgroundColor:t,duration:5e5,pos:e,actionText:&quot;点击刷新&quot;,actionTextColor:&quot;#fff&quot;,onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${&quot;light&quot;===document.documentElement.getAttribute(&quot;data-theme&quot;)?&quot;#49b1f5&quot;:&quot;#1f1f1f&quot;};`;document.getElementById(&quot;app-refresh&quot;).style.cssText=o}}&quot;serviceWorker&quot;in navigator&amp;&amp;(navigator.serviceWorker.controller&amp;&amp;navigator.serviceWorker.addEventListener(&quot;controllerchange&quot;,function(){showNotification()}),window.addEventListener(&quot;load&quot;,function(){navigator.serviceWorker.register(&quot;/sw.js&quot;)}));&lt;/script&gt;' 同样，如果你使用的不是Butterfly主题，可以在所示代码的基础上修改以适配你的主题。以下是展开后的代码，便于修改调试。 以下代码请插入到头部 &lt;/head&gt; 之前： 1234567891011121314151617181920212223242526&lt;style type=&quot;text/css&quot;&gt; .app-refresh { position: fixed; top: -2.2rem; left: 0; right: 0; z-index: 99999; padding: 0 1rem; font-size: 15px; height: 2.2rem; transition: all 0.3s ease; } .app-refresh-wrap { display: flex; color: #fff; height: 100%; align-items: center; justify-content: center; } .app-refresh-wrap span { color: #fff; text-decoration: underline; cursor: pointer; }&lt;/style&gt; 以下代码请插入到底部 &lt;/body&gt; 之前： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div class=&quot;app-refresh&quot; id=&quot;app-refresh&quot;&gt; &lt;div class=&quot;app-refresh-wrap&quot;&gt; &lt;label&gt;✨ 网站已更新最新版本 👉&lt;/label&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;location.reload()&quot;&gt;点击刷新&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; if ('serviceWorker' in navigator) { if (navigator.serviceWorker.controller) { navigator.serviceWorker.addEventListener('controllerchange', function () { showNotification() }) } window.addEventListener('load', function () { navigator.serviceWorker.register('/sw.js') }) } function showNotification() { if (GLOBAL_CONFIG.Snackbar) { var snackbarBg = document.documentElement.getAttribute('data-theme') === 'light' ? GLOBAL_CONFIG.Snackbar.bgLight : GLOBAL_CONFIG.Snackbar.bgDark var snackbarPos = GLOBAL_CONFIG.Snackbar.position Snackbar.show({ text: '已更新最新版本', backgroundColor: snackbarBg, duration: 500000, pos: snackbarPos, actionText: '点击刷新', actionTextColor: '#fff', onActionClick: function (e) { location.reload() }, }) } else { var showBg = document.documentElement.getAttribute('data-theme') === 'light' ? '#49b1f5' : '#1f1f1f' var cssText = `top: 0; background: ${showBg};` document.getElementById('app-refresh').style.cssText = cssText } }&lt;/script&gt; 运行 为了方便每次部署，可以在你的博客根目录下新建 deploy.sh，添加以下内容： 123456789#!/bin/shecho &quot;Start&quot;hexo cleanhexo generategulphexo deployecho &quot;Finish&quot;echo 按任意键继续read -n 1 然后每次部署就可以直接运行这个脚本了。","link":"/hexo-gulp-pwa/"},{"title":"D2T1：贪心、二分、并查集","text":"一些技巧 常见的贪心技巧 货币使用问题： 尽可能少用，那么我们就先拿面值最大的，依次往下走，最后拿光了即可。 区间调度问题： 工作时间不能重叠，在可选工作中，每次都选取结束时间最早的作为选择，可以使工作量最大。 切题小技巧 递归，从后向前 预处理 划分子结构 单调队列、滑动窗口 能剪的枝一定要减！能剪的枝一定要减！能剪的枝一定要减！ 但是剪枝别剪挂了…… 手动扩栈 编译时指定参数 1-Wl,--stack=size size是栈的大小，单位为字节。 一些题 P5686 [CSP-SJX2019]和积和 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int N = 500005, P = 1e9+7;int n;ll a[N], b[N], sa[N], sb[N], s[N], ssa[N], ssb[N];int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, a+i); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, b+i); ll ans = 0, s = 0, sa = 0, sb = 0; for(int i=n; i&gt;=1; --i) { sa += a[i]*(n+1-i)%P; sa%=P; sb += b[i]*(n+1-i)%P; sb%=P; ll del = ((a[i]*sb%P + b[i]*sa%P)%P + P - a[i]*b[i]%P*(n-i+1)%P)%P; s += del; s %= P; ans += s; ans %= P; } printf(&quot;%lld\\n&quot;, ans); return 0;} U129453 「EZEC-4.5」占座位 题解 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;map&lt;ll, ll&gt; f;ll n, k;ll dfs(ll n) { if(f[n]) return f[n]; if(n &lt; 2*k+2) return f[n] = 1; return f[n] = dfs(n/2) + dfs(n-n/2);}int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); if(k == 0) printf(&quot;%lld\\n&quot;, n); else printf(&quot;%lld\\n&quot;, dfs(n)); return 0;} P1182 数列分段 Section II 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int N = 1e5 + 10;int n, m; ll a[N];bool check(ll v) { ll sum = 0, pt = 0; int i=1; while(i&lt;=n) { while(i&lt;=n &amp;&amp; sum + a[i] &lt;= v) { sum += a[i]; ++i; } ++pt; if(pt &gt; m) return false; sum = 0; } return true;}int main() { //freopen(&quot;p1182_1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); ll l=1, r=1e9; for(int i=1; i&lt;=n; ++i) { scanf(&quot;%lld&quot;, a+i); l = max(l, a[i]); } while(l &lt; r-1) { ll mid = l+(r-l)/2; if(check(mid)) r=mid; else l=mid+1; } if(check(l)) printf(&quot;%lld\\n&quot;, l); else printf(&quot;%lld\\n&quot;, r); return 0;} P2822 [NOIP2016提高组]组合数问题 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 2200, INF = 0x3f3f3f3f;int c[N][N], sum[N][N];int T, k;int main() { scanf(&quot;%d%d&quot;, &amp;T, &amp;k); c[0][0] = 1; for(int i=1; i&lt;=2000; ++i) { c[i][0] = 1; for(int j=1; j&lt;=i; ++j) { c[i][j] = c[i-1][j-1] + c[i-1][j]; c[i][j] %= k; } } for(int i=0; i&lt;=2000; ++i) { for(int j=0; j&lt;=i; ++j) { sum[i][j] = (c[i][j] == 0); } } for(int i=0; i&lt;=2000; ++i) { for(int j=1; j&lt;=2000; ++j) { sum[i][j] += sum[i][j-1]; } } for(int j=0; j&lt;=2000; ++j) { for(int i=1; i&lt;=2000; ++i) { sum[i][j] += sum[i-1][j]; } } while(T--) { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); printf(&quot;%d\\n&quot;, sum[n][min(n,m)]); } return 0;} P1007 独木桥 求最大时间时，把碰面想象成交换身份即可 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int l, n, p[5005];int main() { scanf(&quot;%d%d&quot;, &amp;l, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, p+i); int ans1 = 0; for(int i=1; i&lt;=n; ++i) { ans1 = max(ans1, min(p[i], l+1-p[i])); } int ans2 = 0; for(int i=1; i&lt;=n; ++i) { ans2 = max(ans2, max(p[i], l+1-p[i])); } printf(&quot;%d %d\\n&quot;, ans1, ans2); return 0;} P3958 [NOIP2017提高组]奶酪 自底至上找出通路，可以联想到森林合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1100;struct node { LL x, y, z;} a[N];bool cmp(node a, node b) { return (a.z &lt; b.z);}bool tp[N], bt[N];int fa[N], T, n;LL h, r;int root(int x) { return fa[x]==x?x:root(fa[x]);}bool check(int i, int j) { LL dist = (a[i].x-a[j].x)*(a[i].x-a[j].x) + (a[i].y-a[j].y)*(a[i].y-a[j].y) + (a[i].z-a[j].z)*(a[i].z-a[j].z); return dist &lt;= 4*r*r;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%lld%lld&quot;, &amp;n, &amp;h, &amp;r); memset(bt, false, sizeof bt); memset(tp, false, sizeof tp); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld%lld%lld&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z); sort(a+1, a+n+1, cmp); for(int i=1; i&lt;=n; ++i) { if(a[i].z - r &lt;= 0) bt[i] = true; if(a[i].z + r &gt;= h) tp[i] = true; } for(int i=1; i&lt;=n; ++i) fa[i] = i; for(int i=1; i&lt;=n; ++i) { for(int j=i+1; j&lt;=n; ++j) { if(check(i, j)) { fa[root(i)] = root(j); } } } bool fla = false; for(int i=1; i&lt;=n; ++i) { if(bt[i] &amp;&amp; tp[root(i)]) { fla = true; break; } } printf(&quot;%s&quot;, (fla ? &quot;Yes\\n&quot; : &quot;No\\n&quot;)); } return 0;}","link":"/noip-d2t1/"},{"title":"Hexo：将你的博客部署到 Vercel","text":"写在前面 近些日子，静态网站的热度又渐渐高了起来。相比于动态网站，静态网站具有轻量、无需服务器、利于SEO、速度快等特点，非常适合个人博客。再加上Hexo、Hugo等静态博客渲染框架的日渐成熟，已能与Wordpress、Typecho等老牌动态博客框架分庭抗礼。 与此同时，很多静态托管网站也应运而生。各种托管网站看似鱼龙混杂，其实由于各种原因，在国内能用的也就那么几家；如果你像我一样，没有服务器、没有备案，还想白嫖（），那么仅有的选择就更少了。综合各种因素，目前最适合托管静态博客的服务有： GitHub Pages 微软旗下，闻名遐迩的全球第一大开源仓库网站。服务器设在荷兰、美国等地。部分地区部分运营商的用户可能遭到DNS污染，无法正常访问。 Gitee Pages OSCHINA旗下，服务器在上海腾讯云，速度较快，较稳定，提供 xxx.gitee.io 域名，不支持免费自定义域名。 旧Coding Pages 腾讯旗下，服务器在香港/新加坡腾讯云，速度较快，但稳定性差。部分地区速度极慢或不能访问。支持免费自定义域名。 新Coding Pages 与腾讯云绑定食用，功能较齐全，但按量计费。 Vercel 原名Zeit，服务器在美国，在港台有CDN节点。速度略慢于Coding，但大部分地区均可正常访问。提供自定义 xxx.now.sh 和 xxx.vercel.app 域名，且支持免费绑定个人域名。 大部分网站采用的一般都是GitHub + Coding双部署的形式。这种方法比较麻烦，需要DNSPod解析，因此需要实名认证，而且还真未必快到那里去。 Colsrch大佬出过一篇三部署教程，使用了Coding（联通线路），Vercel（默认线路），Cloudflare回源GitHub Page（移动线路），速度略有提升，但是门槛较高，对小白并不友好。而且近期Coding似乎越来越不稳定了，所以也不太推荐此方法。 下面是晚上六点左右，Vercel与Gitee的速度对比。和99块钱相比，慢点就慢点吧（ 还是由于某种原因，市面上的Vercel部署教程并不多。而且由于Vercel里的一些操作还是挺不常规的，所以就写了这么一篇文章，说一下将网站部署在Vercel的详细过程。 导入 GitHub 仓库 Vercel是一个静态网页部署网站，并不托管代码。因此，我们通过GitHub来托管 hexo deploy 生成的网页文件，并设置自动导入。当你的源代码仓库有变动后，Vercel会第一时间检测到并重新部署网站，部署完成后会通过邮件提醒。 :::default 在开始之前，请准备一个 GitHub账号（注意不能是绑有QQ邮箱的）、一个Git仓库（存储Hexo生成的页面）。 ::: 进入Vercel官网，点击 Continue with GitHub 注意：如果出现下图所示的情况，请确认你的GitHub账号上没有绑QQ邮箱（即便它不是主邮箱）。如果仍然报错，请换用国外邮箱。 授权完成后，选择 Import Git Repository，点击Continue，进入如下界面。输入你的仓库 url（https）。 :::default 如果你配置过 GitHub Pages，那么这个地方直接填入你的 GitHub Pages仓库就可以了。 注意：你生成的页面应推送至 master 分支，而不是 gh-pages 分支。如果你之前设置了多部署，比如： 123456deploy: type: git repo: github: xxx coding: xxx branch: master 请务必将 GitHub 拆出来单独写，就像这样： 1234567deploy:- type: git repo: coding: xxx- type: git repo: git@github.com:xxx/xxx.git branch: master 因为如果按照第一种方式，你的生成页面有一定概率会被推送至 gh-pages 分支（由于 Hexo 的默认设置），导致Vercel无法拉取。 ::: 导入项目中会弹出一些自定义选项，不知道会出什么锅的话就不要改，顺着右下角的蓝色键一直点，遵照默认选项就可以了。 这里建议选择 All repo，方便后续部署。 部署完成后，Vercel会提供几个默认域名，可以通过 [项目名].[用户名].vercel.app 访问。 自定义域名 进入 dashboard，点击[项目卡片] -&gt; View Domains 如果你想使用Vercel提供的二级域名，直接添加 xxx.now.sh（或 xxx.vercel.app，看你想要哪个），如果无人占用，会自动验证成功。 如果你想绑定自己的域名，也是在输入框中输入你想要绑定的网址，点击右侧 Add即可。下方会提示Invalid Config，并给出两种绑定方式（A/CNAME + NS），但是不要听他的，而是请按照下面的方式： 验证方式 如果是根域名，请在你的DNS解析处添加 A记录，指向 76.76.21.21 如果是子域名，请在你的DNS解析处添加CNAME记录，指向 cname.vercel-dns.com 添加记录后等待片刻再刷新，下面显示两个对号即表明验证成功。 重定向 如果你绑定了多个域名，可以点击域名卡片右上角的 Edit，将某个域名重定向至你的其他域名。 后话 至此Vercel的部署过程就结束了。 :::warning 初次部署后再进入dashboard，可能会偶尔出现配置好的域名显示invalid config的现象，尽管DNS解析是正常的。经博主测试，此状态下网页仍能正常访问（已排除DNS缓存的问题），可能是Vercel面板的bug吧。 ::: 部署有问题可以到留言板留言，或者直接向 support@vercel.com 发邮件（不清楚能不能用中文），一般一到三天后会回复。","link":"/hexo-vercel/"},{"title":"Hexo：配置 SSH 公钥部署","text":"配置 git 使用 ssh 密钥 git 支持 https 和 git 两种传输协议。其实两种方式都可以，但是如果使用https协议，每次pull、push都要输入密码（大部分电脑上），所以建议使用ssh密钥对认证，可实现免密且更加安全。下面将介绍Hexo如何配置 SSH 公钥部署。 示例在Windows环境下。 Step 1：生成密钥对 - 进入 C:\\用户\\[你的用户名]/.ssh 文件夹，右键唤出 PowerShell - 输入 ssh-keygen，并一直敲击回车至密钥图生成，可以看到文件夹中多出了两个文件：id_rsa 和 id_rsa.pub 实例： 12345678910111213141516171819202122SerokSSR@Desktop-ABCDEFG ~\\.ssh&gt; ssh-keygen Generating public/private rsa key pair.Enter file in which to save the key (C:\\Users\\SerokSSR/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\SerokSSR/.ssh/id_rsa.Your public key has been saved in C:\\Users\\SerokSSR/.ssh/id_rsa.pub.The key fingerprint is:SHA256:fO7pVFqZ464nC8H6B3pTE8cwPx2mTM0G8KJt7Or2L8o SerokSSR@DESKTOP-ABCDEFGThe keys randomart image is:+---[RSA 2048]----+| ...+ || o.. * || .B.= . || o +..Bo. || S =o*. || ..*o= . || ...o=.. || .o+=+o. || +E*BBo |+----[SHA256]-----+ Step 2：配置远程仓库的公钥 - 访问GitHub，点击 头像 -&gt; Settings -&gt; 左侧SSH and GPG keys -&gt; 右上New SSH key - 打开你刚才生成的 /.ssh/id_rsa.pub，把里面的内容全选复制到Key栏中，Title栏可不填 - 点击 Add SSH key，完成添加 Step 3：验证密钥是否生效 控制台输入 ssh -T git@github.com，出现如下回复则密钥已生效。 123SerokSSR@DESKTOP-ABCDEFG ~\\.ssh&gt; ssh -T git@github.comHi SerokSSR! Youve successfully authenticated, but GitHub does not provide shell access. Step 4：添加 SSH 仓库 在你的博客根目录下的 _config.yml，找到 deploy选项，将你仓库的ssh链接添加至此处。 实例： 1234deploy:- type: git repo: git@github.com:SerokSSR/snow.git branch: master Step 5：配置Hexo部署 为了方便每次部署，可以在你的博客根目录下新建 deploy.sh，添加以下内容： 12345678#!echo &quot;Start&quot;hexo cleanhexo generatehexo deployecho &quot;Finish&quot;echo 按任意键继续read -n 1 然后每次部署就可以直接运行这个脚本，而不用每次都要敲一遍 hexo cl&amp;&amp;hexo g&amp;&amp;hexo d了。","link":"/hexo-ssh-deploy/"},{"title":"NOIP2020 游记","text":"（2021.4.29 补记） 这篇游记在去年十一月份开坑，一月份的时候正式写完。 还记得得知判决的那个晚上，我咕掉作业抱着手机坐了一整晚，还和家长起了一些争执。几个月以后再回来看，心态也平和了许多吧。可能这段经历不能带给我别的什么，也可能再过一段时间会为当时的选择而自怨自艾，为什么不最后冲一把，说不定就…… 不过没有如果了吧。到了现在早就没有回头路了，何况回头路上还布着更跌宕的坎坷。@SiRiehn_nx 能够逆天改命，又不代表你也可以，真以为自己行了啊。 上面这些可能更多是写给未来的自己的吧，提醒自己不要后悔，没必要再去填补句号的空白。 高二 OIer @SerokSSR，坐标 TJ。 退役了。 Once upon a time 大概是 NOI Online 刚开始的时候吧，就想着该为 1= 做准备了。三场全都参加了，第一次忘写头文件，第二次抽屉原理不会，第三次才将将苟进了全国前 25%。 说实话是挺沮丧的，当时觉得省一没戏了，但是还是想努力一把。 Summer 暑假报了 luogu 网课。之前一直没系统学过 DP，结果看提纲发现 DP 直接从状压开始讲，于是从 0 开始恶补了好一阵子，但是还是写不出方程来。 网校讲到后面的课基本上都听不大懂了，记得数论听了一半就去睡觉了。 要了基础组的深基，边补基础边学背包，暑假基本就这么过去了。 开学打算把竞赛暂时放一放，因为其实不太想报 -OH，只是想在退役前圆一个省一梦。 CSP-S1 第一个月过去了，基本上是每周末如果作业写完了就写几道题，如果作业太多就咕掉。 去考初赛，以前一直是有分就行，所以没啥压力。 选择题似乎比较水很快做完了，然后看程序，一看这不是昨天 luogu 刚出的 nth_element，瞎分析了一波复杂度全写上了。 被 $O(n)$ 的 map 笑到了，但是题还是不会做。搞了一阵子发现是宽搜，怎么搜的还是看不懂。选项全是蒙的。 最后一个 DP 也没看懂，随便选了几个长得好看的写上了。 出来估分 60~70，听母上大人说有个小孩出来高兴地说太简单了 我：??? 最终得分 83，成了 rank4 可惜初赛分无一点用，复赛还是一道题不会做。 今年复赛考点换成 nk，初赛线都划到 44 了，有点可啪。 之后渐渐就是能不写的作业都不写了，每周末基本上两个整天都在学 OI。 CSP-S2 和期中考试正好在同一周。Singercoder 直接把期中咕掉了，我想了想自己的 OI 水平，还是参加了，不过除了物理生物基本都没咋复习。上午考完，回家就对着电脑坐一下午。 听说过了一轮就可以去考 NOIP，所以也没特意准备。第二天上午背了背 Tarjan 板子，直接去考试了。 开场一看 T1 是个大模拟，觉得自己的码力问题不大（，就开始写 结果写了两个小时，1600 年之后还是一年一年跳的。过了大样例。结果跟脑子短路了一样，不开 T2 开始想 T1 优化。。。 然后就一直调不对了。 最后一小时扔掉调不出来的 T1 想 T2，草草读完题，互不相同也没注意到。$O(k\\times 2^k)$ 走人。 赛后出考场估分 80+40+20+0，以为还可以。 晚上 luogu 自测，发现 T1 年份边界全写挂了，T3 还没取模，T4 白送的 20 分暴力也没写。 当时就流眼泪了，捂着眼，我说停停。 脚造大样例，问候出题人。 周一浑浑噩噩地去上课。mrc 劝我赶快停课，我想了想确实，但是还是等一会吧。 心态快崩了，不过倒是没崩。 停课 期中出分了，班级 rank3，年级在 rank5 左右。 可是人总是想得到没得到的东西的。 找杨鸽签了假条，周五正式开始停课。当时是 11.27，离 NOIP2020 还有刚好两周。 之后的日子也不清楚是怎么过来的。刷历年的题、写总结、写题解看题解，一天一天就这么过去了。 开始喜欢听古风歌了。耳机单曲了好一阵子的 风筝误 和 不见长安。 他还陷在那段隔世经年的梦 静静和衣睡去 不理朝夕 CSP 出分了，10+40+10+0=60 rank36，省三第一。已经有心理准备了，心情没太波动。 NOIP-1 图书馆真的安静，Singercoder 和 zach0914 都不说话。 中午去踢球，后防被对面特长生冲烂了。 看了一天的 DP 题和题解，快放学的时候才知道期望的定义 回家把做过的题往脑子里塞，看到大概 8:00 左右。 然后开始看 KPL，想着 DYG 一定要赢啊。结果眼睛是看着比赛，脑子里想了很多乱七八糟的，紧张的要死。 打到 3:2 的时候十点多了，去睡觉。 一晚上没睡好。 NOIP 早晨看了眼微博，DYG 4:2 AG，心情略微好了一点。 在门口集合的工夫和 zach0914 和 lth 说了说话。lth 掏出了刘汝佳开始看。 过了一会儿 Singercoder 也到了，一起进去。进考场看见了 SiRiehn_nx（当时还叫 zhltao），听他 fAKe 了几句。 CSP 的时候显示屏糊的要死，这回终于换了。 一坐在座位上反倒不那么紧张了，想着尽力就好吧。骑车来的，虽然有戴手套，不过还是冻僵了。 8:30 开考。T1 一看拓扑板子直接开始敲，手有点僵硬，而且中间有一段时间怎么也过不去样例，很慌，几乎把中间变量全输出了一遍，发现是次序写反了。然后大样例又没过。随手把 int 换成了 long long 竟然过了，当时感觉这题稳了。信心很足。用时 35min。 看 T2，觉得 NOIP 不可能考 KMP 的（，所以想怎么 DP。想不出来，上来开始大力模拟，敲了 30min 左右过了前两个样例，第三个本机跑了 2s，问题有点大。 打算把字母全相等的点先放一放，去看 T3。暴力都没有一点思路，想着 T4 估计会更难，必须得把这个的部分分拿下来。然后还是没有思路。 只好去看 T4，读题就读了好久。显然是我不可做的题，直接上爆搜，感觉细节不是一般的多，就没敲，回去把 T2 的相等情况写了。直接拿暴力改的，觉得没问题就没对拍。又看了一会儿 T3，还是没思路。 觉得必须得开 T4 了。枚举好像就很麻烦，最后用了一个递归生成状态，然后开了个 map&lt;vector&lt;int&gt;, vector&lt;int&gt; &gt; 判无解……看前两个样例都过了，就这样吧。现在一想感觉自己是个 zz，为啥不状压一下啊。 很快就中午了，感觉有点饿。忽然想到 T2 可以前缀和优化一点点，写上发现第三个点直接降到了 0.2s，这回应该很稳了吧。当时估了一下分，100+56+0+10，因为 T1 直接是板子觉得这回不太行，又去想 T3。 一想不管了，直接把暴力敲上。敲了 100 多行一运行直接爆栈了，一看只有半个多小时了，干脆全删了打了个随机数，开始检查。 剩 20 多分钟的时候发现 T2 的相等做法 WA 了……调了十分钟没调出来，横下心不管了。然后就一遍一遍地查 freopen 和路径。 考完一个一个去前面核对程序，结果我是我们考场倒数第二个。出来的时候，其他考场已经都走光了。当时脑子里就全是空白的，想着这样也挺好，千万不要听到别人讨论做法。 nk校园确实比某数字中学好看一万倍 考前一周，jzx 在给下一届的放 KMP 讲解视频。 我：这东西根本不用会吧 QAQ，NOIP 一辈子没考过 考试前一天，我们一群人在图书馆口胡押题。 我：拓扑 CSP 刚考完啊，也不会再考第二遍了吧 开过光的嘴。。。 忍不住上 luogu 看了看，看见第一题 1~m 的时候整个人都不好了。后来看见 CZ 说不卡这个又活了过来。高精卡不卡就无所谓了。 oitiku 90+48+0+30，测了一圈似乎都比我分高 /fad 很慌。 洛谷和 oitiku 的分一样。看了看讨论区，1= 应该是稳了吧 /qaq。不知道蓝勾有没有。 心情挺复杂的。明明已经完成目标圆满退役了，却总觉得少了点什么，心里空荡荡的，似乎既有不甘，又有不舍。OI 真的就像划过黑暗的流星，闪着荧烁的火光，可消失却只需短短一瞬。你甚至来不及准备。 我看着自己的排名，又无可救药地动起了心思，尽管理智告诉我希望渺茫。我想着该让自己冷静冷静了，于是打开电脑，写了这么一篇游记。 Future 周围的人和我自己都在告诉我，说你应该认清自己，比起冲队，whk 才是更优解吧，无论是从性价比还是从实力。话是这么说，距离将它接受成现实可能还需要一段时间了。 最后祝我自己好运，祝 rsx(SiRiehn_nx)、lgh(Singercoder)、zsh(tyslsiZ) RP++, AK IOI. 谨以此文纪念我的 OI 生涯。 T1 出题人的双亲大概是溘然长逝了吧，连交换律都卡。90-&gt;60。靠这个做区分度是我没想到的。 60+48+0+30 = 138，弱省 rank10，无缘蓝勾。 就这样吧。 初中的直接从榜上消失了？CCF 属实迷惑操作，让人家参加结果连成绩证明都不给。 这 1= 线真的离谱…最终 rank7，以最后一名的成绩苟到了 1=。 怎么感觉要进队了（ 等等我好像比基准线高了？？？那岂不是说… 果然。 TJ 分到了七个省队名额，而七个 1= 被数字中学和 nk 包揽了；因为我比基准线高，所以执行三分之一限制。也就是说有两个省二能进队；而我和 rsx 如果想进队，必须要考到自己学校的第二名。rsx 有一点点希望，而且他是高一，还有无限的可能。 而我… 得知消息的那天晚上，刚好作业不多。我对着手机，坐了一整晚。 这大概是我离 Cu 最近的一次了。可我刚要反应过来，它却早已裂成了碎片。 后来想了想，我确实完全没有在 NOI 拿到 100+ 的能力。A 过最难的题是绿题（其他的不是板子就是教练带着做的），DP 和图上问题考场上永远是只会敲暴力。今年的题但凡阳间一点，可能就要复刻去年的结局了。就算侥幸进了队，也要押上半个高考，去赌一个渺茫的未来。 从 2018 年暑假入坑，到现在两年多了，可水平似乎从 18 年的普及开始就在原地踏步。只是多会了一些算法，犯病的概率减少了一些。见到带点思维难度的就直接投降。至今没有打过一场 CF。 还是不够强罢了。 甘心吗？当然不甘心。为什么这套题才考了一百分的就能进队，而我却没有了机会。难道这就是所谓的公平吗，whk 成绩越低越好？确实，即使没有校杀，最后的结局很可能也没有什么变化，可我仍然希望做出选择的人是自己。尽管可能他们才是对的吧。 可又能怎样呢。 都结束了吧。 高考加油。","link":"/noip2020-you-ji/"},{"title":"CF387D","text":"题意分析 操作最少的次数，构成有趣图，注意无重边，有向边。 操作分为加边和删边。 有趣图定义 有一个中心，满足此点有自环，且与其他结点有双向边。 除中心点外的结点，满足出度 = 入度 = 2。 算法分析 1、仔细分析有趣图的定义，发现如下性质： 中心的边数为 $(n-1)\\times 2+1$，也就是它与其他结点要有双向边再加自己的一个自环，无重边所以构造中心点时不可能做删除操作，只能加边或不操作。 其他结点的出入度为 2，排除掉与中心点连接的双向边，其点的度一定为一进一出。 2、如何判断结点的度满足一进一出。 图一，图二都是满足结点度一进一出。所以 $n$ 个结点需要 $n$ 条相连边（首尾）。 图三不满足，只有两条相连边 $(e_1,e_2)$ 或者选择 $(e_1,e_3)$ 即有用边,还需要添加 $n-2$ 边有用边，同时还要减掉 1 条边，即总边数减去有用边，也就是要删除的无用边。 方法1：拆点，一个点拆为进点和出点，建立二分图。 ​ 左边的点求匹配，最大匹配就是有用的边。 方法2：直接将图看成二分图，利用有向边每个点都求匹配。 3、枚举每个点做中心点。 中心点 V，计算维护中心需要的边 $(n-1)\\times 2+1-\\sum{V发出的边}$ 删除 V 点，也就是包含相应的边 剩下的图，计算最大匹配，满足一进一出的边数需要的操作（添加边 + 删除边）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int N = 550, INF = INT_MAX;vector&lt;int&gt; g[N];int c, n, m;int tag = 0, vis[N], match[N];bool mp[N][N];bool dfs(int u) { for(int i = 0; i &lt; g[u].size(); ++i) { int v = g[u][i]; if(v == c) continue; if(vis[v] == tag) continue; vis[v] = tag; if(match[v] == 0 or dfs(match[v])) { match[v] = u; return true; } } return false;}int best = INF;int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sum0 = 0; for(int i=1, u, v; i&lt;=m; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u].push_back(v); mp[u][v] = true; ++sum0; } for(int i=1; i&lt;=n; ++i) { memset(match, 0, sizeof match); c = i; int ans = 0; int sum1 = 0; for(int j=1; j&lt;=n; ++j) { if(j == c) { if(mp[c][c]) ++sum1; continue; } if(mp[j][c]) ++sum1; if(mp[c][j]) ++sum1; } ans += 2*(n-1) + 1 - sum1; //printf(&quot;ans1 = %d\\n&quot;, ans); //printf(&quot;sum1 = %d\\n&quot;, sum1); int sum2 = 0; for(int j=1; j&lt;=n; ++j) { ++tag; if(j == c) continue; if(dfs(j)) ++sum2; } ans += sum0 - sum1 - sum2 + n-1 - sum2; best = min(best, ans); //printf(&quot;ans2 = %d\\n&quot;, ans); //printf(&quot;sum2 = %d\\n&quot;, sum2); } printf(&quot;%d\\n&quot;, best); return 0;}","link":"/cf387d/"},{"title":"凝眉","text":"他和她走下车。站台上熙熙攘攘的人守望在那里。没有人向他们看上一眼。 他们停下脚步，看着列车消失在金色的反光里，只留下无底的空白。 “所以……新见和五反田他们呢？”高桥问道。 “他们？他们不会来了。”他想了想道。“他们来过这里。” 她点了点头。 “走吧。” 他握住她的手。 他们费力地拨开人群。等他惊觉的时候，那只手已经松开了。他张望着伸长了脖子，似乎想在人海中辨出她的身影，却像极了在水中捞月的猿。 出得车站，迎面便是阵阵狂风。雪浪排空，秋云怒卷。眼见得风越来越大，他跑向公交站，赶上了去往营口道的车。街上行人寥寥，许是都躲进路旁的小店了吧。 离码头不远的地方，他看到了一个女孩，头发披散在肩上，斜挎着包，朝着风来临的方向走去。他只是瞥了她一眼，很快就失去了兴致，目光投向前面的世纪钟和几幢小楼。 高桥匆匆地走着，不安地环顾着周遭的一切。她大致知道这是什么地方了。风卷着沙砾扫过，不舍昼夜。她略略低下头，眼中只有脚下的路。 他闭上眼，眼前突然又浮出她的音容。他抿起嘴，知道这里没有白来。他一定能遇见她。 地铁站门口的长椅上，一名穿着X中校服的男孩倒在那里。不断地，有的人指指点点，有的人掏出手机，更多的人就擦身而过，一如他们的来时。人们围成一圈一圈的波纹胀缩着，像吞吐的白鲸。 救护车很快赶到了。几个人没等停稳就跳下了车，确认那个男孩还活着，便麻利将他收拾好，三下五除二地抬了上去。车呜呜叫着开走了。 波纹抖动了几下，接着便是轰轰烈烈的溃败。 他跌跌撞撞地起身远去。尽管深一脚浅一脚地走着，他的足迹却惊人地笔直，就像大地在随着他的步履而偏移。 他捡起地上散落的酒瓶，正要往嘴里灌，又哐地摔碎到了地上。水流像蛇一样沿着砖缝汩汩爬去，留下属于他的未来。 雾开始落下来。 他偷偷走到她的身后，一把蒙住了她的眼。她象征地挣扎了几下。他很快松开手，向后退了几步，眼里映满了她的影子。 “还是找到这里了啊，”他笑着说。 她白了他一眼。 他揽住她的腰。皎皎清光透过楼梯侧的窗，洒进空无一人的走廊里，散着幽沁的香。 他和她坐在跑道边，说是要等着，等最后一片云霞沉寂在地平线下。时不时地，他们凑在对方的耳边，轻声低语；欢谑声里，沉沉的烟火灿烂着，像雪染成的白绫。风打在他和她的肩上。 那片云明明随风飘摇着，却迟迟没有离去。月亮不息地转动着。缓缓地，他和她之间像是有些什么，成片成片地生长着，拣尽寒枝。 像一束一束的光。 果然还是偏离了啊，他无声叹道。错过了那一瞬，就算过后再怎么努力，就算你已拥有了一切，你如履薄冰，你不敢高声语，你尽力维护着原样的展览馆。殊不知时间没有负半轴。你再也回不到从前。 他闭上眼。那时他想了太多，他不知道孰对孰错，他不着边际地猜着，就这样过去了。后来他迷途知返，却已无路可退。 “今天……月亮好好看。”他睁开眼，看看天，又看看她。她也望向天空，微蹙眉头，显得有些诧异。大概是没有感到什么分别吧。一湾再普通不过的月亮，撒着空灵的光。 她不着痕迹地点了点头。 他的目光没有移开。她怔了怔，略略偏过头，唇角勾起一个弧度，又回过头正视着他。 远处传来一声巨响。 他回过神，发觉视野的凝滞。她的眼里似乎闪过了一道意味难明的神采来。他没有看清，可即便他看清的话，他也一定会以为那盈盈秋水里，映着的是他自己的影子。 一如她方才的浅笑，一落在他的眼里，便似料峭雪峰陡然塌落，绽起了明媚的飞光。 贪、嗔、痴、怨，爱别离，求不得。 世界的走向尽管去变吧，他想。连过去都错过了，还谈什么未来呢。 他已经无路可退。 他堵住了她的唇。接下来的事已经从这个世界上抹去了，他试着撕开那层薄纱，也终究只能看到未来的投影。两个人滚在一起。一朵血梅葳蕤绽放。 生生繁华于枯荑，萋萋空翠自灵犀。辉星皓夜苍千顷，此宵风醉月舞萤。 他迷迷糊糊地睁开了眼，在一片山水里。满川的红叶簌簌飘落，尽是离人眼中血；他拼了命想要醒来，却像陷在了无垠的沼泽。他只好回到梦中，描绘了她的远去，宛若降兮北渚的帝子。后来他才发现，原来是梦里有个小人拦在他的面前，死命拽住了他的脚，怎么也不愿意长大。 他离开了那个地方，却不知是怎么做到的。一如来时。她早已不在他身旁。他觉得很可笑，明明是亲手缔结的世界，却如同活在梦中。 他原以为能找回他失去的东西的。可他反倒又丢失了好多；她和他的一部分永远地遗失在了那里，遗失在了那个无法企及的角落。他的脑中一片空白，任由身躯驱使他穿过影影绰绰的人群，已分辨不出哪个是她，哪个是熟悉的陌生人。就连残存的记忆，也被那一部分所吸引着，渐渐从他的意识里剥离。他说不上来自己究竟后不后悔，也许是不吧；他攥着唯一的烛火，走遍了无数的银幕，上穷碧落下黄泉。现在烛火也最后熄灭了。或许也是新的开始呢，他想。他拖着疲惫的身躯登上了来时的列车；随着车向前，一寸一寸的大地像是耗尽了最后的力量，轰然坍落，正如他刚刚所见的，沼底尽头的宫殿。一点一点的萤火在空中翻飞，散化为繁星点点，连同他的碎片，连同他和她的一切，连同那最后一丝烙印。他最后一次忆起她的身影，茕茕然在那里，迎上他的目光，嫣然一笑，胜过一切盛放的花。窗外像是有什么在呼啸着：他试图回想起，却早已飘散如烟。他不清楚何时何地，抑或是每时每地也未可知。阳光贪婪地闯了进来，不放过每一处罅隙，洒在她莹莹的脸上。她抿起唇。他倏地站起，眼中却已被水雾弥漫。 远处，站台已隐约可见。他探出车窗，像是要看些什么，却终于没有看清。他揉了揉眼，却想起无泪可流。 他沿着来时的路走去。路旁的烧烤摊上，他看见了新见、五反田、三谷，和其他几个人聚在一起，畅谈着过去，也畅谈着未来。 他们看见他的到来像是很惊讶。新见从隔壁桌搬了把凳子。他们团团围着坐了。 “你一个人回来的？高桥呢？”新见开口问道。 “高桥是谁？”他问。 “没事了，”新见道。“记错人了。” “……哦。”他没再说话，抓起烤翅啃了起来。其他人也恢复了先前的样子，觥筹交错，起坐喧哗。 “还是……要回去吗？”五反田问道。 “是啊。” “……和以前不太一样了。”三谷道。 “哦。” 沉默。 “……这是在威胁我吗？”他擦了擦额头，问道。新见点了点头，出人意料地。 “你非要说……算是吧。不过我们不拦着你。”新见又拿了串烤鱿鱼，“还是那句话，我们是真心在劝你。” “心领了，”他略一拱手。 “又是有非去不可的理由呵……”新见向后仰去。工藤擤了擤鼻子。 他们对视了一会。 “一直向那边走……走到头右拐。就在那里。”半晌，新见像是放弃了努力。“注意安全。路上不再像以前那样了。” “好。” 夜很快就深了。他们相对无言。 他站起身。 “希望这不是最后一次见面吧。”上原举起酒杯，微笑致意。他也笑着回礼。 “那么……再会。”他背上书包。 “再会，”他们齐声道。 他匆匆地走了。他知道有人在向着他拼命地挥手，求他千万别去回头。这都不要紧了。 他走着他的路。 路旁的景致从原野过到了黑白。他不知所措地望着前方，像是看到了那隙天边的裂痕，一针刺下便能渗出殷红的血。 他循环着刚才的会晤，其中一定有他遗漏了的东西。一张张面孔纤毫毕现，如在目前，像老式的放映机吱吱作响。他们倒是相信着未来，可最终却不是失去了自己的名字，就是去往了另一个世界。 他惊醒过来，已经站在路的终点了。前面是一堵砖墙，并不够高，却足以屏蔽他的目光。他在路口踌躇了许久，近乎能猜出墙后的场景了。那里只有最纯粹的白天与黑暗，只有最清白的绝望与梦想，只有最纷乱的花雨与黄沙。一定是的，毋庸置疑。 可他收回了心思，径直向右走去。另一个方向上，几个外国人举着摄像机，叽里咕噜地说着什么。章老师不断点头回应着，又重新扛起了金箍棒，周而复始。汗水浸湿了他的猴毛假发。 到那边先去找鲲吧，他想。他一定会带我去找他们的。还有C和Betsy……他们究竟走到了哪里？他们的时间又在何处停止？他们能不能触及心底的奢望？他们…… 我放下笔起身。远处，天塔像是响应着节约的号召，灭尽了全部的光亮，徒留名姓载孤舟；可年年相望的月亮却好像觉悟不高的样子，仍旧卖力地将别人施予的光又施予给每一个角落，照出了掩映的层云。广寒悠悠，遗世独立，羽化而登仙。 我坐回书桌，对着摊了整整一桌的草稿，却迟迟无法下笔。我想到笔下的一个个人物，他们在既定的旅途上孤独地跋涉着，却一直希冀着另外的一半，愿前路交织在一起。他们有的孑然一身，却并不孤独；可更多的纵是莺莺燕燕，孤独却已渗入骨髓。不过至少他们都以相同的方式来到了终点吧，无论孤独与否。他们本都有无限的可能。 我在纸张间左右横跳，眼前似乎看到了那位主人公，孤独地走在沼底的路上。其实……他已经消失在了他毁掉的那个地方吧。他终是要和五反田他们一起，就像1944年东京的住民，分不清哪一个会最终降临。想到这，我不禁笑了起来，眼里噙满了泪花。 高桥几个留在了沼底的尽头；章老师留在了中美合拍的现场；C和Betsy留在了一个又一个的迷宫：人人都有光辉的未来吧，又或许人人都没有了未来。白骨如山忘姓氏，无非公子与红妆。 我合上手稿，想起还有两个月就要退役了。我关灯躺在床上，沉沉睡去，梦中看见了初生的朝阳，携着金色的流光，照亮了无边的黑暗。 （完） 2020.11.8 2021.6.29 2021.9.8 2021.9.20 2022.7.14","link":"/ning-mei/"},{"title":"匹配：模板","text":"UOJ78 二分图最大匹配（DFS - KM） 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 550;int match[N], g[N][N], vis[N], link[N];int n, m, e, tag, ans = 0;bool dfs(int u) { for(int v=1; v&lt;=m; ++v) { if(!g[u][v] or vis[v] == tag) continue; vis[v] = tag; if(!match[v] or dfs(match[v])) { match[v] = u; return true; } } return false;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e); for(int i=1, u, v; i&lt;=e; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u][v] = true; } for(int i=1; i&lt;=n; ++i) { tag = i; if(dfs(i)) ++ans; } printf(&quot;%d\\n&quot;, ans); for(int i=1; i&lt;=m; ++i) link[match[i]] = i; for(int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, link[i]); return 0;} UOJ79 一般图最大匹配（带花树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 550;int fa[N], match[N], pre[N], vis[N];int tag = 0, n, m, ans = 0;int flag[N];bool g[N][N];queue&lt;int&gt; q;void clear(queue&lt;int&gt; &amp;q) { queue&lt;int&gt; empty; swap(q, empty);}int belong(int u) { return fa[u] == u ? u : fa[u] = belong(fa[u]);}void path(int u) { while(u) { int v = match[pre[u]]; match[u] = pre[u]; match[pre[u]] = u; u = v; }}int lca(int u, int v) { ++tag; u = belong(u); v = belong(v); while(vis[u] != tag) { vis[u] = tag; u = belong(pre[match[u]]); if(v) swap(u, v); } return u;}void connect(int u, int v, int root) { while(belong(u) != root) { pre[u] = v; v = match[u]; if(flag[v] == 2) { q.push(v); flag[v] = 1; } if(belong(u) == u) fa[u] = root; if(belong(v) == v) fa[v] = root; u = pre[v]; }}bool bfs(int u) { memset(flag, 0, sizeof flag); memset(pre, 0, sizeof pre); for(int i=1; i&lt;=n; ++i) fa[i] = i; clear(q); q.push(u); flag[u] = 1; while(!q.empty()) { u = q.front(); q.pop(); for(int v=1; v&lt;=n; ++v) { if(!g[u][v]) continue; if(flag[v] == 0) { pre[v] = u; if(match[v] == 0) { path(v); return true; } q.push(match[v]); flag[v] = 2; flag[match[v]] = 1; } else { if(flag[v] == 2) continue; if(belong(u) == belong(v)) continue; int root = lca(u, v); connect(u, v, root); connect(v, u, root); } } } return false;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1, u, v; i&lt;=m; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u][v] = g[v][u] = true; } for(int i=1; i&lt;=n; ++i) if(match[i] == 0 and bfs(i)) ++ans; printf(&quot;%d\\n&quot;, ans); for(int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, match[i]); return 0;} UOJ80 二分图最大权匹配（BFS - KM） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 440;const LL INF = 0x3f3f3f3f3f3f3f3f;bool vis[N];int pre[N], link[N], res[N];int n, m, e;LL g[N][N], lx[N], ly[N], d[N], ans = 0;void bfs(int k) { int x, y = 0; LL min1 = INF, delta; memset(vis, false, sizeof vis); memset(pre, 0, sizeof pre); memset(d, 0x3f, sizeof d); link[y] = k; do { x = link[y], delta = INF, vis[y] = true; for(int i=1; i&lt;=m; ++i) { if(!vis[i]) { if(d[i] &gt; lx[x] + ly[i] - g[x][i]) { d[i] = lx[x] + ly[i] - g[x][i]; pre[i] = y; } if(delta &gt; d[i]) delta = d[i], min1 = i; } } for(int i=0; i&lt;=m; ++i) if(vis[i]) lx[link[i]] -= delta, ly[i] += delta; else d[i] -= delta; y = min1; } while(link[y]); while(y) link[y] = link[pre[y]], y = pre[y];}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e); m = max(n, m); for(int i=1; i&lt;=e; ++i) { int u, v; LL w; scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w); g[u][v] = w; lx[u] = max(lx[u], w); } for(int i=1; i&lt;=n; ++i) bfs(i); for(int i=1; i&lt;=m; ++i) { if(!g[link[i]][i]) continue; ans += g[link[i]][i]; res[link[i]] = i; } printf(&quot;%lld\\n&quot;, ans); for(int i=1; i&lt;=n; ++i) printf(&quot;%d &quot;, res[i]); return 0;}","link":"/match-template/"},{"title":"单调队列","text":"单调队列是一种特殊维护的队列。一般地，当一新值准备入队时，须先从后向前，将对后来答案没有了影响的点弹出，再从前向后，将所有超出了统计范围的点弹出。对于大多数问题，求解过程中会锁定很多答案区间，在线求最值。 P3088 拥挤的奶牛 题面 有 $N$ 头奶牛沿着一维的栅栏吃草，第 $i$ 头奶牛在目标点 $x_i$，它的身高是 $h_i$ 。当一头奶牛左边 $D$ 距离内而且右边 $D$ 距离内有身高至少是它的两倍的奶牛，它就会觉得拥挤。 请计算觉得拥挤的奶牛的数量。 解 当一奶牛将要入队时： 从后往前，将身高小于该奶牛的弹出（--tail），因为将要进队的奶牛更加靠后，影响范围一定更大，对答案的贡献也一定更大。 从前往后，将与该奶牛距离已超过 $D$ 的奶牛弹出（++head） 将该奶牛入队。 与队头奶牛比较身高，若符合则打上标记，若左右两次统计均符合，则计入答案。 每次统计的是该奶牛左侧的合法性，从后到前再做一遍就可以了。 按照以上规则就可以统计答案了。显然该队列一定为单调递降队列。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N = 55000;struct node { int x, h;} a[N];int n, d, queue[N];bool l[N], r[N];bool cmp(node a, node b) { return a.x &lt; b.x;}int main() { freopen(&quot;p3088.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;d); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].h); sort(a+1, a+n+1, cmp); int head = 0, tail = 1; queue[head] = 1; for(int i=2; i&lt;=n; ++i) { while(head &lt; tail and a[queue[tail-1]].h &lt;= a[i].h) --tail; queue[tail++] = i; while(head &lt; tail and a[i].x - a[queue[head]].x &gt; d) ++head; if(a[queue[head]].h &gt;= (a[i].h &lt;&lt; 1)) l[i] = true; } head = 0, tail = 1; queue[head] = n; for(int i=n-1; i&gt;=1; --i) { while(head &lt; tail and a[queue[tail-1]].h &lt;= a[i].h) --tail; queue[tail++] = i; while(head &lt; tail and a[queue[head]].x - a[i].x &gt; d) ++head; if(a[queue[head]].h &gt;= (a[i].h &lt;&lt; 1)) r[i] = true; } int ans = 0; for(int i=1; i&lt;=n; ++i) if(l[i] and r[i]) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;} P3522 Temperature 题面 有 $n$ 个段，第 $i$ 个为 $[l_i, r_i]$，现要在几个连续的段中，每段中各取一个值，构成一序列，要求该序列不能下降，求序列的最大长度。 解 以段的左端点维护单调序列。 当一新段将要入队时： 从后向前，将所有左点比新段的左点小的段弹出。 从前向后，将所有右点比新段的左点小的段弹出。 统计答案：用当前位置减去队头的上一段的位置 $\\because$ 队头的上一段已被弹出 $\\therefore$ 从队头的上一段的下一段起（可能已被弹出）至当前位置均属于合法序列 代码 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;const int N = 1100000;int max(int a, int b) { return a &gt; b ? a : b; }int n, l[N], r[N], queue[N], ans = -1;int main() { freopen(&quot;p3522.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, l+i, r+i); int head = 0, tail = 1; queue[head] = 0; for(int i=1; i&lt;=n; ++i) { while(head &lt; tail and l[i] &gt;= l[queue[tail-1]]) --tail; queue[tail++] = i; while(head &lt; tail and l[queue[head]] &gt; r[i]) ++head; ans = max(ans, i - queue[head-1]); } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/monotonous-queue/"},{"title":"图论：LCA","text":"LCA: Lowest common ancestor 最近公共祖先 倍增求 LCA 预处理向上跳 $2^k$ 步的结果数组 f[k][x]。 求的时候先把两个点跳到一个深度。这里有一个特判，如果重合直接返回这个点。 然后log值从大往小枚举，两个点一起不断向上跳，直至父亲相同，直接返回父节点。 可以 $O(n)$ 预处理log值，把单次查询复杂度降到 $O(常数)$。 复杂度：预处理 $O(n \\log n)$，查询 $O(1)$ 欧拉序求LCA 欧拉序：dfs时的访问完整路径，回溯时也要把这个点算上。 易知欧拉序的长度是 $2n-1$，从边的角度考虑，每条边都是来回访问了两次，加上根节点的初始访问，$2(n-1)+1=2n-1$。 这里就是一个小性质，记 p[i] 为 $i$ 节点在欧拉序中第一次出现的位置，则对任意的 $u,v$，在 ol[p[u]..p[v]] 段内，使 p[ol[i]] 最小的 ol[i] 即为 lca(u,v)。 多次询问可用ST表预处理出最小值。 复杂度：预处理 $O(n \\log n)$，查询 $O(1)$ Tarjan求LCA 树剖求LCA","link":"/graph-lca/"},{"title":"初级动态规划：LIS、LCS、背包","text":"LIS &amp; LCS P1020 导弹拦截 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n = 0;int a[N], b[N], s[N], ls[N];void add(int x, int v) { for(; x&lt;=n; x+=x&amp;(-x)) s[x] = max(s[x], v); }int query(int x) { int ans = 0; for(; x&gt;0; x-=x&amp;(-x)) ans = max(ans, s[x]); return ans;}int main() { //freopen(&quot;p1020_1.in&quot;, &quot;r&quot;, stdin); for(; scanf(&quot;%d&quot;, a+n+1) != EOF; ++n, b[n] = a[n]); sort(b+1, b+n+1); int t = unique(b+1, b+n+1) - (b+1); for(int i=1; i&lt;=n; ++i) a[i] = lower_bound(b+1, b+t+1, a[i]) - b; int ans = 0; for(int i=n; i&gt;0; --i) { int q = query(a[i]) + 1; add(a[i], q); ans = max(ans, q); } printf(&quot;%d\\n&quot;, ans); ans = 0; memset(s, 0, sizeof s); for(int i=1; i&lt;=n; ++i) { int q = query(a[i]-1) + 1; add(a[i], q); ans = max(ans, q); } printf(&quot;%d\\n&quot;, ans); return 0;} P1439 【模板】最长公共子序列 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, b[N], p1[N], p2[N], s[N];int lowbit(int x) { return x&amp;(-x);}void add(int x, int v) { for(; x &lt;= n; x += lowbit(x)) s[x] = max(s[x], v);}int query(int x) { int ans = 0; for(; x &gt; 0; x -= lowbit(x)) ans = max(ans, s[x]); return ans;}int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, p1+i); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, p2+i); for(int i=1; i&lt;=n; ++i) b[p1[i]] = i; for(int i=1; i&lt;=n; ++i) p2[i] = b[p2[i]]; int ans = 0; for(int i=1; i&lt;=n; ++i) { int q = query(p2[i]-1) + 1; add(p2[i], q); ans = max(ans, q); } printf(&quot;%d&quot;, ans); return 0;} 0-1 背包 $$ F(i,j)= \\begin{cases} F(i-1,j)&amp; j \\leq w_i\\\\ \\max{F(i-1,j),F(i-1,j-w_i)+v_i}&amp; j &gt; w_i \\end{cases} $$ 注意二维转换成一维的时候，$j$ 要从后向前枚举，因为每次的新结果都是根据上一个结果来求得的，从后向前可避免重复取同一物品。 P2196 挖地雷 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 30;typedef pair &lt;int, vector&lt;int&gt; &gt; piv;vector&lt;int&gt; g[N]; int s1[N], n, w[N], in[N];vector&lt;int&gt; ss[N];piv ans;void outp(vector&lt;int&gt; &amp;ans) { for(vector&lt;int&gt;::iterator it = ans.begin(); it != ans.end(); ++it) printf(&quot;%d &quot;, *it); printf(&quot;\\n&quot;);}piv dfs(int x, vector&lt;int&gt; s) { if(s1[x]) { return (piv){s1[x], ss[x]}; } if(g[x].size() == 0) { s1[x] = w[x]; ss[x].clear(); ss[x].push_back(x); return (piv){s1[x], ss[x]}; } s1[x] = w[x]; ss[x].push_back(x); vector&lt;int&gt; st = ss[x]; for(vector&lt;int&gt;::iterator it = g[x].begin(); it != g[x].end(); ++it) { piv p = dfs(*it, s); if(p.first + w[x] &gt; s1[x]) { s1[x] = p.first + w[x]; ss[x] = st; ss[x].insert(ss[x].end(), p.second.begin(), p.second.end()); } } return (piv){s1[x], ss[x]};}int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, w+i); for(int i=1, a; i&lt;=n; ++i) { for(int j=i+1; j&lt;=n; ++j) { scanf(&quot;%d&quot;, &amp;a); if(a) g[i].push_back(j), ++in[j]; } } for(int i=1; i&lt;=n; ++i) { if(!in[i]) { piv p = dfs(i, ss[i]); if(p.first &gt; ans.first) { ans.first = p.first; ans.second.clear(); ans.second.insert(ans.second.end(), p.second.begin(), p.second.end()); } } } outp(ans.second); printf(&quot;%d&quot;, ans.first); return 0;} P1455 搭配购买 套一个并查集。 Code：（2019.12.01） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int N = 11000; struct node { int c, d;} val[N], tmp[N];int n, m, w, fa[N], list[N], dp[N], t, ans = 0;bool flag[N];int root(int x) { return fa[x] == x ? x : fa[x] = root(fa[x]);}void operator +=(node &amp;A, node B) { A.c += B.c, A.d += B.d;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;w); for(int i=1; i&lt;=n; ++i) fa[i] = i; for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, &amp;val[i].c, &amp;val[i].d); for(int i=1; i&lt;=m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); int u1 = root(u), v1 = root(v); fa[u1] = v1; } for(int i=1; i&lt;=n; ++i) root(i); for(int i=1; i&lt;=n; ++i) tmp[fa[i]] += val[i]; memcpy(list+1, fa+1, n*4); std::sort(list+1, list+n+1); t = std::unique(list+1, list+n+1) - (list+1); for(int i=1; i&lt;=t; ++i) for(int j=w; j&gt;=tmp[list[i]].c; --j) dp[j] = std::max(dp[j], dp[j - tmp[list[i]].c] + tmp[list[i]].d); printf(&quot;%d\\n&quot;, dp[w]); return 0;} P1164 小A点菜 这怎么会是橙题啊 注意DP的初值 dp[0] = 1，因为需特别考虑过程中「从0开始买菜」的情况。 循环中的i 表示已经考虑到了前i道菜。如果能买的起，就直接把 dp[j-a[i]] 转移过来，否则不变。 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int dp[11000], n, m, a[110];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); dp[0] = 1; for(int i=1; i&lt;=n; ++i) { for(int j=m; j&gt;=a[i]; --j) { dp[j] += dp[j-a[i]]; } } printf(&quot;%d\\n&quot;, dp[m]); return 0;} 完全背包 与上面的01背包问题差别不大，只是多了一个条件：每个物品可以取无数次。 方法很简单，只要 $j$ 从前向后枚举即可。这样做其实是变相利用了它的后效性，使同一个物品可以被多次取到。 P1616 疯狂的采药 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int t1, m, dp[int(1e7+10)], t[int(1e4+10)], v[int(1e4+10)];int main() { scanf(&quot;%d%d&quot;, &amp;t1, &amp;m); for(int i=1; i&lt;=m; ++i) scanf(&quot;%d%d&quot;, t+i, v+i); for(int i=1; i&lt;=t1; ++i) { dp[i] = dp[i-1]; for(int j=1; j&lt;=m; ++j) if(i-t[j]&gt;=0) dp[i] = max(dp[i], dp[i-t[j]] + v[j]); } printf(&quot;%d\\n&quot;, dp[t1]); return 0;} 多重背包 一种方法是转化成 01 背包处理。 首先找到最大的 $k$ 使得 $t=\\sum_{i=0}^{k}2^i(t &lt; c_i)$，也就是找到最大的小于 $c_i$ 的二的各个次幂和。这样之后，我们就可以通过不重复且有选择地使用 $2^0$到 $2^k$ 来表示出 1到 t所有的数。但是剩下的呢？我们将剩下的 $c_i-t$ 单独分成一个物品，因为 1到 t都可以表示，那么有了这个 $c_i-t$ 物品，就可以表示出所有数了。 例如，把 $21$ 分为 $[1,2,4,8,6]$，这样就可以从中不重复地选择来表示出 1到 $c_i$ 的所有数了。 P1776 宝物筛选 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110, M = 44000;int n, W, v[N], w[N], m[N], dp[M];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;W); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d%d&quot;, v+i, w+i, m+i); for(int i=1; i&lt;=n; ++i) { //1, 2, 4, 8, ... 2^k, m_i-2^(k+1)+1 int sum = 0; for(int j=0; sum + (1&lt;&lt;j) &lt;= m[i]; ++j) { sum += (1&lt;&lt;j); for(int l=W; l&gt;=w[i]*(1&lt;&lt;j); --l) dp[l] = max(dp[l], dp[l-w[i]*(1&lt;&lt;j)] + v[i]*(1&lt;&lt;j)); } for(int l=W; l&gt;=w[i]*(m[i] - sum); --l) dp[l] = max(dp[l], dp[l-w[i]*(m[i] - sum)] + v[i]*(m[i] - sum)); } printf(&quot;%d\\n&quot;, dp[W]); return 0;} P5020 [NOIP2018提高组]货币系统 首先要想到这题可能并不是数论。 80分做法: 考虑爆搜，枚举现有系统中的每个数能否被其他已选择的数表示出来。这里可以贪心的想，如果一个数能被另外几个数表示，那么删除它一定是更优解。 dfs() 部分可以换成背包，不过复杂度级别是差不多的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;bool us[N];int T, n, maxv, t, a[N];bool dfs(int s, int x, int p) { if(x &gt; n or s &gt; a[p]) return false; if(x == p or us[x]) return dfs(s, x+1, p); for(int i=0; i&lt;=maxv/a[x]; ++i) { if(s+a[x]*i == a[p]) return true; bool f = dfs(s+a[x]*i, x+1, p); if(f) return true; } return false;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;n); maxv = 0; for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, a+i); maxv = max(maxv, a[i]); } sort(a+1, a+n+1); t = unique(a+1, a+n+1) - (a+1); int ans = t; memset(us, false, sizeof us); for(int i=1; i&lt;=t; ++i) { if(dfs(0,1,i)) { us[i] = true; --ans; } } printf(&quot;%d\\n&quot;, ans); } return 0;} 满分做法： 其实在80分基础上再多想一步就够了：我们不用枚举每个数的表示法来判断可不可以删。直接对所有数dp，如果一个数能用一种以上的方式表示出来，那么就删掉它。显然删掉这个数是无后效的。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;bool us[N]; int dp[26000];int T, n, maxv, t, a[N];int main() { scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;n); maxv = 0; for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, a+i); maxv = max(maxv, a[i]); } sort(a+1, a+n+1); t = unique(a+1, a+n+1) - (a+1); int ans = t; memset(dp, 0, sizeof dp); dp[0] = 1; for(int i=1; i&lt;=t; ++i) { for(int j=a[i]; j&lt;=maxv; ++j) { dp[j] += dp[j-a[i]]; } } for(int i=1; i&lt;=t; ++i) { if(dp[a[i]] &gt; 1) --ans; } printf(&quot;%d\\n&quot;, ans); } return 0;} 分组背包 在枚举主件的前提下枚举附件。 P1064 金明的预算方案 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 33000, M = 65;typedef vector&lt;int&gt;::iterator IT;int n, m, p[M], v[M], dp[N];int g[M][2];vector&lt;int&gt; s;int main() { //freopen(&quot;P1064_5.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=m; ++i) { int q; scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;p[i], &amp;q); if(q == 0) s.push_back(i); else if(g[q][0]) g[q][1] = i; else g[q][0] = i; } for(IT it = s.begin(); it != s.end(); it++) { int i = *it; int a = g[i][0], b = g[i][1]; for(int j=n; j&gt;=v[i]; --j) { dp[j] = max(dp[j], dp[j-v[i]] + v[i]*p[i]); if(j-v[i]-v[a] &gt;= 0) dp[j] = max(dp[j], dp[j-v[i]-v[a]] + v[i]*p[i] + v[a]*p[a]); if(j-v[i]-v[b] &gt;= 0) dp[j] = max(dp[j], dp[j-v[i]-v[b]] + v[i]*p[i] + v[b]*p[b]); if(j-v[i]-v[a]-v[b] &gt;= 0) dp[j] = max(dp[j], dp[j-v[i]-v[a]-v[b]] + v[i]*p[i] + v[a]*p[a] + v[b]*p[b]); } } printf(&quot;%d\\n&quot;, dp[n]); return 0;} 装满背包 一种特殊情况。 背包不一定装满时，$dp[j]$ 记录的是前i件物品放入空间为j的背包中的最大价值，要在一开始，让 $dp[]$ 中的每个值为 0。 背包装满时，注意要把 f[j]（表示刚好装满的最大价值）初始化为 f[0] = 0; f[1..n] = -INF;，这样就能使那些能够恰好装满背包的物品的值为正数，而那些不能恰好装满背包的物品的值就为负数，就容易区分了。 dp[n(背包最多承重)] == inf 的话，说明装不满；如果装满的话，dp[n] 即为最高价值。","link":"/dp-linear/"},{"title":"图论","text":"图论算法一般都是揉在一起的，很难单独把算法拆开讲，所以直接上题目吧。分类是大致分的，其实有很多是交叉的。 二叉树 二叉树的遍历有三种，分别为前序遍历，中序遍历和后序遍历，并且给定其中的两种遍历能够求出另一种遍历 (必须已知中序遍历)。 前序遍历：按 根 左 右 的顺序进行； 中序遍历：按 左 根 右 的顺序进行； 后序遍历：按 左 右 根 的顺序进行。 最短路 &amp; 生成树 算法复杂度 多源最短路Floyd：严格 $O(n^3)$ 单源最短路Dijkstra： 朴素：严格 $O(n^2)$ 优先队列优化：均摊 $O((e+n) \\log n)$ Bellman-Ford： 最多松弛 $n-1$ 次 严格 $O(ne)$ SPFA： 即队列优化Bellman-Ford 最坏 $O(ne)$，最好 $O(1)$ 板子 咕咕咕 如何卡掉 SPFA 见 https://www.zhihu.com/question/292283275/answer/484871888 P1967 货车运输 最大生成树，然后跑LCA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e4+10, M = 1e5+10, INF = 0x3f3f3f3f;struct node { int id, u, v, w, next;} e[M], e1[M];int h[N], tot = 0, tot1 = 0, n, m;int fa[N][15], dep[N], dis[N][15];int vis[N];bool edg[M];void add(int u, int v, int w) { e1[tot1] = e[tot] = {tot, u, v, w, h[u]}; h[u] = tot++; tot1++; e[tot] = {tot, v, u, w, h[v]}; h[v] = tot++;}int bc[N];int root(int u) { return bc[u] == u ? u : bc[u] = root(bc[u]);}bool cmp(node a, node b) { return a.w &gt; b.w;}void dfs(int u, int f, int vi) { vis[u] = vi; for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(v == f) continue; if(edg[i] or edg[i^1]) { dep[v] = dep[u] + 1; fa[v][0] = u; dis[v][0] = e[i].w; dfs(v, u, vi); } }}void lca(int x, int y) { if(dep[x] &lt; dep[y]) swap(x, y); int ans = INF; int t = dep[x] - dep[y]; for(int i=14; i&gt;=0; --i) { if(t &gt;= (1&lt;&lt;i)) { ans = min(ans, dis[x][i]); x = fa[x][i]; t -= (1&lt;&lt;i); } } if(x == y) { printf(&quot;%d\\n&quot;, ans); return; } for(int i=14; i&gt;=0; --i) { if(fa[x][i] != fa[y][i]) { ans = min(ans, dis[x][i]); ans = min(ans, dis[y][i]); x = fa[x][i]; y = fa[y][i]; } } //printf(&quot;lca:%d\\n&quot;, fa[x][0]); printf(&quot;%d\\n&quot;, min(ans, min(dis[x][0], dis[y][0])));}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); for(int i=1; i&lt;=m; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); } sort(e1, e1+tot1, cmp); for(int i=1; i&lt;=n; ++i) bc[i] = i; for(int i=0; i&lt;tot1; ++i) { int u = e1[i].u, v = e1[i].v; int u1 = root(u), v1 = root(v); if(u1 != v1) { edg[e1[i].id] = true; bc[v1] = u1; } } for(int i=1; i&lt;=n; ++i) { if(bc[i] == i) { dfs(i, 0, i); for(int j=0; j&lt;=14; ++j) { fa[i][j] = i; dis[i][j] = INF; } } } for(int i=1; i&lt;=14; ++i) { for(int j=1; j&lt;=n; ++j) { fa[j][i] = fa[fa[j][i-1]][i-1]; dis[j][i] = min(dis[j][i-1], dis[fa[j][i-1]][i-1]); } } int query; scanf(&quot;%d&quot;, &amp;query); for(int i=1; i&lt;=query; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if(vis[x] != vis[y]) { printf(&quot;-1\\n&quot;); continue; } lca(x, y); } return 0;} P1073 最优贸易 分层图，最短路 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int N = 330000, M = 1650000;struct node { int u, v, w, next; node() {} node(int _u, int _v, int _w, int _next): u(_u), v(_v), w(_w), next(_next) {}} e[M &lt;&lt; 1];int h[N], tot = 0;inline void add(int u, int v, int w = 0) { e[tot] = node(u, v, w, h[u]); h[u] = tot++;}int n, m, w[N]; bool vis[N]; int dis[N];int main() { #ifdef DEBUG freopen(&quot;p1073_1.in&quot;, &quot;r&quot;, stdin); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;w[i]); } memset(h, -1, sizeof h); for(int i=1, x, y, z; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); if(z == 1) add(x, y), add(x+n, y+n), add(x+2*n, y+2*n); else { add(x, y), add(x+n, y+n), add(x+2*n, y+2*n); swap(x, y); add(x, y), add(x+n, y+n), add(x+2*n, y+2*n); } } for(int i=1; i&lt;=n; ++i) { add(i+n, i, w[i]); add(i, i+2*n, -w[i]); } queue&lt;int&gt; q; memset(dis, 0x3f, sizeof dis); q.push(n+1); vis[n+1] = true; dis[n+1] = 0; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = false; for(int i=h[u]; i!=-1; i=e[i].next) { int v=e[i].v; if(dis[v] &gt; dis[u] + e[i].w) { dis[v] = dis[u] + e[i].w; if(!vis[v]) { q.push(v); vis[v] = true; } } } } printf(&quot;%d\\n&quot;, -dis[n*3]); return 0;} P1119 灾后重建 很重要的题目，考察了 Floyd的本质。 Floyd 用 $dis[k][i][j]$ 表示 i 和 j 之间可以通过编号为 $1\\dots k$ 的节点的最短路径，显然，$dis[0][i][j]$ 就是原始邻接矩阵数据。 状态转移方程： $$ dis[k][i][j]=min(dis[k-1][i][j],dis[k-1][i][k]+dis[k-1][k][j]) $$ Floyd 的本质其实就是DP，只不过我们通常做题时利用了数据只会使用一次性的原理，把 dis 变成滚动数组，减少了一维，节省空间。 更多请见 https://www.cnblogs.com/fangwencai/p/4784914.html。 1234567//提前将邻接矩阵存在 dis 数组里，其他不连通的地方初始化成无穷大for(int k=1; k&lt;=n; ++k) //枚举中间点 for(int i=1; i&lt;=n; ++i) //枚举起点 if(i != k) //节省时间，如果一样就不往下走 for(int j=1; j&lt;=n; ++j) //枚举终点 if(i != j and j != k) //继续判断，如果有一样的就不往下走 dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); //状态转移方程，也就是所谓的松弛操作 只要我们能够利用 DP 特性，就能解决许多问题 再回来看这道题，文中说每个村子是不同时间修好的，而每个节点都按顺序给出，这不就是恰好相当于 Floyd的中间点吗？我们可以把 k轮 DP分开做，每输入一个点，就用这个点当中转站把最短距离更新一遍，也就是跑一遍 DP。 Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 220;int t[N];struct query { int id, x, y, t;} a[55000];int res[55000], n, m, dp[N][N];int main() { //freopen(&quot;P1119_2.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, t+i); } t[n+1] = 0x3f3f3f3f; memset(dp, 0x3f, sizeof dp); for(int i=1; i&lt;=n; ++i) dp[i][i] = 0; for(int i=1; i&lt;=m; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); ++u, ++v; dp[u][v] = dp[v][u] = w; } int q; scanf(&quot;%d&quot;, &amp;q); for(int i=1; i&lt;=q; ++i) { scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].t); a[i].id = i; ++a[i].x, ++a[i].y; } int cnt = 1; for(; a[cnt].t &lt; t[1]; ++cnt) { res[a[cnt].id] = -1; } for(int T=1; T&lt;=n; ++T) { for(int i=1; i&lt;=n; ++i) { for(int j=1; j&lt;=n; ++j) { dp[i][j] = min(dp[i][j], dp[i][T] + dp[T][j]); } } while(1) { if(cnt &gt; q) break; if(a[cnt].t &gt;= t[T] and a[cnt].t &lt; t[T+1]); else break; if(a[cnt].x &gt; T or a[cnt].y &gt; T or dp[a[cnt].x][a[cnt].y] == 0x3f3f3f3f) { res[a[cnt].id] = -1; } else { res[a[cnt].id] = dp[a[cnt].x][a[cnt].y]; } ++cnt; } } for(int i=1; i&lt;=q; ++i) printf(&quot;%d\\n&quot;, res[i]); return 0;} 判负环 转自 @SingerCoder，%lgh 注意一定要判入队次数而不是松弛次数。 hack原理很简单：如果存在重边导致了多次松弛，那么对松弛次数的判断就会产生影响。解决方式就是判入队次数，虽然略慢，但是更稳。 Update[2020.7.26]：在写差分约束的时候想用spfa判无解，然后经过一系列的思考就有了下面这组新的hack数据： 1234567891011input:14 61 2 -31 3 -21 4 -12 3 -62 4 -53 4 -4output:NO 注意这组hack只对用链式前向星（而非vector）存边且判的是松弛次数（而非入队次数）的有效，而且该数据无重边无自环，比discuss里面的那个数据更有说服力。 首先hack原理就是对n号节点进行n-1轮松弛，每轮都有 $x( x \\in [1,n-1])$ 次松弛，这样就能产生 $n^2$ 级别的松弛次数。 但是判入队次数就hack不掉了，每轮的第一次松弛会让n节点入队，但n节点只有在下一轮才会出队；因此本轮的其余所有松弛全部无法导致入队。 P3385 [模板]负环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 2e3 + 10, M = 6e3 + 10;struct node { int u, v, w, next;} e[M];int h[N], tot = 0;int T, n, m;inline void add(int u, int v, int w) { e[++tot] = {u, v, w, h[u]}; h[u] = tot;} int dis[N], vis[N];bool inq[N];inline void spfa() { queue&lt;int&gt; q; memset(dis, 0x3f, sizeof dis); memset(vis, 0, sizeof vis); memset(inq, false, sizeof inq); dis[1] = 0; q.push(1); inq[1] = true; ++vis[1]; while(!q.empty()) { int u = q.front(); q.pop(); inq[u] = false;//printf(&quot;%d\\n&quot;, u); for(int i = h[u]; i ; i = e[i].next) { int v = e[i].v; if(dis[v] &gt; dis[u] + e[i].w) { dis[v] = dis[u] + e[i].w; if(!inq[v]) { inq[v] = true; ++vis[v]; if(vis[v] &gt; n-1) { printf(&quot;YES\\n&quot;); return; } q.push(v); } } } } printf(&quot;NO\\n&quot;);}int main() { //freopen(&quot;P3385_2.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, 0, sizeof h); tot = 0; for(int i=1; i&lt;=m; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); if(w &gt;= 0) { add(u, v, w); add(v, u, w); } else add(u, v, w); //printf(&quot;%d &quot;, i); } spfa(); } return 0;} 基环树 n 个点 n 条边 只有一个环 枚举断边 P5022 [NOIp2018TG]旅行","link":"/graph-theory/"},{"title":"受戒","text":"汪曾祺 明海出家已经四年了。 他是十三岁来的。 这个地方的地名有点怪，叫庵赵庄。赵，是因为庄上大都姓赵。叫做庄，可是人家住得很分散，这里两三家，那里两三家。一出门，远远可以看到，走起来得走一会，因为没有大路，都是弯弯曲曲的田埂。庵，是因为有一个庵。庵叫苦提庵，可是大家叫讹了，叫成荸荠庵。连庵里的和尚也这样叫。“宝刹何处？”——“荸荠庵。”庵本来是住尼姑的。“和尚庙”、“尼姑庵”嘛。可是荸荠庵住的是和尚。也许因为荸荠庵不大，大者为庙，小者为庵。 明海在家叫小明子。他是从小就确定要出家的。他的家乡不叫“出家”，叫“当和尚”。他的家乡出和尚。就像有的地方出劁猪的，有的地方出织席子的，有的地方出箍桶的，有的地方出弹棉花的，有的地方出画匠，有的地方出婊子，他的家乡出和尚。人家弟兄多，就派一个出去当和尚。当和尚也要通过关系，也有帮。这地方的和尚有的走得很远。有到杭州灵隐寺的、上海静安寺的、镇江金山寺的、扬州天宁寺的。一般的就在本县的寺庙。明海家田少，老大、老二、老三，就足够种的了。他是老四。他七岁那年，他当和尚的舅舅回家，他爹、他娘就和舅舅商议，决定叫他当和尚。他当时在旁边，觉得这实在是在情在理，没有理由反对。当和尚有很多好处。一是可以吃现成饭。哪个庙里都是管饭的。二是可以攒钱。只要学会了放瑜伽焰口，拜梁皇忏，可以按例分到辛苦钱。积攒起来，将来还俗娶亲也可以；不想还俗，买几亩田也可以。当和尚也不容易，一要面如朗月，二要声如钟磬，三要聪明记性好。他舅舅给他相了相面，叫他前走几步，后走几步，又叫他喊了一声赶牛打场的号子：“格当XX——”，说是“明子准能当个好和尚，我包了！”要当和尚，得下点本，——念几年书。哪有不认字的和尚呢！于是明子就开蒙入学，读了《三字经》、《百家姓》、《四言杂字》、《幼学琼林》、《上论、下论》、《上孟、下孟》，每天还写一张仿。村里都夸他字写得好，很黑。 舅舅按照约定的日期又回了家，带了一件他自己穿的和尚领的短衫，叫明子娘改小一点，给明子穿上。明子穿了这件和尚短衫，下身还是在家穿的紫花裤子，赤脚穿了一双新布鞋，跟他爹、他娘磕了一个头，就随舅舅走了。 他上学时起了个学名，叫明海。舅舅说，不用改了。于是“明海”就从学名变成了法名。 过了一个湖。好大一个湖！穿过一个县城。县城真热闹：官盐店，税务局，肉铺里挂着成边的猪，一个驴子在磨芝麻，满街都是小磨香油的香味，布店，卖茉莉粉、梳头油的什么斋，卖绒花的，卖丝线的，打把式卖膏药的，吹糖人的，耍蛇的，……他什么都想看看。舅舅一劲地推他：“快走！快走！” 到了一个河边，有一只船在等着他们。船上有一个五十来岁的瘦长瘦长的大伯，船头蹲着一个跟明子差不多大的女孩子，在剥一个莲蓬吃。明子和舅舅坐到舱里，船就开了。明子听见有人跟他说话，是那个女孩子。 “是你要到荸荠庵当和尚吗？” 明子点点头。 “当和尚要烧戒疤呕！你不怕？” 明子不知道怎么回答，就含含糊糊地摇了摇头。 “你叫什么？” “明海。” “在家的时候？” “叫明子。” “明子！我叫小英子！我们是邻居。我家挨着荸荠庵。——给你！” 小英子把吃剩的半个莲蓬扔给明海，小明子就剥开莲蓬壳，一颗一颗吃起来。 大伯一桨一桨地划着，只听见船桨拨水的声音：“哗——许！哗——许！” …… 荸荠庵的地势很好，在一片高地上。这一带就数这片地势高，当初建庵的人很会选地方。门前是一条河。门外是一片很大的打谷场。三面都是高大的柳树。山门里是一个穿堂。迎门供着弥勒佛。不知是哪一位名士撰写了一副对联：大肚能容容天下难容之事开颜一笑笑世间可笑之人弥勒佛背后，是韦驮。过穿堂，是一个不小的天井，种着两棵白果树。天井两边各有三间厢房。走过天井，便是大殿，供着三世佛。佛像连龛才四尺来高。大殿东边是方丈，西边是库房。大殿东侧，有一个小小的六角门，白门绿字，刻着一副对联：一花一世界 三藐三菩提 进门有一个狭长的天井，几块假山石，几盆花，有三间小房。 小和尚的日子清闲得很。一早起来，开山门，扫地。庵里的地铺的都是箩底方砖，好扫得很，给弥勒佛、韦驮烧一炷香，正殿的三世佛面前也烧一炷香、磕三个头、念三声“南无阿弥陀佛”，敲三声磬。这庵里的和尚不兴做什么早课、晚课，明子这三声磬就全都代替了。然后，挑水，喂猪。然后，等当家和尚，即明子的舅舅起来，教他念经。 教念经也跟教书一样，师父面前一本经，徒弟面前一本经，师父唱一句，徒弟跟着唱一句。是唱哎。舅舅一边唱，一边还用手在桌上拍板。一板一眼，拍得很响，就跟教唱戏一样。是跟教唱戏一样，完全一样哎。连用的名词都一样。舅舅说，念经：一要板眼准，二要合工尺。说：当一个好和尚，得有条好嗓子。说：民国二十年闹大水，运河倒了堤，最后在清水潭合龙，因为大水淹死的人很多，放了一台大焰口，十三大师——十三个正座和尚，各大庙的方丈都来了，下面的和尚上百。谁当这个首座？推来推去，还是石桥——善因寺的方丈！他往上一坐，就跟地藏王菩萨一样，这就不用说了；那一声“开香赞”，围看的上千人立时鸦雀无声。说：嗓子要练，夏练三伏，冬练三九，要练丹田气！说：要吃得苦中苦，方为人上人！说：和尚里也有状元、榜眼、探花！要用心，不要贪玩！舅舅这一番大法要说得明海和尚实在是五体投地，于是就一板一眼地跟着舅舅唱起来： “炉香乍爇——” “炉香乍爇——” “法界蒙薰——” “法界蒙薰——” “诸佛现金身……” “诸佛现金身……” …… 等明海学完了早经，——他晚上临睡前还要学一段，叫做晚经，——荸荠庵的师父们就都陆续起床了。 这庵里人口简单，一共六个人。连明海在内，五个和尚。有一个老和尚，六十几了，是舅舅的师叔，法名普照，但是知道的人很少，因为很少人叫他法名，都称之为老和尚或老师父，明海叫他师爷爷。这是个很枯寂的人，一天关在房里，就是那“一花一世界”里。也看不见他念佛，只是那么一声不响地坐着。他是吃斋的，过年时除外。 下面就是师兄弟三个，仁字排行：仁山、仁海、仁渡。庵里庵外，有的称他们为大师父、二师父；有的称之为山师父、海师父。只有仁渡，没有叫他“渡师父”的，因为听起来不像话，大都直呼之为仁渡。他也只配如此，因为他还年轻，才二十多岁。仁山，即明子的舅舅，是当家的。不叫“方丈”，也不叫“住持”，却叫“当家的”，是很有道理的，因为他确确实实干的是当家的职务。他屋里摆的是一张帐桌，桌子上放的是帐簿和算盘。帐簿共有三本。一本是经帐，一本是租帐，一本是债帐。和尚要做法事，做法事要收钱，——要不，当和尚干什么？常做的法事是放焰口。正规的焰口是十个人。一个正座，一个敲鼓的，两边一边四个。人少了，八个，一边三个，也凑合了。荸荠庵只有四个和尚，要放整焰口就得和别的庙里合伙。这样的时候也有过，通常只是放半台焰口。一个正座，一个敲鼓，另外一边一个。一来找别的庙里合伙费事；二来这一带放得起整焰口的人家也不多。有的时候，谁家死了人，就只请两个，甚至一个和尚咕噜咕噜念一通经，敲打几声法器就算完事。很多人家的经钱不是当时就给，往往要等秋后才还。这就得记帐。另外，和尚放焰口的辛苦钱不是一样的。就像唱戏一样，有份子。正座第一份。因为他要领唱，而且还要独唱。当中有一大段“叹骷髅”，别的和尚都放下法器休息，只有首座一个人有板有眼地曼声吟唱。第二份是敲鼓的。你以为这容易呀？哼，单是一开头的“发擂”，手上没功夫就敲不出迟疾顿挫！其余的，就一样了。这也得记上：某月某日、谁家焰口半台，谁正座，谁敲鼓……省得到年底结帐时赌咒骂娘。……这庵里有几十亩庙产，租给人种，到时候要收租。庵里还放债。租、债一向倒很少亏欠，因为租佃借钱的人怕菩萨不高兴。这三本帐就够仁山忙的了。另外香烛、灯火、油盐“福食”，这也得随时记记帐呀。除了帐簿之外，山师父的方丈的墙上还挂着一块水牌，上漆四个红字：“勤笔免思”。 仁山所说当一个好和尚的三个条件，他自己其实一条也不具备。他的相貌只要用两个字就说清楚了：黄，胖。声音也不像钟磬，倒像母猪。聪明么？难说，打牌老输。他在庵里从不穿袈裟，连海青直裰也免了。经常是披着件短僧衣，袒露着一个黄色的肚子。下面是光脚趿拉着一对僧鞋，——新鞋他也是趿拉着。他一天就是这样不衫不履地这里走走，那里走走，发出母猪一样的声音：“呣——呣——”。 二师父仁海。他是有老婆的。他老婆每年夏秋之间来住几个月，因为庵里凉快。庵里有六个人，其中之一，就是这位和尚的家眷。仁山、仁渡叫她嫂子，明海叫她师娘。这两口子都很爱干净，整天的洗涮。傍晚的时候，坐在天井里乘凉。白天，闷在屋里不出来。 三师父是个很聪明精干的人。有时一笔帐大师兄扒了半天算盘也算不清，他眼珠子转两转，早算得一清二楚。他打牌赢的时候多，二三十张牌落地，上下家手里有些什么牌，他就差不多都知道了。他打牌时，总有人爱在他后面看歪头胡。谁家约他打牌，就说“想送两个钱给你。”他不但经忏俱通（小庙的和尚能够拜忏的不多），而且身怀绝技，会“飞铙”。七月间有些地方做盂兰会，在旷地上放大焰口，几十个和尚，穿绣花袈裟，飞铙。飞铙就是把十多斤重的大铙钹飞起来。到了一定的时候，全部法器皆停，只几十副大铙紧张急促地敲起来。忽然起手，大铙向半空中飞去，一面飞，一面旋转。然后，又落下来，接住。接住不是平平常常地接住，有各种架势，“犀牛望月”、“苏秦背剑”……这哪是念经，这是耍杂技。也许是地藏王菩萨爱看这个，但真正因此快乐起来的是人，尤其是妇女和孩子。这是年轻漂亮的和尚出风头的机会。一场大焰口过后，也像一个好戏班子过后一样，会有一个两个大姑娘、小媳妇失踪，——跟和尚跑了。他还会放“花焰口”。有的人家，亲戚中多风流子弟，在不是很哀伤的佛事——如做冥寿时，就会提出放花焰口。所谓“花焰口”就是在正焰口之后，叫和尚唱小调，拉丝弦，吹管笛，敲鼓板，而且可以点唱。仁渡一个人可以唱一夜不重头。仁渡前几年一直在外面，近二年才常住在庵里。据说他有相好的，而且不止一个。他平常可是很规矩，看到姑娘媳妇总是老老实实的，连一句玩笑话都不说，一句小调山歌都不唱。有一回，在打谷场上乘凉的时候，一伙人把他围起来，非叫他唱两个不可。他却情不过，说：“好，唱一个。不唱家乡的。家乡的你们都熟，唱个安徽的。” 姐和小郎打大麦，一转子讲得听不得。 听不得就听不得， 打完了大麦打小麦。 唱完了，大家还嫌不够，他就又唱了一个：姐儿生得漂漂的，两个奶子翘翘的。 有心上去摸一把， 心里有点跳跳的。 …… 这个庵里无所谓清规，连这两个字也没人提起。 仁山吃水烟，连出门做法事也带着他的水烟袋。 他们经常打牌。这是个打牌的好地方。把大殿上吃饭的方桌往门口一搭，斜放着，就是牌桌。桌子一放好，仁山就从他的方丈里把筹码拿出来，哗啦一声倒在桌上。斗纸牌的时候多，搓麻将的时候少。牌客除了师兄弟三人，常来的是一个收鸭毛的，一个打兔子兼偷鸡的，都是正经人。收鸭毛的担一副竹筐，串乡串镇，拉长了沙哑的声音喊叫：“鸭毛卖钱——！” 偷鸡的有一件家什——铜蜻蜓。看准了一只老母鸡，把铜蜻蜓一丢，鸡婆子上去就是一口。这一啄，铜蜻蜓的硬簧绷开，鸡嘴撑住了，叫不出来了。正在这鸡十分纳闷的时候，上去一把薅住。 明子曾经跟这位正经人要过铜蜻蜓看看。他拿到小英子家门前试了一试，果然！小英的娘知道了，骂明子：“要死了！儿子！你怎么到我家来玩铜蜻蜓了！”小英子跑过来： “给我！给我！” 她也试了试，真灵，一个黑母鸡一下子就把嘴撑住，傻了眼了！ 下雨阴天，这二位就光临荸荠庵，消磨一天。 有时没有外客，就把老师叔也拉出来，打牌的结局，大都是当家和尚气得鼓鼓的：“×妈妈的！又输了！下回不来了！” 他们吃肉不瞒人。年下也杀猪。杀猪就在大殿上。一切都和在家人一样，开水、木桶、尖刀。捆猪的时候，猪也是没命地叫。跟在家人不同的，是多一道仪式，要给即将升天的猪念一道“往生咒”，并且总是老师叔念，神情很庄重：“……一切胎生、卵生、息生，来从虚空来，还归虚空去往生再世，皆当欢喜。南无阿弥陀佛！” 三师父仁渡一刀子下去，鲜红的猪血就带着很多沫子喷出来。 …… 明子老往小英子家里跑。 小英子的家像一个小岛，三面都是河，西面有一条小路通到荸荠庵。独门独户，岛上只有这一家。岛上有六棵大桑树，夏天都结大桑椹，三棵结白的，三棵结紫的；一个菜园子，瓜豆蔬菜，四时不缺。院墙下半截是砖砌的，上半截是泥夯的。大门是桐油油过的，贴着一副万年红的春联：向阳门第春常在 积善人家庆有余 门里是一个很宽的院子。院子里一边是牛屋、碓棚；一边是猪圈、鸡窠，还有个关鸭子的栅栏。露天地放着一具石磨。正北面是住房，也是砖基土筑，上面盖的一半是瓦，一半是草。房子翻修了才三年，木料还露着白茬。正中是堂屋，家神菩萨的画像上贴的金还没有发黑。两边是卧房。扇窗上各嵌了一块一尺见方的玻璃，明亮亮的，——这在乡下是不多见的。房檐下一边种着一棵石榴树，一边种着一棵栀子花，都齐房檐高了。夏天开了花，一红一白，好看得很。栀子花香得冲鼻子。顺风的时候，在荸荠庵都闻得见。 这家人口不多，他家当然是姓赵。一共四口人：赵大伯、赵大妈，两个女儿，大英子、小英子。老两口没得儿子。因为这些年人不得病，牛不生灾，也没有大旱大水闹蝗虫，日子过得很兴旺。他们家自己有田，本来够吃的了，又租种了庵上的十亩田。自己的田里，一亩种了荸荠，——这一半是小英子的主意，她爱吃荸荠，一亩种了茨菇。家里喂了一大群鸡鸭，单是鸡蛋鸭毛就够一年的油盐了。赵大伯是个能干人。他是一个“全把式”，不但田里场上样样精通，还会罩鱼、洗磨、凿砻、修水车、修船、砌墙、烧砖、箍桶、劈篾、绞麻绳。他不咳嗽，不腰疼，结结实实，像一棵榆树。人很和气，一天不声不响。赵大伯是一棵摇钱树，赵大娘就是个聚宝盆。大娘精神得出奇。五十岁了，两个眼睛还是清亮亮的。不论什么时候，头都是梳得滑溜溜的，身上衣服都是格挣挣的。像老头子一样，她一天不闲着。煮猪食，喂猪，腌咸菜，——她腌的咸萝卜干非常好吃，舂粉子，磨小豆腐，编蓑衣，织芦篚。她还会剪花样子。这里嫁闺女，陪嫁妆，磁坛子、锡罐子，都要用梅红纸剪出吉祥花样，贴在上面，讨个吉利，也才好看：“丹凤朝阳”呀、“白头到老”呀、“子孙万代”呀、“福寿绵长”呀。二三十里的人家都来请她：“大娘，好日子是十六，你哪天去呀？”——“十五，我一大清早就来！”“一定呀！”——“一定！一定！” 两个女儿，长得跟她娘像一个模子里托出来的。眼睛长得尤其像，白眼珠鸭蛋青，黑眼珠棋子黑，定神时如清水，闪动时像星星。浑身上下，头是头，脚是脚。头发滑溜溜的，衣服格挣挣的。——这里的风俗，十五六岁的姑娘就都梳上头了。这两上丫头，这一头的好头发！通红的发根，雪白的簪子！娘女三个去赶集，一集的人都朝她们望。 姐妹俩长得很像，性格不同。大姑娘很文静，话很少，像父亲。小英子比她娘还会说，一天咭咭呱呱地不停。大姐说：“你一天到晚咭咭呱呱——” “像个喜鹊！” “你自己说的！——吵得人心乱！” “心乱？” “心乱！” “你心乱怪我呀！” 二姑娘话里有话。大英子已经有了人家。小人她偷偷地看过，人很敦厚，也不难看，家道也殷实，她满意。已经下过小定，日子还没有定下来。她这二年，很少出房门，整天赶她的嫁妆。大裁大剪，她都会。挑花绣花，不如娘。她可又嫌娘出的样子太老了。她到城里看过新娘子，说人家现在绣的都是活花活草。这可把娘难住了。最后是喜鹊忽然一拍屁股：“我给你保举一个人！” 这人是谁？是明子。明子念“上孟下孟”的时候，不知怎么得了半套《芥子园》，他喜欢得很。到了荸荠庵，他还常翻出来看，有时还把旧帐簿子翻过来，照着描。小英子说：“他会画！画得跟活的一样！” 小英子把明海请到家里来，给他磨墨铺纸，小和尚画了几张，大英子喜欢得了不得：“就是这样！就是这样！这就可以乱孱！”——所谓“乱孱”是绣花的一种针法：绣了第一层，第二层的针脚插进第一层的针缝，这样颜色就可由深到淡，不露痕迹，不像娘那一代绣的花是平针，深浅之间，界限分明，一道一道的。小英子就像个书童，又像个参谋：“画一朵石榴花！” “画一朵栀子花！” 她把花掐来，明海就照着画。 到后来，凤仙花、石竹子、水蓼、淡竹叶，天竺果子、腊梅花，他都能画。 大娘看着也喜欢，搂住明海的和尚头：“你真聪明！你给我当一个干儿子吧！” 小英子捺住他的肩膀，说：“快叫！快叫！” 小明子跪在地下磕了一个头，从此就叫小英子的娘做干娘。 大英子绣的三双鞋，三十里方圆都传遍了。很多姑娘都走路坐船来看。看完了，就说：“啧啧啧，真好看！这哪是绣的，这是一朵鲜花！”她们就拿了纸来央大娘求了小和尚来画。有求画帐檐的，有求画门帘飘带的，有求画鞋头花的。每回明子来画花，小英子就给他做点好吃的，煮两个鸡蛋，蒸一碗芋头，煎几个藕团子。 因为照顾姐姐赶嫁妆，田里的零碎生活小英子就全包了。她的帮手，是明子。 这地方的忙活是栽秧、车高田水，薅头遍草、再就是割稻子、打场子。这几荐重活，自己一家是忙不过来的。这地方兴换工。排好了日期，几家顾一家，轮流转。不收工钱，但是吃好的。一天吃六顿，两头见肉，顿顿有酒。干活时，敲着锣鼓，唱着歌，热闹得很。其余的时候，各顾各，不显得紧张。 薅三遍草的时候，秧已经很高了，低下头看不见人。一听见非常脆亮的嗓子在一片浓绿里唱：栀子哎开花哎六瓣头哎……姐家哎门前哎一道桥哎……明海就知道小英子在哪里，三步两步就赶到，赶到就低头薅起草来，傍晚牵牛“打汪”，是明子的事。——水牛怕蚊子。这里的习惯，牛卸了轭，饮了水，就牵到一口和好泥水的“汪”里，由它自己打滚扑腾，弄得全身都是泥浆，这样蚊子就咬不通了。低田上水，只要一挂十四轧的水车，两个人车半天就够了。明子和小英子就伏在车杠上，不紧不慢地踩着车轴上的拐子，轻轻地唱着明海向三师父学来的各处山歌。打场的时候，明子能替赵大伯一会，让他回家吃饭。——赵家自己没有场，每年都在荸荠庵外面的场上打谷子。他一扬鞭子，喊起了打场号子： “格当XX——” 这打场号子有音无字，可是九转十三弯，比什么山歌号子都好听。赵大娘在家，听见明子的号子，就侧起耳朵：“这孩子这条嗓子！” 连大英子也停下针线：“真好听！” 小英子非常骄傲地说：“一十三省数第一！” 晚上，他们一起看场。——荸荠庵收来的租稻也晒在场上。他们并肩坐在一个石磙子上，听青蛙打鼓，听寒蛇唱歌，——这个地方以为蝼蛄叫是蚯蚓叫，而且叫蚯蚓叫“寒蛇”，听纺纱婆子不停地纺纱，“XX——”，看萤火虫飞来飞去，看天上的流星。 “呀！我忘了在裤带上打一个结！”小英子说。 这里的人相信，在流星掉下来的时候在裤带上打一个结，心里想什么好事，就能如愿。 …… “”荸荠，这是小英最爱干的生活。秋天过去了，地净场光，荸荠的叶子枯了，——荸荠的笔直的小葱一样的圆叶子里是一格一格的，用手一捋，哔哔地响，小英子最爱捋着玩，——荸荠藏在烂泥里。赤了脚，在凉浸浸滑滑溜的泥里踩着，——哎，一个硬疙瘩！伸手下去，一个红紫红紫的荸荠。她自己爱干这生活，还拉了明子一起去。她老是故意用自己的光脚去踩明子的脚。 她挎着一篮子荸荠回去了，在柔软的田埂上留了一串脚印。明海看着她的脚印，傻了。五个小小的趾头，脚掌平平的，脚跟细细的，脚弓部分缺了一块。明海身上有一种从来没有过的感觉，他觉得心里痒痒的。这一串美丽的脚印把小和尚的心搞乱了。 …… 明子常搭赵家的船进城，给庵里买香烛，买油盐。闲时是赵大伯划船；忙时是小英子去，划船的是明子。 从庵赵庄到县城，当中要经过一片很大的芦花荡子。芦苇长得密密的，当中一条水路，四边不见人。划到这里，明子总是无端端地觉得心里很紧张，他就使劲地划桨。 小英子喊起来： “明子！明子！你怎么啦？你发疯啦？为什么划得这么快？”…… 明海到善因寺去受戒。 “你真的要去烧戒疤呀？” “真的。” “好好的头皮上烧十二个洞，那不疼死啦？” “咬咬牙。舅舅说这是当和尚的一大关，总要过的。”“不受戒不行吗？” “不受戒的是野和尚。” “受了戒有啥好处？” “受了戒就可以到处云游，逢寺挂褡。” “什么叫‘挂褡’？” “就是在庙里住。有斋就吃。” “不把钱？” “不把钱。有法事，还得先尽外来的师父。” “怪不得都说‘远来的和尚会念经’。就凭头上这几个戒疤？” “还要有一份戒牒。” “闹半天，受戒就是领一张和尚的合格文凭呀！”“就是！” “我划船送你去。” “好。” 小英子早早就把船划到荸荠庵门前。不知是什么道理，她兴奋得很。她充满了好奇心，想去看看善因寺这座大庙，看看受戒是个啥样子。 善因寺是全县第一大庙，在东门外，面临一条水很深的护城河，三面都是大树，寺在树林子里，远处只能隐隐约约看到一点金碧辉煌的屋顶，不知道有多大。树上到处挂着“谨防恶犬”的牌子。这寺里的狗出名的厉害。平常不大有人进去。放戒期间，任人游看，恶狗都锁起来了。 好大一座庙！庙门的门坎比小英子的肐膝都高。迎门矗着两块大牌，一边一块，一块写着斗大两个大字：“放戒”，一块是：“禁止喧哗”。这庙里果然是气象庄严，到了这里谁也不敢大声咳嗽。明海自去报名办事，小英子就到处看看。好家伙，这哼哈二将、四大天王，有三丈多高，都是簇新的，才装修了不久。天井有二亩地大，铺着青石，种着苍松翠柏。“大雄宝殿”，这才真是个“大殿”！一进去，凉嗖嗖的。到处都是金光耀眼。释迦牟尼佛坐在一个莲花座上，单是莲座，就比小英子还高。抬起头来也看不全他的脸，只看到一个微微闭着的嘴唇和胖敦敦的下巴。两边的两根大红蜡烛，一搂多粗。佛像前的大供桌上供着鲜花、绒花、绢花，还有珊瑚树，玉如意、整根的大象牙。香炉里烧着檀香。小英子出了庙，闻着自己的衣服都是香的。挂了好些幡。这些幡不知是什么缎子的，那么厚重，绣的花真细。这么大一口磬，里头能装五担水！这么大一个木鱼，有一头牛大，漆得通红的。她又去转了转罗汉堂，爬到千佛楼上看了看。真有一千个小佛！她还跟着一些人去看了看藏经楼。藏经楼没有什么看头，都是经书！妈吔！逛了这么一圈，腿都酸了。小英子想起还要给家里打油，替姐姐配丝线，给娘买鞋面布，给自己买两个坠围裙飘带的银蝴蝶，给爹买旱烟，就出庙了。 等把事情办齐，晌午了。她又到庙里看了看，和尚正在吃粥。好大一个“膳堂”，坐得下八百个和尚。吃粥也有这样多讲究：正面法座上摆着两个锡胆瓶，里面插着红绒花，后面盘膝坐着一个穿了大红满金绣袈裟的和尚，手里拿了戒尺。这戒尺是要打人的。哪个和尚吃粥吃出了声音，他下来就是一戒尺。不过他并不真的打人，只是做个样子。真稀奇，那么多的和尚吃粥，竟然不出一点声音！他看见明子也坐在里面，想跟他打个招呼又不好打。想了想，管他禁止不禁止喧哗，就大声喊了一句：“我走啦！”她看见明子目不斜视地微微点了点头，就不管很多人都朝自己看，大摇大摆地走了。 第四天一大清早小英子就去看明子。她知道明子受戒是第三天半夜，——烧戒疤是不许人看的。她知道要请老剃头师傅剃头，要剃得横摸顺摸都摸不出头发茬子，要不然一烧，就会“走”了戒，烧成了一片。她知道是用枣泥子先点在头皮上，然后用香头子点着。她知道烧了戒疤就喝一碗蘑菇汤，让它“发”，还不能躺下，要不停地走动，叫做“散戒”。这些都是明子告诉她的。明子是听舅舅说的。 她一看，和尚真在那里“散戒”，在城墙根底下的荒地里。 一个一个，穿了新海青，光光的头皮上都有十二个黑点子。——这黑疤掉了，才会露出白白的、圆圆的“戒疤”。和尚都笑嘻嘻的，好像很高兴。她一眼就看见了明子。隔着一条护城河，就喊他： “明子！” “小英子！” “你受了戒啦？” “受了。” “疼吗？” “疼。” “现在还疼吗？” “现在疼过去了。” “你哪天回去？” “后天。” “上午？下午？” “下午。” “我来接你！” “好！” …… 小英子把明海接上船。 小英子这天穿了一件细白夏布上衣，下边是黑洋纱的裤子，赤脚穿了一双龙须草的细草鞋，头上一边插着一朵栀子花，一边插着一朵石榴花。她看见明子穿了新海青，里面露出短褂子的白领子，就说：“把你那外面的一件脱了，你不热呀！” 他们一人一把桨。小英子在中舱，明子扳艄，在船尾。 她一路问了明子很多话，好像一年没有看见了。 她问，烧戒疤的时候，有人哭吗？喊吗？ 明子说，没有人哭，只是不住地念拂。有个山东和尚骂人：“俺日你奶奶！俺不烧了！” 她问善因寺的方丈石桥是相貌和声音都很出众吗？“是的。” “说他的方丈比小姐的绣房还讲究？” “讲究。什么东西都是绣花的。” “他屋里很香？” “很香。他烧的是伽楠香，贵得很。” “听说他会做诗，会画画，会写字？” “会。庙里走廊两头的砖额上，都刻着他写的大字。”“他是有个小老婆吗？” “有一个。” “才十九岁？” “听说。” “好看吗？” “都说好看。” “你没看见？” “我怎么会看见？我关在庙里。” 明子告诉她，善因寺一个老和尚告诉他，寺里有意选他当沙弥尾，不过还没有定，要等主事的和尚商议。 “什么叫‘沙弥尾’？” “放一堂戒，要选出一个沙弥头，一个沙弥尾。沙弥头要老成，要会念很多经。沙弥尾要年轻，聪明，相貌好。”“当了沙弥尾跟别的和尚有什么不同？” “沙弥头，沙弥尾，将来都能当方丈。现在的方丈退居了，就当。石桥原来就是沙弥尾。” “你当沙弥尾吗？” “还不一定哪。” “你当方丈，管善因寺？管这么大一个庙？！” “还早呐！” 划了一气，小英子说：“你不要当方丈！” “好，不当。” “你也不要当沙弥尾！” “好，不当。” 又划了一气，看见那一片芦花荡子了。 小英子忽然把桨放下，走到船尾，趴在明子的耳朵旁边，小声地说： “我给你当老婆，你要不要？” 明子眼睛鼓得大大的。 “你说话呀！” 明子说：“嗯。” “什么叫‘嗯’呀！要不要，要不要？” 明子大声地说：“要！” “你喊什么！” 明子小小声说：“要——！” “快点划！” 英子跳到中舱，两只桨飞快地划起来，划进了芦花荡。芦花才吐新穗。紫灰色的芦穗，发着银光，软软的，滑溜溜的，像一串丝线。有的地方结了蒲棒，通红的，像一枝一枝小蜡烛。青浮萍，紫浮萍。长脚蚊子，水蜘蛛。野菱角开着四瓣的小白花。惊起一只青桩（一种水鸟），擦着芦穗，扑鲁鲁鲁飞远了。 …… 一九八〇年八月十二日，写四十三年前的一个梦","link":"/shou-jie/"},{"title":"图论：Tarjan","text":"前置概念 时间戳：搜索时第几个搜索到这个点。如搜索顺序是1-&gt;2-&gt;3-&gt;6，则6的时间戳为4 对于无向图 连通分量：对于图G来的一个子图中，任意两个点都可以彼此到达，这个子图就被称为图G的连通分量（一个点就是最小的连通分量） 最大连通分量：对于图G的一个子图，这个子图为图G的连通分量，且是图G所有连通分量中包含节点数最多的那个，即为G的最大联通分量 算法流程 推荐看看这篇 简单应用 缩点 有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。孤立的一个点也是一个强连通分量。 如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量（SCC, Strongly Connected Components）。把每个强联通分量看成一个集合，把每个集合看成一个点，那么所有SCC就形成了一个DAG（有向无环图），就是著名的缩点。 Problem 根据题目意思，我们只需要找出一条点权最大的路径就行了，不限制点的个数。那么考虑对于一个环上的点被选择了，一整条环是不是应该都被选择，这一定很优，能选干嘛不选。很关键的是题目还允许我们重复经过某条边或者某个点，我们就不需要考虑其他了。因此整个环实际上可以看成一个点（选了其中一个点就应该选其他的点） 在处理了环后，我们就重新建立一张图，以每个环为节点（孤立一个点也算也算环的，其实也就是强联通分量了）。在这张图中我们要dp，显然对于任意边&lt;u,v&gt;，dp[v] = max(dp[v], dp[u] + new_weight[v])。 dp的时候拓扑排一下序，这也是DAGdp的常见trick了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4+10, M = 1e5+10;struct node { int u, v, nxt;} e[M];int h[N], tot = 0;int dfn[N], low[N], tag = 0, top = 0, num = 0;int n, m, w[N], ww[N], f[N], id[N], s[N], in[N];void tarjan(int u) { dfn[u] = low[u] = ++tag; s[++top] = u; for(int i = h[u], v; i; i = e[i].nxt) { v = e[i].v; if(!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if(!id[v]) low[u] = min(low[u], dfn[v]); } if(dfn[u] == low[u]) { ++num; while(s[top] != u) { id[s[top]] = num; ww[num] += w[s[top]]; top--; } id[s[top]] = num; ww[num] += w[s[top]]; top--; } }int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, w+i); for(int i=1; i&lt;=m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); if(u == v) continue; e[++tot] = {u, v, h[u]}; h[u] = tot; } for(int i=1; i&lt;=n; ++i) { if(!dfn[i]) tarjan(i); } memset(h, 0, sizeof h); for(int i=0, t=0; i&lt;tot; ++i) { int u = id[e[i].u], v = id[e[i].v]; if(u == v); else { e[++t] = {u, v, h[u]}; h[u] = t; ++in[v]; } } queue&lt;int&gt; q; for(int i=1; i&lt;=num; ++i) { if(!in[i]) q.push(i); } int ans = 0; for(int i=1; i&lt;=num; ++i) f[i] = ww[i], ans = max(ans, f[i]); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = h[u]; i; i = e[i].nxt) { int v = e[i].v; f[v] = max(f[v], f[u]+ww[v]); ans = max(ans, f[v]); --in[v]; if(!in[v]) q.push(v); } } printf(&quot;%d\\n&quot;, ans); return 0;} 找割点 割点：去掉无向联通图的某个点后，此图不连通，该点为割点。 Problem 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;iostream&gt;using std::min;const int N = 22000, M = 110000;struct node { int u, v, next;} e[M &lt;&lt; 1];int h[N], tot;int dfn[N], low[N], tag;int res[N], ans, n, m, fa[N];void tarjan(int u, int fa) { dfn[u] = low[u] = ++tag; int sum = 0; for(int i = h[u], v; i; i = e[i].next) { v = e[i].v; if(v == fa) continue; if(dfn[v]) low[u] = min(low[u], dfn[v]); else { ++sum; tarjan(v, u); low[u] = min(low[u], low[v]); if(fa == -1) continue; if(low[v] &gt;= dfn[u]) res[u] = true; } } if(fa == -1 and sum &gt; 1) res[u] = true; }int main() { //freopen(&quot;p3388_4.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1, x, y; i&lt;=m; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); e[++tot] = (node) {x, y, h[x]}; h[x] = tot; e[++tot] = (node) {y, x, h[y]}; h[y] = tot; } for(int i=1; i&lt;=n; ++i) if(dfn[i] == 0) tarjan(i, -1); for(int i=1; i&lt;=n; ++i) if(res[i]) ++ans; printf(&quot;%d\\n&quot;, ans); for(int i=1; i&lt;=n; ++i) if(res[i]) printf(&quot;%d &quot;, i); return 0;}","link":"/graph-tarjan/"},{"title":"尺取法","text":"尺取法，又称滑动窗口或双指针，是一种在序列上寻找最优解的方法．对于序列的每个左端点 $l$，让右端点 $r$ 尽可能延伸至最远，得到一个答案区间，$r$ 已到达最远后将与 $l$ 有关的信息弹出，对于多个答案区间找出最优解．复杂度通常为线性． 不过一些时候这样不能保证求得的是最优解，这时就需要其他思路，或者使用莫队（根号算法）暴力求解． HDU5178 Pairs 题面 有 $n$ 个值 $x_1, x_2, \\dots,x_n$，求使得 $|x_b-x_a|\\leqslant k,a&lt;b$ 的数对 $(a,b)$ 的个数． 解 分析可知 $a&lt;b$ 这一条件只是确保无重复，次序其实对于最终答案没有影响． 考虑先对 $x$ 排序（因原题目有绝对值，无影响），for​ $l$ 尺取出最远的 $r$， 则 $(l,r]$ 间的每个数均与 $l$ 构成合法数对． 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;algorithm&gt;const int N = 110000;typedef long long LL;int T, n;LL k, x[N];int main() { freopen(&quot;hdu5178.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%lld&quot;, &amp;n, &amp;k); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, x+i); std::sort(x+1, x+n+1); LL ans = 0; for(int l=1, r=2; l&lt;=n; ++l) { for(; r &lt;= n and x[r] - x[l] &lt;= k; ++r); ans += r - l - 1; } printf(&quot;%lld\\n&quot;, ans); } return 0;} HDU6119 小小粉丝度度熊 类似 CF1041D Glider 题面 给出 $n$ 个已签到的天数区间，$m$ 张补签卡，求可获得的最大连续签到时长。 解 尺取模板。 天数区间可重叠，须进行合并。 需要注意的是，当已确定最长合法区间 $[l,r]$ 后（即下一个区间与 $r$ 的距离大于剩余的补签卡数量，连不上），应把剩余补签卡全部应用到 $r$ 之后的天数上得到更优解。 代码 边界条件较多。 $R$ 为已加入队列的最后一个区间，判断的是区间 $R+1$ 的合法性。 特判第一个区间，开始时 $sum$ 直接加上第一个已签到区间的长，使用 $0$ 张补签卡。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110000;struct node { int l, r;} a[N], b[N];bool flag[N];bool cmp(node a, node b) { return a.l &lt; b.l; }int n, m;int max(int a, int b) { return a &gt; b ? a : b; }int main() { freopen(&quot;hdu6119.in&quot;, &quot;r&quot;, stdin); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) { for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, &amp;b[i].l, &amp;b[i].r), flag[i] = false; sort(b+1, b+n+1, cmp); for(int i=2; i&lt;=n; ++i) { if(b[i-1].r &gt;= b[i].l) { b[i].l = b[i-1].l; b[i].r = max(b[i].r, b[i-1].r); flag[i-1] = true; } } int tot = 0; for(int i=1; i&lt;=n; ++i) { if(flag[i]) continue; a[++tot].l = b[i].l; a[tot].r = b[i].r; } int sum = a[1].r - a[1].l + 1, f = 0, ans = 0; for(int L = 1, R = 1; L &lt;= tot; ++L) { for(; R + 1 &lt;= tot and f + a[R+1].l - a[R].r - 1 &lt;= m; ++R) sum += a[R+1].r - a[R].r, f += a[R+1].l - a[R].r - 1; ans = max(ans, sum + m - f); sum -= a[L+1].l - a[L].l; f -= a[L+1].l - a[L].r - 1; } printf(&quot;%d\\n&quot;, ans); } return 0;} HDU1937 Finding Seats 题面 电影院有 $R$ 行 $C$ 列，用 '.' 表示空座，'X' 表示不可选。 要求选择至少 $K$ 个空座位 $(x_i, y_i)$，使得 $$ (\\max x_i -\\min x_i)\\cdot(\\max y_i -\\min y_i),1\\leqslant i \\leqslant K $$ 最小。 解 二维尺取。 枚举题目所求长方形的上下界，尺取求出左右最短距离。用二维前缀和简化空位查找。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 330;int row, c, k;char str[N];int s[N][N];int query(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];}int main() { freopen(&quot;hdu1937.in&quot;, &quot;r&quot;, stdin); while(true) { scanf(&quot;%d%d%d&quot;, &amp;row, &amp;c, &amp;k); if(row == 0 and c == 0 and k == 0) break; for(int i=1; i&lt;=row; ++i) { scanf(&quot;%s&quot;, str+1); int sum = 0; for(int j=1; j&lt;=c; ++j) { sum += (str[j] == '.' ? 1 : 0); s[i][j] = s[i-1][j] + sum; } } int ans = 0x7fffffff; for(int up = 1; up &lt;= row; ++up) { for(int down = up; down &lt;= row; ++down) { for(int l=1, r=1; l&lt;=c; ++l) { for(; r&lt;=c; ++r) { if(query(up, l, down, r) &gt;= k) { ans = min(ans, (down - up + 1) * (r - l + 1)); break; } } } } } printf(&quot;%d\\n&quot;, ans); } return 0;} HDU5358 First One 题面 有一数列 $a_1, a_2, \\dots, a_n$，求 $$ \\sum_{i=1}^{n} \\sum_{j=i}^{n} (i + j)(\\lfloor \\log_2 \\sum_{k=i}^{j} a_k \\rfloor + 1) $$ 的值。特别地，$\\log_20=0$。 解 观察上式，对于 $\\lfloor\\log\\rfloor$ 来说，它的一个值可对应很多个真数，考虑分块。 枚举 $\\lfloor \\log_2 \\sum_{k=i}^{j} a_k \\rfloor$ 的每一个值（1~34）。 令 $$ v =\\lfloor \\log_2 \\sum_{k=i}^{j} a_k \\rfloor $$ $$ sum = \\sum_{k=i}^{j}a_k $$ 则 $$ sum \\in [2^{v-1},2^v) $$ 用尺取求出部分和在此范围的区段 $[i,j]$，求出结果加入计数器。 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 110000;typedef long long LL;LL cl[40], a[N], s[N];int T, n;int main() { freopen(&quot;hdu5358.in&quot;, &quot;r&quot;, stdin); cl[0] = -1, cl[1] = 1; for(int i=2; i&lt;=34; ++i) cl[i] = ((cl[i-1] + 1) &lt;&lt; 1LL) - 1; scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, a+i); for(int i=1; i&lt;=n; ++i) s[i] = s[i-1] + a[i]; LL ans = 0; for(LL k=1; k&lt;=34; ++k) { LL l = 0, r = 0; for(LL i=1; i&lt;=n; ++i) { for(l = max(l, i); l &lt;= n and s[l] - s[i-1] &lt;= cl[k-1]; ++l); for(r = max(l, r); r &lt;= n and s[r] - s[i-1] &lt;= cl[k]; ++r); ans += k * (i * (r-l) + (l+r-1) * (r-l) / 2); } } printf(&quot;%lld\\n&quot;, ans); } return 0;} HDU6103 Kirinriki 题面 有两字符串 $A,B$（从 $1$ 编号），长度均为 $n$，定义 $$ dis(A,B) = \\sum_{i=1}^n|A_i-B_{n-i}| $$ 字符之差定义为其 ASCII 码的差。 对于一字符串 $S$，找出它的两个不重叠连续子串，他们的 $dis$ 不大于 $m$，求最长合法子串长度。 解 寻找单调性，易得 $$ \\forall S’ \\subseteq S,T’\\subseteq T:dis(S’,T’)\\leqslant dis(S,T) $$ 因此子串越长越好。 又$\\because$ $\\forall$ 两个合法子串，其必关于母串的某一位置（或某两位置之间）对称，考虑枚举这一中心点，分上面的两种情况。 注意到对于每个子串，其长度越大越好，同时又有约束上界，可对称尺取。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string.h&gt;int abs(int x) { return x &gt; 0 ? x : -x; }int max(int a, int b) { return a &gt; b ? a : b;}int T, n, m;char s[22000];int main() { freopen(&quot;hdu6103.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;m); scanf(&quot;%s&quot;, s+1); int n = strlen(s+1), ans = 0; for(int i=1; i&lt;=n; ++i) { int f = 0; for(int l1 = i-1, r1 = i-1, l2 = i+1, r2 = i+1; l1 &gt; 0 and l2 &lt;= n; --l1, ++l2) { for(; r1 &gt; 0 and r2 &lt;= n and f + abs(s[r1] - s[r2]) &lt;= m; --r1, ++r2) f += abs(s[r1] - s[r2]); ans = max(ans, r2 - l2); f -= abs(s[l1] - s[l2]); } } for(int i=1; i&lt;=n; ++i) { int f = 0; for(int l1 = i, r1 = i, l2 = i+1, r2 = i+1; l1 &gt; 0 and l2 &lt;= n; --l1, ++l2) { for(; r1 &gt; 0 and r2 &lt;= n and f + abs(s[r1] - s[r2]) &lt;= m; --r1, ++r2) f += abs(s[r1] - s[r2]); ans = max(ans, r2 - l2); f -= abs(s[l1] - s[l2]); } } printf(&quot;%d\\n&quot;, ans); } return 0;} POJ2739 Sum of Consecutive Prime Numbers 尺取水题。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;cmath&gt;using namespace std;bool prime(int x) { if(x &lt; 2) return false; int m = int(sqrt(x)); for(int i=2; i&lt;=m; ++i) if(x % i == 0) return false; return true;}int x, p[11000];int main() { int tot = 0; for(int i=1; i&lt;=10000; ++i) { if(prime(i)) p[++tot] = i; } while(true) { scanf(&quot;%d&quot;, &amp;x); if(x == 0) break; int f = 0, ans = 0; for(int l=1, r=1; l&lt;=tot; ++l) { for(; r &lt;= tot and f + p[r] &lt;= x; ++r) f += p[r]; if(f == x) ++ans; f -= p[l]; } printf(&quot;%d\\n&quot;, ans); } return 0;} CF1198A MP3 题面 给出 $n,I$。 $n$ - 数列 $a_1,a_2,…,a_n$ 选定一个区间 $[l,r]$，并进行操作，使 $$ v_i = \\begin{cases} l&amp;v_i&lt;l\\\\ v_i&amp;l\\leqslant v_i \\leqslant r\\\\ r&amp;v_i&gt;r \\end{cases} $$ 要求经过处理后，数列中不同的数的个数 $\\leqslant 2^{\\lfloor 8I/n\\rfloor}$，且使数列中被更改的位置的总数最小，求这个最小值。 解 原题面较长，需耐心看题。 可先将原数列排序并离散化，记下每种数的出现次数，用前缀和优化求和。因顺序已预先排好，直接尺取 $[l,r]$，使区间内的值最大化，用总数相减得出答案。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N = 440000; int a[N], b[N], cnt[N], s[N], n, I, t; int power(int x) { int ans = 1, base = 2; for(; x; x &gt;&gt;= 1) { if(x &amp; 1) ans *= base; if(ans &gt; t) return ans; base *= base; } return ans;} int main() { freopen(&quot;cf1198a.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;I); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, a+i), b[i] = a[i]; if(8*I &gt; n*((int)log2(n) + 1)) { printf(&quot;0\\n&quot;); return 0; } sort(b+1, b+n+1); t = unique(b+1, b+n+1) - (b+1); int K = power(8*I/n); for(int i=1; i&lt;=n; ++i) { int p = lower_bound(b+1, b+t+1, a[i]) - b; ++cnt[p]; } for(int i=1; i&lt;=t; ++i) s[i] = s[i-1] + cnt[i]; int ans = 0x7fffffff; for(int l=1, r; l&lt;=t; ++l) { r = min(l + K - 1, t); ans = min(ans, s[t] - (s[r] - s[l-1])); } printf(&quot;%d\\n&quot;, ans); return 0;} CF180E Cubes 题意简述 现有一数列 $a_1,a_2,…,a_n (1\\leqslant a_i \\leqslant m)$（更准确地翻译的话，现有一排小方块，第 $i$ 个方块的颜色为 $a_i$），求在最多删去 $k$ 个位置的数后，所能获得的最长连续子段的长度，要求该子段中所有数均相同． 解释 可以不删数． $1 \\leqslant n \\leqslant 2 \\times 10^5$，$1 \\leqslant m \\leqslant 10^5$，$0 \\leqslant k &lt;n$． 样例#1：删去 $5th$ 和 $6th$． 样例#2：删去 $4th$ 和 $7th$． 样例#3：不变． 解答 枚举每种颜色，这样问题就可被简化为对于每种颜色，求出其修改后的最长合法子段，可用尺取法求解。 尺取法与单调队列有关，应用范围比较小，要求原问题在满足条件的情况下，长度越长，答案越好。利用双指针 $l,r$ 及队列思想，对于同一个 $l$ 让 $r$ 尽可能延伸至最远，得到一个答案区间，$r$ 已到达最远后将与 $l$ 有关的信息弹出，对于多个答案区间找出最优解。 更详细的解释请看这里 代码 将原数列分块，对每种颜色建立链表，枚举时直接访问。 链表的每个节点存储该颜色块的左右端点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 220000, M = 110000;struct node { int l, r, next;} a[N];int tmp[M], n, m, k, h[M];int main() { freopen(&quot;cf180e.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); int f = 0, tot = 0, ans = 0; for(int i=1, c; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;c); if(f == c) a[tot].r = i; else { a[++tot] = (node) {i, i, c, 0}; if(h[x]) a[tmp[c]].next = tmp[c] = tot; else h[x] = tmp[x] = tot; f = c; } } for(int i=1; i&lt;=m; ++i) { if(h[i] == 0) continue; // 无该颜色 int L = h[i], R = h[i], f = 0, sum = a[h[i]].r - a[h[i]].l + 1; for(; L; L = a[L].next) { for(; a[R].next and f + a[a[R].next].l - a[R].r - 1 &lt;= k; R = a[R].next) f += a[a[R].next].l - a[R].r - 1, sum += a[a[R].next].r - a[a[R].next].l + 1; ans = max(ans, sum); // 统计 sum -= a[L].r - a[L].l + 1; // 弹出 f -= a[a[L].next].l - a[L].r - 1; } } printf(&quot;%d\\n&quot;, ans); return 0;} CF939E Maximize! 题面 对于一个只包含正整数的 multiset $S$，你需要支持以下 $2$ 种操作： $1$ 找出 $S$ 的一个子集 $s$，使 $max(s)-mean(s)$ 最大，并输出这个最大值。保留十位小数。 $2$ $x$ 加入一个新数 $x$ 到 $S$ 中，保证加入的数是递增的。 解 思维题。 $max$ 越大越好，$mean$ 越小越好。 结论一：子集 $s$ 中必包含 $\\max S$。 结论二：$\\forall x \\in S, x\\notin s,mean(s) &gt; x:mean(s) &lt; mean(s\\cup{x})$​ 。 证明略。 代码 略丑。 为防止 WA，特判了较小的情况，维护的也略微麻烦一点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;const int N = 550000;typedef double LF;int Q, s[N];int main() { freopen(&quot;cf939e.in&quot;, &quot;r&quot;, stdin); int tot = 0, f = 0; LF sum = 0, lastans = 0, lasttype = 0; scanf(&quot;%d&quot;, &amp;Q); while(Q--) { int type; scanf(&quot;%d&quot;, &amp;type); if(type == 1) { scanf(&quot;%d&quot;, &amp;s[++tot]); lasttype = type; } else { if(lasttype == 2) { printf(&quot;%.10lf\\n&quot;, lastans); continue; } if(tot == 1) { printf(&quot;%.10lf\\n&quot;, (LF)0); lastans = 0; lasttype = 2; continue; } if(tot == 2) { lastans = s[2] - (s[1] + s[2]) / 2.0; printf(&quot;%.10lf\\n&quot;, lastans); lasttype = 2; sum = s[1], f = 1; continue; } for(int i=f+1; i&lt;tot; ++i) { if((LF)(sum + s[tot]) / i &gt; (LF)s[i]) f = i, sum += s[i]; else break; } lastans = s[tot] - (sum + s[tot]) / (f+1); printf(&quot;%.10lf\\n&quot;, lastans); lasttype = type; } } return 0;}","link":"/ruler-method/"},{"title":"搜索与状压 DP","text":"DFS 搜索和DP不分家，几乎所有的DP都能用搜索解决（虽然复杂度可能较劣）。不过，如果实在想不出正解，DFS不失为骗分的好手段。 主要的搜索算法有： DFS/BFS爆搜 双向BFS 启发式搜索（又称A*） 迭代加深搜索 IDA*（迭代加深+启发式） 记忆化搜索 剪枝 重要程度：1,7,6 &gt; 4,3 &gt; 5,2。 P3956 [NOIP2017普及组]棋盘 搜索/DP的题一定要先看数据范围。这道题 $1 ≤ m ≤ 100, 1 ≤ n ≤ 1000$，朴素搜索显然不可行。 然后分析题目，到达一个点可能有多种途径，所以也不可以用vis数组优化。只剩记忆化搜索了。 简单证明一下正确性： 如果当前格子本来就有颜色，那么魔法一定可用 如果当前格子原本没有颜色，那么只要搜到这个格子，魔法其实只有一种情况就是不可用 记搜时注意剪枝条件一定要写满。比如 f &gt;= mem[x][y] 如果改成 f &gt; mem[x][y]，后果就会很严重。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int m, n, c[N][N], mem[N][N];int d[4][2] = {{0,1},{0,-1},{-1,0},{1,0}};int ans = 0x3f3f3f3f;void dfs(int x, int y, int f, int cc) { //f: 代价 //cc != -1 不能用魔法, 此处改成的颜色 //cc == -1 可以 if(f &gt;= mem[x][y] || f &gt;= mem[m][m]) return; mem[x][y] = f; if(x == m &amp;&amp; y == m) return; for(int i=0; i&lt;4; ++i) { int xx=x+d[i][0],yy=y+d[i][1]; if(xx&lt;1||xx&gt;m||yy&lt;1||yy&gt;m) continue; if(cc!=-1&amp;&amp;c[xx][yy]==cc||cc==-1&amp;&amp;c[xx][yy]==c[x][y]) { dfs(xx, yy, f, -1); } else if(cc!=-1&amp;&amp;c[xx][yy]!=cc&amp;&amp;c[xx][yy]!=-1||cc==-1&amp;&amp;c[xx][yy]!=c[x][y]&amp;&amp;c[xx][yy]!=-1) { dfs(xx, yy, f+1, -1); } else if(cc==-1&amp;&amp;c[xx][yy]==-1) { dfs(xx, yy, f+2, c[x][y]); } }}int main() { scanf(&quot;%d%d&quot;, &amp;m, &amp;n); memset(c, -1, sizeof c); memset(mem, 0x3f, sizeof mem); for(int i=1; i&lt;=n; ++i) { int x, y, cc; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;cc); c[x][y] = cc; } dfs(1, 1, 0, -1); printf(&quot;%d\\n&quot;, mem[m][m] == 0x3f3f3f3f ? -1 : mem[m][m]); return 0;} P3959 [NOIP2017 提高组]宝藏 可能你会想到生成树，所以这里给出一个反例： 这张图从1号点开始的Prim便是错的。 如果跑Prim，从1号点开始的话，我们会先访问2，（此时花费为1），然后我们会访问3，此时花费为3 * 2，然后由于只有4号点未访问，这时3号的访问顺序为3，访问4号的代价是3 * 100 = 300，显然这种做法不是最优的，正确的答案应该是211（从1号点开始的最小花费为211）。 虽然直接跑Prim是错的，但是Prim的思想仍然重要，这一思想也在最短路等很多算法中有应用：用更新过的点去更新其他点。 我们设计一个不基于点的dfs函数，参数只需传递代价，每次迭代，先枚举访问过的点，再枚举一个未访问且未开通路径的点，进行松弛，将代价持续传递下去。计算代价需要记录点的深度，也要通过父节点传递下去。 这样我们就有了一个大概的思路，照着模拟，可以拿到至少70分。 Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;const int INF = 0x7f7f7f7f;int min(int a, int b) { return a &lt; b ? a : b; }int map[20][20];int dep[20], best, n, m, num;bool vis[20];void dfs(int x) { if(x &gt;= best) return; //注意这里的剪枝！ if(num == 0) { best = x; return; } for(int i=1; i&lt;=n; ++i) { if(vis[i]) { for(int j=1; j&lt;=n; ++j) { if(!vis[j] and map[i][j] &lt; INF) { vis[j] = true; --num; dep[j] = dep[i] + 1; dfs(x + map[i][j] * dep[j]); vis[j] = false; ++num; } } } }}int main() { memset(map, 0x7f, sizeof map); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=m; ++i) { int x, y, v; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;v); map[x][y] = map[y][x] = min(map[x][y], v); } best = INF; num = n; for(int i=1; i&lt;=n; ++i) { vis[i] = true; --num; dep[i] = 0; dfs(0); vis[i] = false; ++num; } printf(&quot;%d\\n&quot;, best); return 0;} 按当年的测试数据，在这段代码的基础上再进行足够细致的剪枝，可以拿到100分的好成绩。 状压 DP 常用操作 设全集为 $x$ for(int y = x; y; y = (y-1) &amp; x)：枚举 x 的每个子集 x^y：x 集合中刨去 y x&amp;y == y：y 是 x 的子集 P3959 宝藏 对还是刚才那道题。 即便当时的测试数据水到乱搞都可以打满，但是搞懂正解仍然很有必要。 设计状态，令 $f_{j,i,S}$ 表示从起点到准备向外发边的点 $i$ 的距离为 $j$，准备要把集合 $S$ 中的点挖通。 转移时，枚举从节点 $i$ 打出的边 $(i,k)$，再枚举从 $k$ 要打通的子集 $S_2\\subset S$，那么 $$ f_{j, i, S} = \\min_{k \\in S_2 \\subset S} (d[i][k] * (j + 1) + f_{j + 1, k, S_2 - {k}} + f_{j, i, S - S_2}) $$ 转移顺序一定要想好。 最后取所有 $f_{0,i,U-{i}}$ 的最小值即可，其中 $U$ 是全集。 核心代码 12345678910111213141516171819202122232425262728293031323334//预处理集合中1的个数for (int i = 1; i &lt; mx; ++i) sz[i] = sz[i &amp; (i - 1)] + 1;//预处理 lowbitfor (int i = 0; i &lt; n; ++i) mn[1 &lt;&lt; i] = i;for (int i = 1; i &lt; mx; ++i) mn[i] = mn[i &amp; -i];for (int i = 0; i &lt; n; ++i) f[n - 1][i][0] = 0; //初值for (int j = n - 2; j &gt;= 0; --j) { //距离 for (int i = 0; i &lt; n; ++i) { //发边点 f[j][i][0] = 0; //初值 for (int S = 1; S &lt; (1 &lt;&lt; n); ++S) { if (((~S &gt;&gt; i) &amp; 1) //i不在集合S里 &amp;&amp; sz[S] &lt;= n - j - 1) //不会多挖 for (int S2 = S; S2; S2 = (S2 - 1) &amp; S) { //S的每个子集 int tmp = S2; for (int k = mn[tmp]; tmp; k = mn[tmp &amp;= ~(1 &lt;&lt; k)]) //S2里的每个点 if (mp[i][k] ^ INF) //存在待挖的边 f[j][i][S] = min(f[j][i][S], f[j + 1][k][S2 &amp; ~(1 &lt;&lt; k)] + f[j][i][S &amp; ~S2] + mp[i][k] * (j + 1)); } } }}int ans = INF;for (int i = 0; i &lt; n; ++i) ans = std::min(ans, f[0][i][(mx - 1) &amp; ~(1 &lt;&lt; i)]);","link":"/dp-graph/"},{"title":"复仇","text":"汪曾祺 复仇者不折镆干。虽有忮心，不怨飘瓦。 ——庄子 一支素烛，半罐野蜂蜜。他的眼睛现在看不见蜜。蜜在罐里，他坐在榻上。但他充满了蜜的感觉，浓，稠。他嗓子里并不泛出酸味。他的胃口很好。他一生没有呕吐过几回。一生，一生该是多久呀？我这是一生了么？没有关系，这是个很普通的口头语。谁都说：“我这一生……”。就像那和尚吧，——和尚一定是常常吃这种野蜂蜜。他的眼睛眯了眯，因为烛火跳，跳着一堆影子。他笑了一下：他心里对和尚有了一个称呼，“蜂蜜和尚”。这也难怪，因为蜂蜜、和尚，后面隐了“一生”两个字。明天辞行的时候，我当真叫他一声，他会怎么样呢？和尚倒有了一个称呼了。我呢？他会称呼我什么？该不是“宝剑客人”吧（他看到和尚一眼就看到他的剑）。这蜂蜜——他想起来的时候一路听见蜜蜂叫。是的，有蜜蜂。蜜蜂真不少（叫得一座山都浮动了起来）。现在，残余的声音还在他的耳朵里。从这里开始了我今天的晚上，而明天又从这里接连下去。人生真是说不清。他忽然觉得这是秋天，从蜜蜂的声音里。从声音里他感到一身轻爽。不错，普天下此刻写满了一个“秋”。他想象和尚去找蜂蜜。一大片山花。和尚站在一片花的前面，实在是好看极了，和尚摘花。大殿上的铜钵里有花，开得真好，冉冉的，像是从钵里升起一蓬雾。他喜欢这个和尚。 和尚出去了。单举着一只手，后退了几步，既不拘礼，又似有情。和尚你一定是自自然然地行了无数次这样的礼了。和尚放下蜡烛，说了几句话，不外是庙宇偏僻，没有什么可以招待；山高，风大气候凉，早早安息。和尚不说，他也听见。和尚说了，他可没有听。他尽着看这和尚。他起身为礼，和尚飘然而去。双袖飘飘，像一只大蝴蝶。 他在心里画不出和尚的样子。他想和尚如果不是把头剃光，他该有一头多好的白发。一头亮亮的白发在他的心里闪耀着。 白发的和尚呀。 他是想起了他的白了发的母亲。 山里的夜来得真快！日入群动息，真是静极了。他一路走来，就觉得一片安静。可是山里和路上迥然不同。他走进小山村，小蒙舍里有孩子读书声，马的铃铛，连枷敲在豆秸上。小路上的新牛粪发散着热气，白云从草垛边缓缓移过，一个梳辫子的小姑娘穿着一件银红色的衫子……可是原来描写着静的，现在全表示着动。他甚至想过自己作一个货郎来给这个山村添加一点声音的，这一会可不能在这万山之间拨浪浪摇他的小鼓。 货郎的拨浪鼓在小石桥前摇，那是他的家。他知道，他想的是他的母亲。而投在母亲的线条里着了色的忽然又是他的妹妹。他真愿意有这么一个妹妹，像他在这个山村里刚才见到的。穿着银红色的衫子，在门前井边打水。青石的井栏。井边一架小红花。她想摘一朵，听见母亲纺车声音，觉得该回家了，天不早了，就说：“我明天一早来摘你。你在那儿，我记得！”她可以给旅行人指路：“山上有个庙，庙里和尚好，你可以去借宿。”小姑娘和旅行人都走了，剩下一口井。他们走了一会，井栏上的余滴还丁丁咚咚地落回井里。村边的大乌柏树黑黑的。夜开始向它合过来。磨麦子的石碾呼呼的声音停止在一点上。 想起这个妹妹时，他母亲是一头乌青的头发。他多愿意摘一朵红花给母亲戴上。可是他从来没见过母亲戴过一朵花。就是这一朵没有戴上的花决定了他的命运。 母亲呀，我没有看见你的老。 于是他的母亲有一副年轻的眉眼而戴了一头白发。多少年来这一头白发在他心里亮。 他真愿意有那么一个妹妹。 可是他没有妹妹，他没有！ 他的现在，母亲的过去。母亲在时间里停留。她还是那样年轻，就像那个摘花的小姑娘，像他的妹妹。他可是老多了，他的脸上刻了很多岁月。 他在相似的风景里做了不同的人物。风景不殊，他改变风景多少？现在他在山上，在许多山里的一座小庙里，许多小庙里的一个小小的禅房里。 多少日子以来，他向上，又向上；升高，降低一点，又升得更高。他爬的山太多了。山越来越高，山头和山头挤得越来越紧。路越来越小，也越来越模糊。他仿佛看到自己，一个小小的人，向前倾侧着身体，一步一步，在苍青赭赤之间的一条微微的白道上走。低头，又抬头。看看天，又看看路。路像一条长线，无穷无尽地向前面画过去。云过来，他在影子里；云过去，他亮了。他的衣裙上沾了蒲公英的绒絮，他带它们到远方去。有时一开眼，一只鹰横掠过他的视野。山把所有的变化都留在身上，于是显得亘古不变。他想：山呀，你们走得越来越快，我可是只能一个劲地这样走。及至走进那个村子，他向上一看，决定上山借宿一宵，明天该折回去了。这是一条线的尽头了，再往前没有路了。 他阖了一会眼。他几乎睡着了，几乎做了一个梦。青苔的气味，干草的气味。风化的石头在他的身下酥裂，发出声音，且发出气味。小草的叶子窸窣弹了一下，蹦出了一个蚱蜢。从很远的地方飘来一根鸟毛，近了，更近了，终于为一根枸杞截住。他断定这是一根黑色的。一块卵石从山顶上滚下去，滚下去，滚下去，落进山下的深潭里。从极低的地方传来一声牛鸣。反刍的声音（牛的下巴磨动，淡红色的舌头），升上来，为一阵风卷走了。虫蛀着老楝树，一片叶子尝到了苦味，它打了一个寒噤。一个松球裂开了，寒气伸入了鳞瓣。鱼呀，活在多高的水里，你还是不睡？再见，青苔的阴湿；再见，干草的松软；再见，你硌在胛骨下抵出一块酸的石头。老和尚敲磐。现在，旅行人要睡了，放松他的眉头，散开嘴边的纹，解开脸上的结，让肩膊平摊，腿脚舒展。 烛火什么时候灭了。是他吹熄的？ 他包在无边的夜的中心，像一枚果仁包在果核里。 老和尚敲着磐。 水上的梦是漂浮的。山里的梦挣扎着飞出去。 他梦见他对着一面壁直的黑暗，他自己也变细，变长。他想超出黑暗，可是黑暗无穷的高，看也看不尽的高呀。他转了一个方向，还是这样。再转，一样。再转，一样。一样，一样，一样是壁直而平，黑暗。他累了，像一根长线似的落在地上。“你软一点，圆一点嘛！”于是黑暗成了一朵莲花。他在莲花的一层又一层瓣子里。他多小呀，他找不到自己了。他贴着黑的莲花作了一次周游。丁——，莲花上出现一颗星，淡绿的，如磷火，旋起旋灭。余光霭霭，归于寂无。丁——，又一声。 那是和尚在做晚课，一声一声敲他的磐。他追随，又等待，看看到底多久敲一次。渐渐的，和尚那里敲一声，他心里也敲一声，不前不后，自然应节。“这会儿我若是有一口磐，我也是一个和尚。”佛殿上一盏像是就要熄灭，永不熄灭的灯。冉冉的，钵里的花。一炷香，香烟袅袅，渐渐散失。可是香气透入了一切，无往不在。他很想去看看和尚。 和尚，你想必不寂寞？ 客人，你说的寂寞的意思是疲倦？你也许还不疲倦？ 客人的手轻轻地触到自己的剑。这口剑，他天天握着，总觉得有一分生疏；到他好像忘了它的时候，方知道是如何之亲切。剑呀，不是你属于我，我其实是属于你的。和尚，你敲磐，谁也不能把你的磬的声音收集起来吧？你的禅房里住过多少客人？我在这里过了我的一夜。我过了各色的夜。我这一夜算在所有的夜的里面，还是把它当作各种夜之外的一个夜呢？好了，太阳一出，就是白天。明天我要走。 太阳晒着港口，把盐味敷到坞边的杨树的叶片上。海是绿的，腥的。 一只不知名的大果子，有头颅那样大，正在腐烂。 贝壳在沙粒里逐渐变成石灰。 浪花的白沫上飞着一只鸟，仅仅一只。太阳落下去了。 黄昏的光映在多少人的额头上，在他们的额头上涂了一半金。 多少人逼向三角洲的尖端。又转身，分散。 人看远处如烟。 自在烟里，看帆篷远去。 来了一船瓜，一船颜色和欲望。 一船是石头，比赛着棱角。也许—— 一船鸟，一船百合花。 深巷卖杏花。骆驼。 骆驼的铃声在柳烟中摇荡。鸭子叫，一只通红的蜻蜓。 惨绿色的雨前的磷火。 一城灯！ 嗨，客人！ 客人，这仅仅是一夜。 你的饿，你的渴，饿后的饱餐，渴中得饮，一天的疲倦和疲倦的消除，各种床，各种方言，各种疾病，胜于记得，你一一把它们忘却了。你不觉得失望，也没有希望。你经过了哪里，将去到哪里？你，一个小小的人，向前倾侧着身体，在黄青赭赤之间的一条微微的白道上走着。你是否为自己所感动？ “但是我知道我并不想在这里出家！” 他为自己的声音吓了一跳。这座庙有一种什么东西使他不安。他像瞒着自己似的想了想那座佛殿。这和尚好怪！和尚是一个，蒲团是两个。一个蒲团是和尚自己的，那一个呢？佛案上的经卷也有两份。而他现在住的禅房，分明也不是和尚住的。 这间屋，他一进来就有一种特殊的感觉。墙极白，极平，一切都是既方且直，严厉而逼人。而在方与直之中有一件东西就显得非常的圆。不可移动，不可更改。这件东西是黑的。白与黑之间划出分明界限。这是一顶极大的竹笠。笠子本不是这颜色，它发黄，转褐，最后就成了黑的。笠顶有一个宝塔形的铜顶，颜色也发黑了，——一两处锈出了绿花。这顶笠子使旅行人觉得不舒服。什么人戴了这样一顶笠子呢？拔出剑。他走出禅房。 他舞他的剑。 自从他接过这柄剑，从无一天荒废过。不论在荒村野店，驿站邮亭，云碓茅蓬里，废弃的砖瓦窑中，每日晨昏，他都要舞一回剑，每一次对他都是新的刺激，新的体验。他是在舞他自己，他的爱和恨。最高的兴奋，最大的快乐，最汹涌的激情。他沉酣于他的舞弄之中。 把剑收住，他一惊，有人呼吸。 “是我。舞得好剑。” 是和尚！和尚离得好近。我差点没杀了他。 旅行人一身都是力量，一直贯注到指尖。一半骄傲，一半反抗，他大声地喊： “我要走遍所有的路。” 他看看和尚，和尚的眼睛好亮！他看着这双眼睛里有没有讥刺。和尚如果激怒了他，他会杀了和尚。然而和尚站得稳稳的，并没有为他的声音和神情所撼动，他平平静静，清清朗朗地说： “很好。有人还要从没有路的地方走过去。” 万山百静之中有一种声音，丁丁然，坚决地，从容地，从一个深深的地方迸出来。 这旅行人是一个遗腹子。父亲被仇人杀了，抬回家来，只剩一口气。父亲用手指蘸着自己的血写下了仇人的名字，就死了。母亲拾起了他留下的剑。剑在旅行人手里。仇人的名字在他的手臂上。到他长到能够得到井边的那架红花的时候，母亲交给他父亲的剑，在他的手臂上刺了父亲的仇人的名字，涂了蓝。他就离开了家，按手臂上那个蓝色的姓名去找那个人，为父亲报仇。 不过他一生中没有叫过一声父亲。他没有听见过自己叫父亲的声音。 父亲和仇人，他一样想不出是什么样子。如果仇人遇见他，倒是会认出来的：小时候村里人都说他长得像父亲。然而他现在连自己是什么样子都不清楚了。 真的，有一天找到那个仇人，他只有一剑把他杀了。他说不出一句话。他跟他说什么呢？想不出，只有不说。 有时候他更愿意自己被仇人杀了。 有时候他对仇人很有好感。 有时候他觉得自己就是那个仇人。既然仇人的名字几乎代替了他自己的名字，他可不是借了那个名字而存在的么？仇人死了呢？ 然而他依然到处查访这个名字。 “你们知道这个人么？” “不知道。” “听说过么？” “没有。” …… “但是我一定是要报仇的！” “我知道，我跟你的距离一天天近了。我走的每一步，都向着你。” “只要我碰到你，我一定会认出你，一看，就知道是你，不会错！” “即使我一生找不到你，我这一生是找你的了！” 他为自己这一句的声音掉了泪，为他的悲哀而悲哀了。 天一亮，他跑近一个绝壁。回过头来，他才看见天，苍碧嶙峋，不可抗拒的力量压下来，使他呼吸急促，脸色发青，两股紧贴，汗出如浆。他感觉到他的剑。剑在背上，很重。而从绝壁的里面，从地心里，发出丁丁的声音，坚决而从容。 他走进绝壁。好黑。半天，他什么也看不见。退出来？不！他像是浸在冰水里。他的眼睛渐渐能看见面前一两尺的地方。他站了一会，调匀了呼吸。丁，一声，一个火花，赤红的。丁，又一个。风从洞口吹进来，吹在他的背上。面前飘来了冷气，不可形容的阴森。咽了一口唾沫。他往里走。他听见自己跫跫足音，这个声音鼓励他，教他走得稳当，不踉跄。越走越窄，他得弓着身子。他直视前面，一个又一个火花爆出来。好了，到了头： 一堆长发。长头发盖着一个人。匍匐着，一手錾子，一手铁锤，低着头，正在开凿膝前的方寸。他一定是听见来人的脚步声了，他不回头，继续开凿。錾子从下向上移动着。一个又一个火花。他的手举起，举起。旅行人看见两只僧衣的袖子。他的披到腰下的长发摇动着。他举起，举起，旅行人看见他的手。这双手！奇瘦，瘦到露骨，都是筋。旅行人后退了一步。和尚回了一下头。一双炽热的眼睛，从披纷的长发后面闪了出来。旅行人木然。举起，举起，火花，火花。再来一个，火花！他差一点晕过去：和尚的手臂上赫然有三个字，针刺的，涂了蓝的，是他的父亲的名字！ 一时，他什么也看不见了，只看见那三个字。一笔一画，他在心里描了那三个字。丁，一个火花。随着火花，字跳动一下。时间在洞外飞逝。一卷白云掠过洞口。他简直忘记自己背上的剑了，或者，他自己整个消失，只剩下这口剑了。他缩小，缩小，以至于没有了。然后，又回来，回来，好，他的脸色由青转红，他自己充满于躯体。剑！他拔剑在手。 忽然他相信他的母亲一定已经死了。 铿的一声。 他的剑落回鞘里。第一朵锈。 他看了看脚下，脚下是新开凿的痕迹。在他脚前，摆着另一副锤錾。 他俯身，拾起锤錾。和尚稍微往旁边挪过一点，给他腾出地方。 两滴眼泪闪在庙里白发的和尚的眼睛里。 有一天，两副錾子同时凿在虚空里。第一线由另一面射进来的光。 约一九四四年写在昆明黄土坡","link":"/fu-chou/"},{"title":"数论：不定方程整数解","text":"欧几里得算法 又称辗转相除法，迭代求两数 gcd。 由 $(a, b) = (a, ka + b)$ 的性质，$\\gcd(a, b) = \\gcd(b, a\\bmod b)$。容易证明这么做的复杂度是 $O(\\log n)$。 注意：$\\gcd(0, a) = a$。 裴蜀定理 裴蜀定理：设 $(a, b) = d$，则对任意整数 $x, y$，有 $d|(ax + by)$ 成立；特别地，一定存在 $x, y$ 满足 $ax + by = d$。 等价的表述：不定方程 $ax + by = c(a, b, c 为整数)$ 有解的充要条件为 $(a, b)|c$。 P4549 【模板】裴蜀定理 裴蜀定理可以推广到多元方程。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() { int n; scanf(&quot;%d&quot;, &amp;n); int a; scanf(&quot;%d&quot;, &amp;a); int g = a; for(int i=2; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;a); if(a == 0) continue; if(a &lt; 0) a = -a; g = __gcd(g, a); } printf(&quot;%d\\n&quot;, g); return 0;} 扩展欧几里得（exgcd） 裴蜀定理的推论：$a, b$ 互质等价于 $ax + by = 1$ 有解。 因此，要求不定方程 $ax+by=c$ 的解，只需求 $ax+by=d,d=\\gcd(a,b)$ 的解，然后扩倍（乘上 $\\frac{c}{d}$）即可。 求出任意一个解 考虑使用欧几里德算法的思想，令 $a = bq + r$，其中 $r = a \\bmod b$，递归求出 $bx + ry = d$ 的一个解。 设求出 $bx + ry = d$ 的一个解为 $x = x_0, y = y_0$，考虑如何把它变形成 $ax + by = d$ 的解。 将 $a = bq + r$ 代入 $ax + by = d$，化简得 $$ b(xq + y) + rx = d $$ 令 $$ xq + y = x_0, x = y_0 $$ 上式成立。 故 $$ x = y_0, y = x_0 - y_0q $$ 为 $ax + by = d$ 的解。 注意边界情况：当 $b = 0$ 时，必有 $a = d$，此时令 $x = 1, y = 0$ 即可。 怎么求出所有解？ 先用exgcd 求出任意一个解 $x = x_0, y = y_0$，再求出 $ax + by = 0$ 的最小的解 $$ x = dx = b/(a, b), y = dy = -a/(a, b) $$ 所有解就是 $$ x = x_0 + kdx, y = y_0 + kdy,k\\in \\mathbb{Z} $$ P1082 同余方程 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; pll;ll a, b;pll exgcd(ll a, ll b) { if(b == 0) return {1,0}; pll p = exgcd(b, a%b); return {p.second, p.first-a/b*p.second};}int main() { scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b); ll x = exgcd(a,b).first; while(x &lt; 0) x+=b; while(x-b &gt; 0) x-=b; printf(&quot;%lld\\n&quot;, x); return 0;} P3951 [NOIP2017提高组]小凯的疑惑 方法很多，这里提供一个比较好理解的扩欧做法。 首先已知题目必存在答案，那么设答案为 $k-1$ ，则 $ax+by=k$ 必有一组非负整数解 $(x,y)$ 假设 $ax+by=k-1$ 有非负整数解，那么该式必能化为 $$ a(x-x_0)+b(y-y_0)=k $$ 其中 $$ ax_0+by_0=1 $$ 注意到，若尽量使该式能够有解，则有两种情况，分别令 $x_0$ 或 $y_0$ 取其最小非负整数解 $x’$ 和 $y’'$（因为一方最小时另一方必为最大情况） 因此为了让原式无解，需保证 $x-x’&lt;0, y-y’‘&lt;0$，即 $x&lt;x’,y&lt;y’'$ 因为要构造最大非负整数解，所以令 $x=x’-1,y=y’‘-1$ 所得即为 $k$，答案即为 $a(x’-1)+b(y’'-1)-1$，就可以直接利用扩欧求解了。 不过其实还能进一步化简 有一个很显然的结论，$ax_0+by_0=1$ 是没有非负整数解的 然后把 $x,y$ 想象成分别在两个竖直的数轴上，可以发现，对于上面的两组解 $(x’,y’),(x’‘,y’')$，他们都是离水平面（原点）最近的解，所以他们在扩欧通解上是两组相邻的解 则 $$ \\begin{aligned} ans&amp;=k-1\\\\ &amp;=a(x’-1)+b(y’‘-1)-1 \\\\ &amp;=ax’-a+by’‘-b-1 \\\\ &amp;=ax’+by’+ab-a-b-1 \\\\ &amp;=ab-a-b. \\end{aligned} $$","link":"/num-exgcd/"},{"title":"数论：整除问题","text":"整除分块 与其说整除分块是一种算法，不如说它是一个技巧。有时我们需要计算这样的式子： $$ \\sum_{i=1}^n f(i)\\lfloor\\frac{n}{i}\\rfloor $$ 根据经验，我们发现 $\\lfloor\\frac{n}{i}\\rfloor$ 只有 $O(\\sqrt n)$ 种取值。对于每种取值，$i$ 都会有一个连续的范围。假设函数 $f$ 的前缀和可以预处理后快速求出，那么我们可以枚举 $\\lfloor\\frac{n}{i}\\rfloor$ 的所有取值，并和 $f$ 的连续一段的和相乘。具体可以见代码： 1234567// s[i] 为函数 f(i) 的前缀和 int ans = 0;for(int i=1, j; i&lt;=n; i=j+1) { j = n/(n/i); ans += (s[j]-s[i-1])*(n/i);}printf(&quot;%d\\n&quot;, ans); 杂题 P4942 小凯的数字 我们知道，一个数模 $9$ 等于他的各位和模 $9$。这一结论可以推广至将某数截成若干节，每段合起来也符合这个规律，题目便转化成求 $\\sum_{i=l}^{r} i\\pmod 9$。用 __int128 也可以过，但是更好是把除以二挪到前面，使其符合乘法取模分配率，注意奇偶。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;int a[15], b[15];int main() { int q; scanf(&quot;%d&quot;, &amp;q); for(int i=1; i&lt;=q; ++i) { LL l, r; scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r); if((r-l+1) %2 == 0) printf(&quot;%lld\\n&quot;, ((r-l+1)/2)%9*(l+r)%9); else printf(&quot;%lld\\n&quot;, ((l+r)/2)%9*(r-l+1)%9); } return 0;}","link":"/num-theory/"},{"title":"未来","text":"“When you have that last piece of the jigsaw, everything will, I hope, be clear. . . .&quot; 「引子」 我听着《我们仍不知道那年中美合拍的日子》，突然，章老师走了进来。我打开空气净化器，看了看垃圾桶里闪闪发光的律师函。 总之，故事就这样开始了。 「初雪」 六老师签售会当天，现场热闹的很。 “六爷爷……孙悟空到底有几个女朋友啊？” “所以我经常说，”章承恩回头望了望摄像机。“戏说不是胡说，改编不是乱编。……一个民族……文化……谢罪……拿着棒子这么走……” 这时，“啊——”的一声惨叫传来。六水线旁，一名男子倒在地上，已经没有了气息。 —— “死者名叫戴杉并，29 岁，在金猴皮鞋厂工作，不过似乎并不是他的主业。在他的电脑里，我们找到了很多线索表明这位海军上将……”三谷（Mitani）汇报道。 “行了行了，”我不耐烦地打断道，“我名侦探江户川（Edogawa）可不是来听你 × × 的。说吧，名单上还有谁？” “你怎么知道……”三谷失声道。 “喂喂，”我敲了敲桌子，“就你这智商还想干这事？告诉你吧，作者看你蠢成这样，特意派我来带你走向人生巅峰的。所以，现在——” 「正宫」 那天，我听闻杨洁导演去世了，准备好挽联，前去吊唁。 灵堂的气氛非常肃穆。那边六老师竟也换上了一袭黑衣，毕恭毕敬地垂下头，低声道： “今年下半年……中美合拍……杨洁导演满意……多多支持。” 我沉痛地走出灵堂，外面的天已经黑了。天上的几颗星星闪着明灭的冷光。 我低头看了看手表：十三时二十六分。 难道是……？！ 我缓而又缓地回过头。气势恢宏的大堂已经了无踪影。一望无际的原野上，章老师和几个吊唁的人似乎也意识到了什么，震悚地踅向四周。 突然，一道白痕闪了光，现了一个人，急匆匆地跑了过来。我看到他那惊愕之下掩着的笑意的脸，不禁一声哀叹： “唉！又是这个蠢货！” 就在这时，高速跑动的他像是被什么绊了一下，“咚”地一声趴在了地上。 额……我不得不承认的是，虽然作者的确缺乏才华（很多时候都要靠我自己的演技），但在关键问题的处理上却是一点也不含糊。 我一边想着，一边向人群走去。 「Q&A」 只听得章老师对着全国人民破口大骂道： “等我回去以后，一个一个给你们寄律师函……对了，今年下半年……” :::default Question：人类的本质是什么？ Wrong Answer：复读机 Accepted：人类的本质是什么？ ::: 「设计实验」 （好像又扯远了……说正事） “必须灭杜！”桌对面的一个人大声喊道。我回过神来。 我皱起眉。那个名叫马三傻（Ma Wasabi）的人又来了。 旁边的那个人似乎也毫无兴致，一脸心不在焉地附和着。 “……灭杜使我成为一个完整的人。？” “……啊？对对对，一点也不能剩。”上原（Uehara）答道。 “咦，怎么不见时川（Tokikawa）来？”我向邻座的新见（Shimmi）问道。他摇摇头。 “不知道。许是睡过头了吧。” 话虽这么说，但一个小时后，时川还没有下来。我因闲得无聊，便打开「神奇动物园」。这是一款专为睿智人群设计的高端手游，画面精良，很适合用来打发时间。 “时川还不下来？”工藤（Kudo）不耐烦道。 “要不上去看一下吧，”我提议道。 我同工藤到得他的房间口，敲了敲门。没有应声。 “等我给他打个电话。”工藤拿出寻呼机。电话铃响到第十三下时，他摇头。“没有人接。” 我们没有办法，只好找来了服务人员。我推开门：这里并没有人。 “他的背包还在，应该是没准备长时间外出的。”工藤道。 我点点头。看来也不会有什么发现了。“走吧，”我说道。 工藤和我正要离开之时，我的目光落在了浴室的门框上。门的合页上，圆珠笔迹的刻痕： + '5' (18) 65 ？ 我决定不再多想。 我们回到大厅。 “找到了吗？”五反田（Gotanda）问道。工藤摇头。 “已经十二点了，”高桥（Takahashi）道。“要不先吃饭吧。” 餐桌上的气氛非常肃穆。大家都默默吃着，seldom next 的两个人小声低语。时川到底去了哪里呢？ 这时，店员端来了两面金黄的油炸哥布林。十数双筷子顿时一齐扑了过去。我没有动。 “天一……不来一块？”新见狼吞虎咽地吃着。 “奇怪，”我喃喃道，“总觉得有什么不对。” “哪里不对了？我告诉你，完整的哥布林可是稀世珍品，难不成你想吃被滚木碾过一遍的？”他自谓幽默地笑笑，“快点吧，凉了就不好吃了。” 我取下一片，仔细检查一番；没有 clue。看来我的第六感最近也变得不准了啊，我苦笑着夹起放入嘴中。 ——我呸呸几口吐了出来。“哥布林有毒！” 旁边的人惊诧地看了我一眼，随即也下意识地做了。 “什么？……有毒？” “我们吃着什么事都没有呵……哪里有毒了？” 但我既不要无谓的辩解了。循着水木（Mizuki）惊惧的目光，工藤满口白沫地倒在了桌上，一下最后的抽搐。 「端口Ｉ」 警察匆忙赶到现场。 “初步判断死者应该是死鱼（Diefish）氰化物中毒，”法医汇报道，“不过具体原因还要等解剖结果。” 他点点头。 警察和服务员简单地交谈了几句，走了。房间里笼罩着一团滞重的沉默。 “S 失踪了，Q 死了，”我自言自语道，“下一个就是我了。” 「DNS错误！」 然而这个世界已不存在规则了。 「Loading . . .」 “好嗨哟！”有人在我耳边喊道。 “嗨ニマ啊，要动手赶快！”我不满道。 “好的好的，”那人说着掏出一卷绳子。“我打算勒死你。不过分吧？” “能换个更舒服的吗？这个绳子勒着好疼。”我问道。 他摇了摇头。“恐怕没有机会了。” “喂！”已经喘不过气的我奋力嚷道。“剧本可不是这么写的！” “我知道，”他平静地说。“你还有什么要说的吗？” “你……”我很生气。 我边生气边想着明天早上吃什么。 「你们家的网炸了？」 “江户川先生昨天晚上被人不改剧本就弄死了。”我悲伤地告诉了另外的几个人。 大家都非常惋惜。 「460？再见」 两个月后。 我和高桥，新见，五反田四个人准时上了火车。 “出口竟然没被堵死，”我对新见说道。 “是啊；话说也真是的，十二个人最后就剩下了四个，连盘身份局都凑不齐……真是无聊。”新见摇头。 “对了，马三傻是怎么死的来着？”五反田（他似乎一直对这件事念念不忘）第 9102 次问道。 “唉，只有他死的最惨啊。你说是不是？”新见满脸泪光地笑了起来。 “没有办法……”我鼻子一酸。“他那天本来想去地沟弄点早点吃，结果刚一出门就让火车给撞死了……”我不由自主地哭了起来；高桥，新见，五反田也不甘示弱，一瞬间，整个车厢里哀嚎声，哭声，抽泣声，抹泪声揉作一团，是一浪高过一浪，过了好久，车厢里还回荡着一股海风的味道。 “三谷被人用诺基亚砸死了；R 上电梯时被从后面推了一下，掉到电梯井里摔死了；Y ……”五反田回忆道。 “对了，”高桥突然叫道，“还记得时川吗？” “他可能永远都不会回来了。”我推开窗。 “为什么？”新见问道。只听得五反田似有似无的抽泣声。 “他去了另一个地方。”半晌，我长吁一口气。“一个更值得的 occasion。” “比我们要去的这个地方更值得？”高桥问道。我用力点了点头。 之后的很长一段时间里没有人说话。 我久久地望向窗外。又是在这不经意的一刹，透过窗玻璃的反光，高桥指着我，对着正要说出什么惊天秘密似的新见使了个眼色。 我叹了口气。他们果然早已知道了一切。我所为之付的一番心血，并诩诩然以为天衣无缝的计划，不过是跳梁小丑罢了；一切都发生在那么短短的，不到十秒的时间里，可对我来说却像极了一生。 我的视线依然投在远方。看着看着，我渐渐不明白有多少东西可以称得上是变化了。世界本来就没有形状。 我想说些什么，但终究说不出口。我便一直是个如此懦弱的人。 即使是踏上这辆撞死了马三傻的火车。 “还有多长时间到？”高桥看了看手表。 “很快，”我答道。 “诶我突然有个想法，”五反田打起精神，“如果我们到站了还不下车，那么它会载我们到哪里？” “向前。” “Forever?” “Yes.” “可是……是你创造了这一切吧？” 我默然。新见好像打开了「神奇动物园」。 “Give him a rest 吧，”高桥说，“那些事不必再提了。” 我出神地望着车厢的一点。 “吱——”传来汽笛的轰鸣声。 “我们到了，”新见说。 太阳钻了出来。一阵熹微，暖融融地照在我们的脸上。 “I say . . . 我们应该给自己取个新名字吧？”五反田提议道，“毕竟西湖六月初嘛。我呢，就叫 MRC 好了。” “我叫大辣鸡。”新见若有所思道。 “我叫大肥猪。”高桥毫不犹豫地说出了自己的心声。 “所以……你呢？”所有人的目光望向我。我惊了一下，笑容凝结在脸上。就在那边。 我眨了眨眼；一切如故。 原来我们是到了这里啊，我想道。不过也无所谓了。 新见和五反田 paradox 地对视着。 “天一有事吗……”高桥迟疑了一下，问道。 “没事没事，”我摆摆手，“刚才想事来着。” 太阳沉了下去。最初的一道光。 “高桥？”我唤道。她侧过脸。 “怎么啦？” “早晨来临了。” （BGM :ノルウェイの森） （WOW） （&lt;・)))&gt;&lt;&lt;）","link":"/future/"},{"title":"年轻人不讲武德","text":"缘起 健身房的年轻后生不讲武德偷袭马老师，把马保国老师的眼睛给蹭了一下 音译 啊朋友们好啊，我是浑元形意太极门掌门人马保国。 刚才有个朋友，问我马老师发生甚么事了，我说怎么回事，给我发了几张截图。我一看，嗷，原来是左天，有两个年轻人，30多岁，一个体重90多公斤，一个体重80多公斤。塔们说，诶，有一个说是，我在健身房练功，颈椎练坏了，马老师你能不能教教我浑元功法，矮…帮助治疗一下我的颈椎病。我说可以。 我说你在健身房练死劲儿，不好用，塔不服气。诶，我说小朋友，你两个手来折我一个手指头，塔折不动，他说你这没用，我说我这个有用，这是化劲儿。传统功夫是讲化劲儿的，四两拨千斤。二百多斤的英国大力士都握不动我的一个手指头，啊。他非跟我试试，我说可以。 诶，我一说，他啪就站起来了。很快啊！然后上来就是一个左正蹬，一个右鞭腿，一个左刺拳，我全部防出防出去了啊。防出去以后，自然就是，传统功夫以点到为止。右拳放到他鼻子上没打他，我笑一下准备收拳，因为这时间，按传统功夫的点到为止，他已经输了。如果这一拳发力，一拳就把他鼻子打鸪鹧了。放在鼻子上没有打他，他也承认，我先打到他面部。他不知道拳放在了鼻子上，他承认我先打到他面部，啊！我收拳的时间不打了，他突然袭击，左刺拳来打我脸，啊。我大E了啊，没有闪。矮…他的左拳给我眼，啊右眼，蹭了一下。但没关系啊，他也说，啊，他截图也说了，两分多钟以后，当时流眼泪了，捂着眼，我说婷婷，然后两分钟钟以后，两分多钟以后，诶…就好了。 我说小伙子你不讲武德，你不懂。马老师对不起对不起我不懂规矩，啊，他说他是乱打的。他可不是乱打的啊，蹬蹬，鞭腿，左刺拳，训练有素。后来他说他练过三四年泰拳，啊，看来是有备而来！这两个年轻人不讲武德，来，骗，来，偷袭，我69岁的老同志。这好吗？这不好。我劝，这位年轻人耗子尾汁，好好反思，以后不要再犯这样的聪明，小聪明，啊，呃…武林要以和为贵，要讲武德，不要搞窝里斗。谢谢朋友们！ 后续 一些已经搜不到的视频。 一 武 林 高 手 白鼠。 二 中 华 武 德 台词混剪。 三 马和耗子（完整版） 四 马保国 × 王者荣耀：国服蒙恬 国服婉儿 五 8848“耗子尾汁”手机 六 ⚡吉 祥 三 马⚡ 联动。 七 比三鞭更强！马保国的松活弹抖闪电五连鞭！ 原片。 收尾","link":"/mabaoguo/"},{"title":"涉江","text":"E 座的尽头是一扇窗。她喜欢伏在那里的窗棂上，很多个课间。窗外是一幢天井；三面环楼，夐不见曦。 天井的中央是一台鱼池。一到每年新生入学的时候，鱼们便如笋般冒了出来，流水潺潺，清荣峻茂；整个学校也像鱼池一样变得活络了起来。人们的脸上总是挂着笑容；鱼池旁也缀上了很多人影，来来往往的。 她的背后是一道走廊，连结着初中部和高一年级。原则上，高一的饮水机坏了，才会有人从这里经过，就比如这几天；那边的机器更高端，相传有四个水龙头。她听高三的学长们说，原先这里本是熙熙攘攘，那一年却突然间就变了天。或许今后也会有那一年吧。走廊里时常有行为艺术家们走过，小嘴抹蜜，应节而舞，免不了一群男女从旁指点，逼逼赖赖。也有三三两两的女生们，攒聚喁喁。偶尔天亮的时候，也会有许多男同，两两联会，而姐妹相称。 但这些都与她无关。她相信未来，相信辰星在无边的旷野，正如大多数人一样。她可能还没有想到过那样的一天，雪花浸满了每一个角落。空自，她守望着梦乡。 楼下有一群人走过，为首的迨着球。教室里传来九日的声响。他似乎看见了她。她的思绪仍然飘在远方，漠然颔首。 他们走上楼来。他一迳向 E 座的尽头走去。值勤的女生认出了他，嘴唇微微动了动，遽把脸扭了过去，没有作声。他也照着做了。那扇窗静静地在那里；窗闩没有扣严，被一阵狂风吹散了。他正要上前，风却一瞬间弱了下去。太阳拐了一个弯；和煦的光洒遍了他和她的窗。微风摩挲着窗扇，像一只系在法线上的蝴蝶。兰麝香仍在，珮环声渐远。","link":"/she-jiang/"},{"title":"数论：逆元","text":"什么是逆元？ 若 $ax \\equiv 1 \\pmod b$，则称 $x$ 是 $a$ 关于模 $b$ 的逆元，常记做 $a^{-1}$。 上式等价于 $ax + by = 1$，因此，一种求逆元的方法就是利用扩欧解方程 $ax + by = 1$。 显然，逆元不一定存在：其存在的充要条件为 $(a, b) = 1$。 推论：$p$ 是质数，$p$ 不整除 $a$，则 $a$ 模 $p$ 的逆元存在。 结论：在 $[0, b)$ 的范围内，$a$ 关于模 $b$ 的逆元（若存在）是唯一的。 证明： 反证法，若 $a$ 有两个逆元 $0 &lt; x_1 &lt; x_2 &lt; b$， 即 $ax_1 ≡ ax_2 ≡ 1 \\pmod b$， 那么有 $b|a(x_2 - x_1)$ 成立。 又由于 $(a, b) = 1$，因此 $b|(x_2 - x_1)$。 其中 $0 &lt; x_2 - x_1 &lt; b$，产生了矛盾。 求解逆元 $$ ax\\equiv 1 \\pmod p $$ 扩欧 上面已经提到过了，直接解方程 $ax + py = 1$ 即可。这个方法十分容易理解，而且对于单个查找效率不错，尤其是在模数比较大的时候。 这个做法在 $a,p$ 互质，但 $p$ 不是质数时也可以使用。其他方法均要求 $p$ 必须为素数。 快速幂 这个做法要利用费马小定理：若 $p$ 为素数，$a$ 为正整数，且 $a,p$ 互质，则有 $$ a^{p-1} \\equiv 1 \\pmod {p} $$ 因此， $$ \\begin{aligned} ax&amp;\\equiv 1 &amp;\\pmod p\\\\ \\Rightarrow ax&amp;\\equiv a^{p-1} &amp;\\pmod p\\\\ \\Rightarrow x &amp;\\equiv a^{p-2} &amp;\\pmod p \\end{aligned} $$ 用快速幂算出 $a^{p-2} \\pmod p$ 的值，这个数就是它的逆元了。 递推 用于求连续的数对于同一模数的逆元。 P3811 【模板】乘法逆元 首先有 $1^{-1}\\equiv 1 \\pmod p$。 然后设 $p=ki+r(1&lt;r&lt;i&lt;p)$，即 $k$ 是 $\\frac{p}{i}$ 的商，$r$ 是余数。 再将这个式子放到模 $p$ 意义下，有 $$ k\\times i+r \\equiv 0 \\pmod p $$ 两边乘上 $i^{-1}r^{-1}$，有 $$ \\begin{aligned} k\\times r^{-1}+i^{-1}&amp;\\equiv 0 &amp;\\pmod p\\\\ \\Rightarrow{}i^{-1}&amp;\\equiv -k\\times r^{-1} &amp;\\pmod p\\\\ \\Rightarrow{}i^{-1}&amp;\\equiv -\\lfloor \\frac{p}{i} \\rfloor*(p \\bmod i)^{-1} &amp;\\pmod p \\end{aligned} $$ 于是，我们就可以递推求得逆元了。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;long long inv[int(3e6+10)]; int n, p;int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;p); inv[1] = 1; for(int i=2; i&lt;=n; ++i) { inv[i] = p-(p/i)*inv[p%i]%p; } for(int i=1; i&lt;=n; ++i) printf(&quot;%lld\\n&quot;, inv[i]); return 0;} 阶乘 首先有这样一个结论：$\\frac{1}{n!}=\\frac{1}{n}\\times\\frac{1}{(n-1)!}$，即 $(n-1)!$ 的逆元等于 $n!$ 的逆元乘 $n$。 因此，我们求出 $n!$ 的逆元然后逆推，可以求出 $1!,2!,\\dots,n!$ 的逆元；又 $\\frac{1}{n!}\\times(n-1)!=\\frac{1}{n}$，$n!$ 的逆元乘上 $(n-1)!$ 可以得到 $n$ 的逆元。","link":"/num-inv/"},{"title":"浅谈 Splay（一）","text":"1. 右旋（Right Rotation） 观察每个节点的变化，其中每个节点都有指向其父节点的指针没有画出。 ①②③处节点连接有变化。 （1）$Q$ 的左子树修改为 $P$ 的右子树的内容 即 $B$ 成为 $Q$ 的左子树， $B$ 的父节点是 $Q$ 。 12q-&gt;left = p-&gt;right; p-&gt;right-&gt;father = q; 注意 P​ 可能没有右子树（即不存在 P-&gt;right 节点）。 修改如下： 12q-&gt;left = p-&gt;right; if(p-&gt;right != NULL) p-&gt;right-&gt;father = q; （2）$P$ 的右子树修改为 $Q$ ，且同时 $Q$ 的父节点修改为 $P$ 。 12p-&gt;right = q; q-&gt;father = p; 注意 Q 和 P 的左右子树有变化，所以 Q,P 的信息需要重新维护。 1update(q); update(p); //先Q后P （3）$R$ 的子树应该修改为 $P$ 需要判断 $Q$ 是 $R$ 的哪种子树，左子树则 $P$ 给 $R$ 的左子树，否则给右子树。 全局变量 $root$ 记录树根。 特判 $Q$ 有可能就是树根（即 $R$ 不存在）； 12345678if(r == NULL) { p-&gt;father = NULL; root = p; return;}if(q == r-&gt;left) { r-&gt;left = p; p-&gt;father = r;} else { r-&gt;right = p; p-&gt;father = r;} 整理一下，不管 Q​ 有无父节点，P 的父节点均修改为 Q 的父节点。 123456p-&gt;father = r;//记录树根if(r == NULL) { root = p; return; }//判断P连到R的那颗子树if(q == r-&gt;left) r-&gt;left = p; else r-&gt;right = p; Code : 12345678910111213141516171819202122void right_rotate(node *p) { node *q = p-&gt;father; //记录p的父节点 node *r = q-&gt;father; //记录p的父节点的父节点 //操作1 q-&gt;left = p-&gt;right; if(p-&gt;right != NULL) p-&gt;right-&gt;father = q; //操作2 p-&gt;right = q; q-&gt;father = p; //维护节点信息（注意此处可暂不维护P） update(q); //update(p); //操作3 p-&gt;father = r; if(r == NULL) { root = p; return; } if(q == r-&gt;left) r-&gt;left = p; else r-&gt;right = p;} 2、左旋（Left Rotation） 同理右旋，只是①②不同。 Code : 12345678910111213141516171819202122void left_rotate(node *p) { node *q = p-&gt;father; //记录p的父节点 node *r = q-&gt;father; //记录p的父节点的父节点 //操作1 q-&gt;right = p-&gt;left; if(p-&gt;left != NULL) p-&gt;left-&gt;father = q; //操作2 p-&gt;left = q; q-&gt;father = p; //维护节点信息 update(q); //update(p); //操作3 p-&gt;father = r; if(r == NULL){ root = p; return; } if(q == r-&gt;left) r-&gt;left = p; else r-&gt;right = p;} 3、双旋 不断旋转 $X$ 节点，为了保证复杂度，需要连续旋转两次且旋转的次序不同。 定义 $X$ 的父节点为 $Y$，$Y$ 的父节点为 $Z$。 （1）$X$ 和 $Y$ 同时是其父节点的左子树或者同时是各自父节点的右子树（即同侧）。 这时我们要进行两次旋转，先旋转 $Y$，再旋转 $X$。 同左旋转演示图如下： 同右旋转演示图如下： （2）$X$ 和 $Y$ 是其父节点的左、右子树，不同侧（即一左一右或一右一左）。 这时我们只要 旋转两次 X​ 即可。 （3）判断 $X$ 节点如何旋转。 $X$ 是其父节点的左子树则右旋，否则左旋。 $X$ 若是它父节点左子树返回 true，否则返回 false： 123456789bool getlr(node *p) { return (p-&gt;father-&gt;left == p);} //选择合适的旋转方式void rotate(node *p) { if(getlr(p)) right_rotate(p); else left_rotate(p);} 4、旋转到根 将 $X$ 旋转到根是 splay 的关键，为了保证复杂度，只要对 $X$ 节点操作，操作后就要将其旋转到根。 如何旋转到根： 一步旋转就可以到根，进行单旋； 两步或两步以上，可以不断使用双旋。 设计函数 splay(p,q) 将 $P$ 旋转到 $Q$ 下方。 q == NULL 表示 $P$ 旋转到了根； while $P$ 至少两次旋转才能到达：双旋； if $P$ 还差一步满足条件：单旋。 Code : 1234567891011121314void splay(node *p, node *tar) { while(p-&gt;father != tar and p-&gt;father-&gt;father != tar) { if(getlr(p) == getlr(p-&gt;father)) { rotate(p-&gt;father); rotate(p); } else { rotate(p); rotate(p); } } if(p-&gt;father != tar) rotate(p); update(p); //优化（避免重复维护）}","link":"/about-splay/"},{"title":"预告","text":"《碎想》即将发布。 之前图床和评论都挂掉了，已经修复。","link":"/foreshow/"},{"title":"网络流：Dijkstra 求费用流","text":"注：下文中的边权 $w$ 均表示费用 $f$。 Dijkstra 不能求有负权边的最短路，所以我们可以对网络 $G$ 中的每一个点设置一个势函数 $h(u)$，以满足在与原图等价的新图中的边权非负。 最短路 在任意残留网络中的任意边 $(u,v)$ 都需要满足： $$ w_{u, v}+h(u) - h(v)≥0 $$ 令图 $G$ 的等价图为 $G’$，其对应的边 $(u,v)$ 的权值为 $$ w’{u,v} = w{u,v} + h(u) - h(v) $$ 因此，对于原图中的任意一条路径 $(u_1,u_2,\\dots,u_k)$，它在 $G$ 中的权值为 $$ w_{u_1,u_2}+w_{u_2,u_3}+\\dots+w_{u_{k-1},u_k} $$ 在 $G’$ 中的权值可化简为 $$ w_{u_1,u_2} + w_{u_2,u_3} + \\dots + w_{u_{k-1}, u_k} + h(u_1)-h(u_k) $$ 所以，在 $G’$ 求出的路径都可以对应到 $G$ 上。 令 $d_{u}$ 为图 $G$ 中源点 $s$ 到点 $u$ 的最短路径，图 $G’$ 中为 $d’_{u}$，显然有 $$ d_{u,v} = d’_{u,v}-h(u)+h(v) $$ 所以我们只需要求 $G’$ 的最短路径，就能对应回原图的最短路径。 势函数 初值 如果网络 $G$ 初始边权非负，则令 $h(u)=0$ ，否则可令 $h(u) = dis[u]$（用 SPFA 解决）。 证明略。 维护 每次增广后，令 $h(u)=h(u)+dis[u]$ 即可。 证明：对于残余网络上的任意边 $(u,v)$，均有 $$ dis[u]+w_{u,v}+h(u)-h(v)≥dis[v] $$ 移项，得 $$ w_{u,v}+(h(u)+dis[u])-(h(v)+dis[v]) \\geq 0 $$ 证毕。 P3381 ［模板］最小费用最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlineconst int N = 5500, M = 55000, INF = 0x3f3f3f3f;struct point { int u, val; point(int _u = 0, int _val = 0): u(_u), val(_val) {} bool operator &lt; (const point &amp;o) const { return val &gt; o.val; } };priority_queue &lt;point&gt; q;struct node { int u, v, w, f, next; node() {}} e[M &lt;&lt; 1];int head[N], tot = 0;il void add(int u, int v, int w, int f) { e[tot].u = u, e[tot].v = v, e[tot].w = w, e[tot].f = f; e[tot].next = head[u]; head[u] = tot++;}int h[N], dis[N], flow[N], pre[N];int n, m, s, t;int maxflow = 0, mincost = 0;il bool dijkstra() { memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); memset(pre, -1, sizeof pre); dis[s] = 0; q.push(point(s, 0)); while (!q.empty()) { int u = q.top().u, val = q.top().val; q.pop(); if (val &gt; dis[u]) continue; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].v; if (e[i].w and dis[v] &gt; dis[u] + e[i].f + h[u] - h[v]) { pre[v] = i; flow[v] = min(flow[u], e[i].w); dis[v] = dis[u] + e[i].f + h[u] - h[v]; q.push(point(v, dis[v])); } } } return dis[t] != INF;}il void check() { for (int p = pre[t]; p != -1; p = pre[e[p].u]) { e[p].w -= flow[t]; e[p^1].w += flow[t]; } maxflow += flow[t]; mincost += (dis[t] - h[s] + h[t]) * flow[t]; for(int i=1; i&lt;=n; ++i) h[i] += dis[i];}int main() { freopen(&quot;p3381.in&quot;, &quot;r&quot;, stdin); memset(head, -1, sizeof head); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i=1, u, v, w, f; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;w, &amp;f); add(u, v, w, f); add(v, u, 0, -f); } while (dijkstra()) check(); printf(&quot;%d %d\\n&quot;, maxflow, mincost); return 0;}","link":"/network-flow-dijkstra/"},{"title":"网络流：最小割","text":"将图 $G$ 分为 $A$ 和 $B$ 两个点集，$A$ 和 $B$ 之间的边的集合称为无向图的割集。带权图的割 (Cut) 就是割集中的边权之和。 S - T 最小割 特别地，对于一个网络，在满足 $源点 s \\in 点集{S}, 汇点 t \\in 点集{T}(S\\cap T= \\varnothing)$ 的情况下，从 S 到 T 的边的权值和被称为 S 到 T 的割。 通俗地说，如果把你家和自来水厂之间的水管网络砍断了一些，那么自来水厂无论怎么放水，水都无法到达你们家，自然就停水了，砍掉的水管就是割。 砍水管的人自然希望花的力气越小越好。在所有割中，权值和最小的称为最小割。对于一个给定的 S - T 网络，如何求出它的最小割呢？ 最大流最小割定理 网络的最大流等于最小割。 这个定理看起来很简单，但是真去思考的话其实挺麻烦的。 证明 Step 1：任意一个流都小于等于任意一个割 自来水公司随便给你家通点水，构成一个流，随便砍几刀砍出一个割，那么由于容量限制，每一根的被砍的水管子流出的水流量都小于管子的容量。每一根被砍的水管的水本来都要到你家的，现在流到外面，加起来得到的流量还是等于原来的流。而管子的容量加起来就是割，所以流小于等于割。 由于上面的流和割都是任意构造的，所以任意一个流小于任意一个割，即 $$ \\forall F \\leqslant \\forall C $$ Step 2：构造出一个流，使它等于一个割 当达到最大流时，根据增广路定理，残留网络中 s 到 t 已经没有通路了。因此，若把残余网络中 s 能到的的点的集合设为 S，不能到的点集为 T ，构造出一个割集 $C[点集S,点集T]$，所有由 S 发往 T 的边必然满流。并且，这些满流边的流量和就是当前的流，即最大流。把这些满流边作为割，就构造出了一个和最大流相等的割。 Step 3：最大流等于最小割 设上一步构造出流和割分别为 $F_m$ 和 $C_m$。 又 $\\forall F \\leqslant \\forall C$ $\\therefore \\forall F \\leqslant F_m=C_m \\leqslant \\forall C$。 网络流等价定理 综合最大流最小割定理和增广路定理，可以得到这样的结论： 对于一个网络流图 $G=(V,E)$，其中有源点 $s$ 和汇点 $t$ ，那么下面三个条件是等价的： 流 $f$ 是图 $G$ 的最大流； 残留网络 $G$ 不存在增广路； 在 $G$ 中必存在一个割 $C[S,T]$，使得 $f=C[S,T]$。 读者自证不难 证明 1 =&gt; 2（即增广路定理） 利用反证法，假设流 $f$ 是图 $G$ 的最大流，但是残留网络中还存在有增广路 $p$，其流量为 $f_p$，则有流 $f’=f+f_p&gt;f$。这与 $f$ 是最大流产生矛盾。 证明 2 =&gt; 3（即最大流最小割定理） 总结一下上面的证明。 假设残留网络 $G_f$ 不存在增广路，所以在残留网络 $G_f$ 中不存在路径从 $s$ 到达 $t$。我们定义 $S$ 集合为当前残留网络中 $s$ 能够到达的点，同时定义 $T=V-S$，此时构成一个割 $C(S,T)$。 且 $u∈S,v∈T$，有 $f(u,v)=c(u,v)$。若 $f(u,v)&lt;c(u,v)$，则有 $G_f(u,v)&gt;0$，$s$ 可以到达 $v$，与 $v \\in T$ 矛盾。 因此有 $f(S,T)= \\sum f(u,v)=\\sum c(u,v)=C(S,T)$。 证明 3 =&gt; 1： 由于 $f$ 的上界为最小割，当 $f$ 到达割的容量时，显然就已经到达最大值，因此 $f$ 为最大流。 这样就说明了为什么找不到增广路时，所求得的一定是最大流。 最大权闭合子图 在一个图中，我们选取一些点构成集合，记为 V，且集合中的出边（即集合中的点的向外连出的弧），所指向的终点也在 V 中，则我们称 V 为闭合图。在所有闭合图中，集合中点的权值之和最大的 V，称为最大权闭合子图。 栗子 上图中最大权闭合子图为 {3,4,5}。 最大权闭合子图权值和 构图 构建一个超级源点 s，一个超级汇点 t，所有的点按权值的正负连接到 s 和 t 上，转换成一个边权值有向图，如下图： （注：点权为 0 的点可以忽略，对结果没有影响） 前置知识 该带边权有向图的 S - T 最小割，割集中所有的边，都与 s 或 t 相连接。 显然，因为不与 s,t 相连的边，权值都是 INF，最小割不可能割在 INF 的边上。 该图中的每一个简单割产生的两个子图，我们记含有点 s 的是图 S，含有点 t 的是图 T，则图 S 是最大权闭合子图。 简单割内不包含边权为 INF 的边，即不含有连通两个图的边（除了连接在 t 点上的边之外）；即，图 S 中没有边与图 T 连通，那么，所有的边都只能连接在图 S 之内，即为闭合图。 记割集中，所有连接在 s 上的边的权值和为 $x_1$，所有连接在 t 上的边的权值和为 $x_2$，则割集中所有边权值和为 $x=x_1+x_2$。 记图 S 中所有点的权值和为 $w$，记其中正权值之和为 $w_1$，负权值之和为 $- w_2$，故 $w = w_1 - w_2$。 因此， $$ w+x=w_1-w_2+x_1-x_2 $$ 又， $$ x_2 = w_2 $$ 因为图 S 中所有负权值的点必然连接到 t 点，而图 S 必然要与 t 分割开，故割集中，连接在 t 点上的边权值和就是图S中所有负权值点的权值之和取负。因而， $$ w+x=w_1+x_1 $$ 显然，$w_1 + x_1$ 是整个图中所有正权值之和，记为 $sum$，则 $$ w=sum-x $$ 即，图 S 中所有点的权值和 = 整个图中所有正权值之和 - 割集中所有边权值和。因为 $sum$ 为定值，只要我们取最小割，则图 S 中所有点的权值和就是最大的，即此时图 S 为最大权闭合子图。 栗子 解法 先记录整个图中，所有正点权值的和； 建立对应流网络，求最大流，最大流在数值上等于最小割，故我们得到了流网络的 s-t 最小割； 所有正点权值的和减去 s-t 最小割，即得最大权闭合子图的权值和。 P2762 太空飞行计划问题 Hint 这里大概讲一下转换成最大流以后怎么输出。 一个结论就是假如我们跑的是 Dinic 那么我们最后一次网络流（这一次网络流并没有起任何作用，只是确认了无更多残余流量可以退出了）中，所有被分到层的都一定被选上了。 没有更多残余流量其实意味着这个图已经被割成了两部分，一个实验如果有层数意味着它没有被割掉（被选上了），一个仪器如果有层数意味着它已经被割掉了（也是被选上了）。 于是只要在最后输出所有有层数的点就行了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 110, INF = 0x3f3f3f3f;char tools[10000];class node { public: int u, v, w, next;} e[N * N];int head[N], cur[N], tot = 0;void add(int u, int v, int w) { e[tot] = {u, v, w, head[u]}; head[u] = tot++; e[tot] = {v, u, 0, head[v]}; head[v] = tot++;}int h[N], n, m, s, t;bool bfs() { memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int&gt; q; q.push(s); h[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = head[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and h[v] == 0) { h[v] = h[u] + 1; if(v == t) return true; q.push(v); } } } return false;}int dfs(int u, int low) { if(u == t) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next, cur[u] = i) { int v = e[i].v; if(e[i].w and h[v] == h[u] + 1) { int f = dfs(v, min(w, e[i].w)); if(f == 0) h[v] = 0; e[i].w -= f; e[i^1].w += f; w -= f; if(w == 0) break; } } return low - w;}int maxflow = 0, sum = 0;void dinic() { int flow; while(bfs()) while(flow = dfs(s, INF)) maxflow += flow;}int main() { //freopen(&quot;shut2.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;m, &amp;n); memset(head, -1, sizeof head); s = 0, t = n+m+1; for(int i=1, w; i&lt;=m; ++i) { scanf(&quot;%d&quot;, &amp;w); add(s, i, w); sum += w; memset(tools, '\\0', sizeof tools); cin.getline(tools, 10000); int ulen = 0, tool; while(sscanf(tools + ulen, &quot;%d&quot;, &amp;tool) == 1) { add(i, tool + m, INF); if(tool == 0) ulen++; else { while(tool) { tool /= 10; ulen++; } } ulen++; } } for(int i=1, w; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;w); add(i+m, t, w); } dinic(); for(int i=1; i&lt;=m; ++i) if(h[i]) printf(&quot;%d &quot;, i); printf(&quot;\\n&quot;); for(int i=1; i&lt;=n; ++i) if(h[i+m]) printf(&quot;%d &quot;, i); printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, sum - maxflow); return 0;} 全局最小割 可参考这篇文章。 Code (POJ 2914, 未优化版) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 550;int g[N][N];int dis[N];bool flag[N], vis[N];int n, m, s, t;int main() { while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) { memset(g, 0, sizeof g); for(int i=1, a, b, c; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); ++a, ++b; g[a][b] += c; g[b][a] += c; } int ans = 0x3f3f3f3f; memset(flag, false, sizeof flag); for(int o=1; o&lt;n; ++o) { s = t = 0; memset(vis, false, sizeof vis); memset(dis, 0, sizeof dis); for(int p=1; p&lt;=n; ++p) { int v = -1; for(int i=1; i&lt;=n; ++i) if(!flag[i] and !vis[i] and (v == -1 or dis[v] &lt; dis[i])) v = i; if(v == -1) break; vis[v] = true; s=t, t=v; for(int i=1; i&lt;=n; ++i) if(!flag[i] and !vis[i]) dis[i] += g[t][i]; } flag[t] = true; ans = min(ans, dis[t]); if(ans == 0) break; for(int i=1; i&lt;=n; ++i) { if(flag[i]) continue; g[s][i] += g[t][i]; g[i][s] += g[i][t]; } } printf(&quot;%d\\n&quot;, ans); } return 0;}","link":"/minimum-cut/"},{"title":"网络流：模板","text":"P3376 网络最大流（Dinic） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 11000, M = 110000;const int INF = 0x7fffffff;struct node { int u, v, w, next;} e[M &lt;&lt; 1];int cur[N], h[N], tot;int dfn[N], ans, n, m, s, t;void add(int u, int v, int w) { e[tot] = node({u, v, w, h[u]}); cur[u] = h[u] = tot++;}bool bfs() { memset(dfn, 0, sizeof dfn); queue&lt;int&gt; q; dfn[s] = 1; q.push(s); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and !dfn[v]) { dfn[v] = dfn[u] + 1; q.push(v); if(v == t) return true; } } } return false;}int dfs(int u, int low) { if(u == t) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next) { int v = e[i].v; cur[u] = i; if(e[i].w and dfn[v] == dfn[u] + 1) { int f = dfs(v, min(w, e[i].w)); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}void dinic() { while(bfs()) { memcpy(cur, h, sizeof cur); ans += dfs(s, INF); }}int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); memset(h, -1, sizeof h); for(int i=1, u, v, w; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, 0); } dinic(); printf(&quot;%d\\n&quot;, ans); return 0;} P3381 最小费用最大流（单路增广） Dijkstra 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlineconst int N = 5500, M = 55000, INF = 0x3f3f3f3f;struct point { int u, val; point(int _u = 0, int _val = 0): u(_u), val(_val) {} bool operator &lt; (const point &amp;o) const { return val &gt; o.val; } };priority_queue &lt;point&gt; q;struct node { int u, v, w, f, next; node() {}} e[M &lt;&lt; 1];int head[N], tot = 0;il void add(int u, int v, int w, int f) { e[tot].u = u, e[tot].v = v, e[tot].w = w, e[tot].f = f; e[tot].next = head[u]; head[u] = tot++;}int h[N], dis[N], flow[N], pre[N];int n, m, s, t;int maxflow = 0, mincost = 0;il bool dijkstra() { memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); memset(pre, -1, sizeof pre); dis[s] = 0; q.push(point(s, 0)); while (!q.empty()) { int u = q.top().u, val = q.top().val; q.pop(); if (val &gt; dis[u]) continue; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].v; if (e[i].w and dis[v] &gt; dis[u] + e[i].f + h[u] - h[v]) { pre[v] = i; flow[v] = min(flow[u], e[i].w); dis[v] = dis[u] + e[i].f + h[u] - h[v]; q.push(point(v, dis[v])); } } } return dis[t] != INF;}il void check() { for (int p = pre[t]; p != -1; p = pre[e[p].u]) { e[p].w -= flow[t]; e[p^1].w += flow[t]; } maxflow += flow[t]; mincost += (dis[t] - h[s] + h[t]) * flow[t]; for(int i=1; i&lt;=n; ++i) h[i] += dis[i];}int main() { memset(head, -1, sizeof head); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i=1, u, v, w, f; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;w, &amp;f); add(u, v, w, f); add(v, u, 0, -f); } while (dijkstra()) check(); printf(&quot;%d %d\\n&quot;, maxflow, mincost); return 0;} SPFA 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 5500, M = 110000, INF = 0x3f3f3f3f;struct node { int u, v, w, f, next;} e[M];int h[N], tot = 0;void add(int u, int v, int w, int f) { e[tot] = {u, v, w, f, h[u]}; h[u] = tot++;}int pre[N], flow[N], dis[N];bool vis[N];int n, m, s, t, maxflow, mincost;bool spfa() { memset(pre, -1, sizeof pre); memset(vis, false, sizeof vis); memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); queue&lt;int&gt; q; q.push(s); vis[s] = true; dis[s] = 0; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = false; for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and dis[v] &gt; dis[u] + e[i].f) { dis[v] = dis[u] + e[i].f; pre[v] = i; flow[v] = min(flow[u], e[i].w); if(!vis[v]) { q.push(v); vis[v] = true; } } } } return dis[t] != INF;}void check() { for(int p = pre[t]; p != -1; p = pre[e[p].u]) { e[p].w -= flow[t]; e[p^1].w += flow[t]; } mincost += dis[t] * flow[t]; maxflow += flow[t];}int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); memset(h, -1, sizeof h); for(int i=1, u, v, w, f; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;w, &amp;f); add(u, v, w, f); add(v, u, 0, -f); } while(spfa()) check(); printf(&quot;%d %d\\n&quot;, maxflow, mincost); return 0;} LOJ115 无源汇有上下界可行流（超级源汇） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlineconst int N = 220, M = 11000, INF = 0x3f3f3f3f;struct node { int u, v, w, next;} e[M * 6];int head[N], cur[N], tot = 0;il void add(int u, int v, int w) { e[tot] = (node) {u, v, w, head[u]}; head[u] = tot++;}int h[N], n, m, ss, tt;il bool bfs() { //分层 memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int&gt; q; q.push(ss); h[ss] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = head[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and !h[v]) { h[v] = h[u] + 1; if(v == tt) return true; q.push(v); } } } return false;}int dfs(int u, int low) { if(u == tt) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next, cur[u] = i) { int v = e[i].v; if(e[i].w and h[v] == h[u] + 1) { int f = dfs(v, min(w, e[i].w)); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}int tflow = 0, sflow = 0;il void dinic() { for(int i = head[ss]; i != -1; i = e[i].next) sflow += e[i].w; //出流量 while(bfs()) dfs(ss, INF); for(int i = head[tt]; i != -1; i = e[i].next) tflow += e[i].w; //入流量 if(sflow == tflow) { //满流 printf(&quot;YES\\n&quot;); for(int i=0; i&lt;tot; i+=6) printf(&quot;%d\\n&quot;, e[i+1].w + e[i+5].w); //反边流量和 } else printf(&quot;NO\\n&quot;); }int main() { freopen(&quot;loj115.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(head, -1, sizeof head); ss = 0, tt = n+1; for(int i=1, u, v, l, h; i&lt;=m; ++i) { //建图 scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;h); add(u, tt, l); add(tt, u, 0); add(ss, v, l); add(v, ss, 0); add(u, v, h-l); add(v, u, 0); } dinic(); return 0;} 有源汇有上下界（转无源汇，然后断边） 最大流（顺流增广） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 220, M = 22000, INF = 0x3f3f3f3f;struct node { int u, v, w, next;} e[M];int head[N], cur[N], tot = 0;void add(int u, int v, int w) { e[tot] = (node) {u, v, w, head[u]}; head[u] = tot++; e[tot] = (node) {v, u, 0, head[v]}; head[v] = tot++;}int h[N], in[N], n, m, s, t, ss, tt, sflow = 0, tflow = 0;bool bfs(int s, int t) { memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int&gt; q; q.push(s); h[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = head[u], v; i != -1; i = e[i].next) { v = e[i].v; if(e[i].w and !h[v]) { h[v] = h[u] + 1; if(v == t) return true; q.push(v); } } } return false;}int dfs(int u, int low, int t) { if(u == t) return low; int w = low; for(int i = cur[u], v; i != -1; i = e[i].next, cur[u] = i) { v = e[i].v; if(e[i].w and h[v] == h[u] + 1) { int f = dfs(v, min(w, e[i].w), t); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}int main() { //freopen(&quot;loj116.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); ss = 0, tt = n+1; memset(head, -1, sizeof head); for(int i=1, u, v, l, h; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;h); in[u] -= l; in[v] += l; add(u, v, h-l); } for(int i=1; i&lt;=n; ++i) { if(!in[i]); else if(in[i] &gt; 0) { sflow += in[i]; add(ss, i, in[i]); } else { add(i, tt, -in[i]); } } add(t, s, INF); while(bfs(ss, tt)) tflow += dfs(ss, INF, tt); if(sflow != tflow) { printf(&quot;please go home to sleep\\n&quot;); return 0; } for(int i = head[ss]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; for(int i = head[tt]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; int sum = e[--tot].w; e[tot-1].w = e[tot].w = 0; while(bfs(s, t)) sum += dfs(s, INF, t); printf(&quot;%d\\n&quot;, sum); return 0;} 最小流（逆流增广） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 220, M = 22000, INF = 0x3f3f3f3f;struct node { int u, v, w, next;} e[M];int head[N], cur[N], tot = 0;void add(int u, int v, int w) { e[tot] = (node) {u, v, w, head[u]}; head[u] = tot++; e[tot] = (node) {v, u, 0, head[v]}; head[v] = tot++;}int h[N], in[N], n, m, s, t, ss, tt, sflow = 0, tflow = 0;bool bfs(int s, int t) { memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int&gt; q; q.push(s); h[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = head[u], v; i != -1; i = e[i].next) { v = e[i].v; if(e[i].w and !h[v]) { h[v] = h[u] + 1; if(v == t) return true; q.push(v); } } } return false;}int dfs(int u, int low, int t) { if(u == t) return low; int w = low; for(int i = cur[u], v; i != -1; i = e[i].next, cur[u] = i) { v = e[i].v; if(e[i].w and h[v] == h[u] + 1) { int f = dfs(v, min(w, e[i].w), t); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}int main() { //freopen(&quot;loj116.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); ss = 0, tt = n+1; memset(head, -1, sizeof head); for(int i=1, u, v, l, h; i&lt;=m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;h); in[u] -= l; in[v] += l; add(u, v, h-l); } for(int i=1; i&lt;=n; ++i) { if(!in[i]); else if(in[i] &gt; 0) { sflow += in[i]; add(ss, i, in[i]); } else { add(i, tt, -in[i]); } } add(t, s, INF); while(bfs(ss, tt)) tflow += dfs(ss, INF, tt); if(sflow != tflow) { printf(&quot;please go home to sleep\\n&quot;); return 0; } for(int i = head[ss]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; for(int i = head[tt]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; int sum = e[--tot].w; e[tot-1].w = e[tot].w = 0; while(bfs(s, t)) sum += dfs(s, INF, t); printf(&quot;%d\\n&quot;, sum); return 0;}","link":"/network-flow-template/"},{"title":"网络流：消圈算法","text":"注：下文中的权均表示费用。 消圈定理 在某个流 $f$ 中，如果其残余网络中没有负圈（剩余流量为 $0$ 的边视为不存在），那它一定是当前流量下的最小费用，否则一定不是。 证明 假设一个网络，所有边的容量都是 $1$。 如果流量走上路的话，其残余网络（黑箭头）变为： 因为上路的边的流量占满了，所以现在上路只有反边。 显然 $A \\rightarrow C \\rightarrow t \\rightarrow B \\rightarrow A$ 为负圈，沿此负圈增广（每条边的流量＋1），环上每个点的入流量仍然等于出流量（原流为可行流）。 流量在圈中增广，总的流量既没有增加，也没有减少，只不过是流量从费用更少的地方流过 （$A \\rightarrow C \\rightarrow t$），从费用大的地方退流而已（$t \\rightarrow B \\rightarrow A$），流过的流量和退掉的流量是相等的，实质上只是将从 $A$ 流出的流量的方向改变，使得费用更小。 网络流的反边给了我们一个很好的反悔机制，使得我们可以对任意一个流 $f$，通过消负圈（可能不止一个），来得到它当前流量下的最小费用流。 可以看到，沿着负圈增广之后，已经没有负圈存在了，已经达到了当前流量下的最小费用流（也就是最小费用最大流）。所以只要有负圈，就可以增广达到更小费用。 应用 求最小费用最大流时，可以先跑出一条可行最大流，然后通过不断消圈调整出最小费用。 更广泛用于残余网络寻找更优解。 POJ2175 Evacuation Plan 题面 原题面很长。 给出已达到最大流的残余网络，求出其是否已达到最小费用，如果未达到则找出更优方案。 思路 消圈模板，建出网络后利用 SPFA，如果一个节点被更新了 $n$ 次则说明图中一定存在负环。题目中没有说必须是最优解，因此只要将负圈上的流量调整 $1$ 即可。 注意一个节点被更新 $n$ 次不代表其一定在负权圈内。正确做法是从这个节点 $v$ 开始不断捯它的前驱，如果发现某个节点 $u$ 被访问了两遍，则说明 $u$ 一定在负权圈内，再根据 $u$ 去捯前驱调整负权圈。 图解 好像有几个地方标错了QAQ 凑合看吧 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlinetemplate &lt;typename T&gt; il T abs(T x) { return x &gt; 0 ? x : -x; }const int N = 110, M = N * N &lt;&lt; 1, INF = 0x3f3f3f3f;struct coor { int x, y, z;} a[N], b[N];struct node { int u, v, w, f, next;} e[M];int h[N &lt;&lt; 1], tot = 0;bool vis[N &lt;&lt; 1];int n, m, s, t;int cnt[N &lt;&lt; 1], pre[N &lt;&lt; 1];il void add(int u, int v, int w, int f) { e[tot] = (node) {u, v, w, f, h[u]}; h[u] = tot++;}int bp[N][N], dis[N &lt;&lt; 1], p[N][N], occ[N];deque&lt;int&gt; q;bool cyc[N &lt;&lt; 1];il void check(int v) { do { cyc[v] = true; v = e[pre[v]].u; } while(!cyc[v]); int u = v; do { --e[pre[v]].w; ++e[pre[v]^1].w; v = e[pre[v]].u; } while(u != v); for(int i=1; i&lt;=m; ++i) for(int j = h[n+i]; j != -1; j = e[j].next) if(e[j].v != t) bp[e[j].v][i] = e[j].w; printf(&quot;SUBOPTIMAL\\n&quot;); for(int i=1; i&lt;=n; ++i) { for(int j=1; j&lt;=m; ++j) printf(&quot;%d &quot;, bp[i][j]); printf(&quot;\\n&quot;); }}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z); for(int i=1; i&lt;=m; ++i) scanf(&quot;%d%d%d&quot;, &amp;b[i].x, &amp;b[i].y, &amp;b[i].z); for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) scanf(&quot;%d&quot;, &amp;p[i][j]), occ[j] += p[i][j]; memset(h, -1, sizeof h); s = 0, t = n+m+1; for(int i=1; i&lt;=n; ++i) { add(s, i, a[i].z, 0); add(i, s, 0, 0); } for(int i=1; i&lt;=n; ++i) { for(int j=1; j&lt;=m; ++j) { int f = abs(a[i].x - b[j].x) + abs(a[i].y - b[j].y) + 1; add(i, n+j, INF, f); add(n+j, i, p[i][j], -f); } } for(int i=1; i&lt;=m; ++i) { add(n+i, t, b[i].z - occ[i], 0); add(t, n+i, occ[i], 0); } memset(dis, 0x3f, sizeof dis); q.push_front(s); vis[s] = true; ++cnt[s]; dis[s] = 0; while(!q.empty()) { int u = q.front(); q.pop_front(); vis[u] = false; for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and dis[v] &gt; dis[u] + e[i].f) { pre[v] = i; dis[v] = dis[u] + e[i].f; if(!vis[v]) { if(!q.empty() and dis[v] &gt;= dis[q.front()]) q.push_back(v); else q.push_front(v); vis[v] = true; ++cnt[v]; if(cnt[v] == t+1) { check(v); return 0; } } } } } printf(&quot;OPTIMAL\\n&quot;); return 0;} 算法证明中的图片引自 Sengxian’s Blog。","link":"/network-flow-deloop/"},{"title":"网络流：最大流","text":"EK 增广路方法是很多网络流算法的基础。其思路是每次找出一条从源到汇的能够增加流的路径，调整流值和残留网络 ，直到没有增广路为止。 EK 算法就是不断的找最短路，找的方法就是每次找一条边数最少的增广（即最短路径增广）。 最多要增广多少次？ 可以证明，最多 O(VE)​ 次增广，可以达到最大流。 如何找到一条增广路？ 先明确什么是增广路。增广路是一条从s到t的路径，路径上每条边残留容量都为正。把残留容量为正的边设为可行的边，那么我们就可以用简单的 BFS 得到边数最少的增广路。 如何增广？ BFS 得到增广路之后，这条增广路能够增广的流值，是路径上最小残留容量边决定的。把这个最小残留容量 MinCap 值加到最大流值 Flow 上，同时路径上每条边的残留容量值减去 MinCap；最后，路径上每条边的反向边残留容量值要加上 MinCap。这样每次增广的复杂度为 O(E)，总复杂度就是 O(VE2)。事实上，大多数网络的增广次数很少，因此 EK 算法能处理绝大多数问题。 为什么增广路径上每条边的反向边残留容量值要加上 MinCap？ 残留网络 = 容量网络 - 流量网络 容量网络不改变的情况下，由于增广好比给增广路上通了一条流，路径上所有边流量加 MinCap 之后，相对应的残留网络就发生相反的改变。因为建立了反向边，如果这条路径不是最理想的就会回流，避免了这种情况。这是网络流里很重要的一点。 图例 Dinic BFS 分层 与EK一样，我们仍要通过 bfs 来判断图中是否还存在增广路，但是 Dinic 算法里的 bfs 略有不同。这次，我们不用记录路径，而是给每一个点分层，对于任意点 i，从 s 到 i 每多走过一个点，就让层数多 1。一次分层后可以找到多条增广路，从而提高效率。 分完层效果是这样的：（蓝色的数字是每个点层数） DFS 增广 有了每个点的层数编号，对任意点 u 到点 d 的路径如果有 $dep[d]=dep[u]+1$，我们就可以判断该路径在增广路上。 比如说，我们首先找 s-&gt;1-&gt;4-&gt;t： 第二次，s-&gt;1-&gt;5-&gt;t： 第三次，s-&gt;1-&gt;3-&gt;t： 还有第四条，s-&gt;2-&gt;3-&gt;t： PS：Dinic 在跑二分图匹配时比匈牙利快很多。 P3376 网络最大流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 11000, M = 110000;const int INF = 0x7fffffff;struct node { int u, v, w, next;} e[M &lt;&lt; 1];int cur[N], h[N], tot;int dfn[N], ans, n, m, s, t;void add(int u, int v, int w) { e[tot] = node({u, v, w, h[u]}); cur[u] = h[u] = tot++;}bool bfs() { memcpy(cur, h, sizeof cur); memset(dfn, 0, sizeof dfn); queue&lt;int&gt; q; dfn[s] = 1; q.push(s); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = h[u]; i != -1; i = e[i].next) { int v = e[i].v; if(e[i].w and !dfn[v]) { dfn[v] = dfn[u] + 1; q.push(v); if(v == t) return true; } } } return false;}int dfs(int u, int low) { if(u == t) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next) { int v = e[i].v; cur[u] = i; if(e[i].w and dfn[v] == dfn[u] + 1) { int f = dfs(v, min(w, e[i].w)); if(f == 0) dfn[v] = 0; e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; } } return low - w;}void dinic() { int flow; while(bfs()) while(flow = dfs(s, INF)) ans += flow;}int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); memset(h, -1, sizeof h); for(int i=1, u, v, w; i&lt;=m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, 0); } dinic(); printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/maximum-flow/"},{"title":"还在用 STL 排序？","text":"使用 C 库函数 很多人都不知道的是，其实 C 语言也是自带排序函数的，就是位于 &lt;stdlib.h&gt; 库中的 qsort 函数声明： 1void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) 其中 base - 指向要排序的数组的第一个元素的指针 nitems - base 指向的数组中元素的个数 size - 数组中每个元素的大小（以字节为单位） compar - 用来比较两个元素的函数 与 &lt;algorithm&gt; 中的 std::sort 略有差异，尤其是在 compar 函数的定义上。 其形参必须是 const void* 型（可以理解为，在 compar 函数内部会将 const void* 型转换成实际类型）。 如果返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面； 如果返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定； 如果返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。 在 C11 标准中，新增了另一个排序函数 qsort_s ，但在无编译开关的情况下无法使用。 另外，虽然它的名字叫 qsort ，但目前还没有任何一个 C 标准规定其必须通过快排实现（） 实测在整数排序下，效率与 STL 相差无几，都在 140ms/1.20MB 左右。 Code © : 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;const int N = 1e5 + 10;int cmp(const void *a, const void *b) { return (*(int*)a - *(int*)b);}int main() { int n, i, a[N]; scanf(&quot;%d&quot;, &amp;n); for (i=0; i&lt;n; ++i) scanf(&quot;%d&quot;, a+i); qsort(a, n, sizeof(int), cmp); for (i=0; i&lt;n-1; ++i) printf(&quot;%d &quot;, a[i]); printf(&quot;%d\\n&quot;, a[n-1]); return 0;} 使用 PB_DS PB_DS，又称平板电视，是一个冷门但功能极为强大的 GNU-cpp 扩展库，但在 OI 中（尤其是省选以下）极少用到。 该库中提供了大量数据结构（虽然不开O2的话几乎都会T掉），以树形结构为主，拿出来基本个个都可以排序 堆： （未开 O2，248ms/5.23MB ） 1234567891011121314#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;using namespace __gnu_pbds;__gnu_pbds::priority_queue &lt; int, greater&lt;int&gt;, pairing_heap_tag &gt; q;int n;int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=0, a; i&lt;n; ++i) scanf(&quot;%d&quot;, &amp;a), q.push(a); for(int i=0; i&lt;n; ++i) printf(&quot;%d &quot;, q.top()), q.pop(); return 0;} 由于 pb_ds 中的 tree 相当于 set 而不是 multiset ，因此比手写快排还长，不再展示。","link":"/still-using-stl-sort/"},{"title":"邂逅","text":"汪曾祺 船开了一会，大家坐定下来。理理包箧，接起刚才中断的思绪，回忆正在进行中的事务已过的一段的若干细节，想一想下一步骤可能发生的情形；没有目的的擒纵一些飘忽意象； 漫然看着窗外江水； 接过茶房递上来的手巾擦脸；掀开壶盖让茶房沏茶； 口袋里摸出一张什么字条，看一看，又搁了回去；抽烟，打盹；看报；尝味着透人脏腑的机器的浑沉的震颤，——震得身体里的水起了波纹。一小圈， 小圈；暗数着身下靠背椅的一根一根木条；什么也不干，听而不闻，视而不见，近乎是虚设的&quot;在&quot;那里；观察，感觉，思索着这些，……各种生活式样摆设在船舱座椅上，展放出来；若真实，又若空幻，各自为政，没有章法，然而为一种什么东西范围概括起来，赋之以相同的一点颜色。——那也许是&quot;生活&quot;本身。在现在，即使&quot;过江&quot;，大家同在一条&quot;船&quot;上。 在分割了的空间之中，在相忘于江湖的漠然之中，他被发现了，象从一棵树下过，忽然而发现了这里有一棵树。他是什么时候进来的呢？他一定是刚刚进来。虽没有人注视着舱门如何进来了一个人，然而全舱都已经意识到他.在他由动之静，迈步之间有停止之意而终于果然站立下来的时候.他的进来完全成为了一个事实。象接到了一个通知似的，你向他看。 你觉得若有所见了。 活在世上，你好像随时都在期待着，期待着有什么可以看看的事。有时你疲疲困困，你的心休息，你的生命匍伏着象是一条假寐的狗，而一到有什么事情来了，你醒豁过来，白日里闪来了清晨。 常常也是一涉即过，清新的后面是沉滞，像一缕风。 他停立在两个舱门之间的过道当中，正好是大家都放弃而又为大家所共有的一个自由地带。一一一他为什么不坐，有的是空座位。一一一他不准备坐，没有坐的意思，他没有从这边到那边看看，他不是在挑选哪一张椅子比较舒服。他好像有所等待的样子。——动人的是他的等待么？ 他脉脉的站在那里。在等待中总是有一种孤危无助的神情的，然而他不放纵自己的情绪，不强迫人怜恤注意他。他意态悠远，肤体清和，目色沉静，不纷乱，没有一点焦躁不安，没有忍耐。——你疑心他也许并不等待着什么，只是他的神情且像在等待着什么似的而已。 他整洁，漂亮，颀长，而且非常的文雅，身体的态度，可欣可感，都好极了。难得的，遇到这样一个人。 哦，一一他是个瞎子，一一他来卖唱，一一他是等着这个女孩子进来，那是他女儿，他等待着茶房沏了茶打了手巾出去， (茶房从他面前经过时他略为往后退了退，让他过去， )等着人定，等着一个适当的机会开口。 她本来在那里的？是等在舱门外头？她也进来得正是时候，象她父亲一样，没有人说得出她怎么进来的，而她已经在那里了，毫不突兀，那么自然，那么恰到好处，刚刚在点儿上。他们永远找得到那个千载一时的成熟的机缘，一点不费力。他已经又在许多纷纭褶曲的心绪的空隙间插进他的声音，不知道什么时候，说了句简单的开场白，唱下去了。没有跳踉呼喝，振足拍手，没有给任何旅客一点惊动，一点剌激，仿佛一切都预先安排，这支曲子本然的已经伏在那里，应当有的，而且简直不可或缺，不是改变，是完成，不是反，是正；不是二，是一。…… 一切有点出乎意外。 我高兴我已经十年不经过这一带，十年没有坐这种过江的班轮了，我才不认识他。如果我已经知道他，情形会不会不同？一切令我欣感的印象会不会存在？——也不，总有个第一次的。在我设想他是一种什么人的时候我没有想出，没有想到他是卖唱的。他的职业特征并不明显，不是一眼可见，也许我全心倾注在他的另一种气质，而这种气质不是，或不全是生成于他的职业，我还没有兴趣也没有时间来判断，甚至没想他是何以为生的？如果我起初就发现——为什么刚才没有， 直到他举出来轻轻拍击的时候我才发现他手里有一副檀板呢？ 从前这一带轮船上两个卖唱的，一个鸦片鬼，瘦极了，嗓子哑得简直发不出声音，吨吨的如敲破竹子：一个女人，又黑又肥，满脸麻子。——他样子不象是卖唱的？其实要说，也象，——卖唱的样子是一个什么样子呢？ ——他不满身是那种气味。腐烂了的果子气味才更强烈，他还完完整整，好好的。他样子真是好极了。这是他女儿，没有问题。他唱的什么？ 有一回，那年冬天特别冷，雪下得大极了，河封住了，船没法子开，我因事须赶回家去，只有起早走，过湖，湖都冻得实实的，船没法子过去，冰面上倒能走。大风中结了几个伴在茫茫一片冰上走， 心里感动极了，抽一枝烟划一枝洋火好费事！一个人划洋火成了全队人的事情。……(我掏了一枝烟抽， )远远看见那只轮船冻在湖边，一点活意都没有，被遗弃在那儿，红的，黑的，都是可怜的颜色。我们坐过它很多次，天不这么冷，现在我们就要坐它的。忽然想起那两个卖唱的。他们在哪里了呢，雪下了这么多天了。沿河堤有许多小客栈，本来没有什么人知道的，你想不到有那么多，都有了生意了，近年下，起早走路的客人多，都有事。他们大概可以一站一站的赶，十多里，三三十里，赶到小客栈里给客人解闷去。他们多半会这么着的。封了河不是第一次，路真不好走。一个人走起来更苦，他们其实可以结成伴。一一哈，他们可以结婚！ 这我想过不止一次了，颇有为他们做媒之意。“结婚”，哈！但是他们一起过日子很不错，同是天涯沦落人，彼此有个照应。可是怪，同在一路，同在一条船上卖唱，他们好像并没有同类意识，见了面没有看他们招呼过，谈话中也未见彼此提起过，简直不认识似的。不会，认识是当然认识的。利害相妨，同行妒忌，未必罢，他们之间没有竞争。 男的鸦片抽成了精，没有几年好活了，但是他机灵，活络得多，也皮赖，一定得的钱较多。女的可以送他葬，到时候有个人哭他，买一陌纸钱烧给他。——你是不是想男的可以戒烟，戒了烟身体好起来，不喝酒，不赌钱，做两件新蓝布大褂，成个家，立个业，好好过日于，同偕到老？小孩子！小孩子！一一不，就是在个土地庙神龛鬼脚下安身也行，总有一点温暖的。——说不定他们还会生个孩子。 现在，他们一定结伴而行了，在大风雪中挨着冻饿，挨着鸦片烟，十里二十里的往前赶一家一家的小客枪了。小客栈里咸菜辣椒煮小鲫鱼一盘一盘的冒着热气，冒着香，锅里一锅白米饭。——今天米价是多少？一百八？ 下来一半(路程)了罢？天气好，风平浪静。 他们不会结婚，从来没有想到这个上头去过。这个鸦片鬼不需要女人，这个女人没有人要。别看这个鸦片鬼，他要也才不要这个女人！他骨干肢体毁蚀了，走了样，可是本来还不错的，还起原来很有股子潇洒劲儿。那样的身段是能欣赏女人的身段，懂得风情的身段。这个女人没有女人味儿！鸦片鬼老是一段&quot;活捉张三郎&quot;，挤眉瞪眼，伸头缩脖子，夸张，恶俗，猥亵，下流极了。没法子。他要抽鸦片。可是要是没法子不听还是宁可听他罢。他聪明，他用两枝竹筷子丁丁当当敲一个青花五寸盘子，敲得可是神极了，溅跳洒泼，快慢自如，有声有势，活的一样。他很有点才气，适于干这一行的，他懂。那个黑麻子女人拖把胡琴唱&quot;你把那，冤枉事勒欧欧欧欧欧欧……&quot;实在不敢领教。或者，更坏，不知哪里学来的一段黑风帕。这个该死的蠢女人！ 他们秉赋各异，玩意儿不同，凑不到一起去。 真不大像是——这女孩子配不上他父亲，一一还不错，不算难看，气派好，庄静稳重，不轻浮，现在她接她父亲的口唱了。 有熟人懂得各种曲子的要问问他，他们唱的这种叫什么调子。这其实应当说是一种戏文，用的是代言体，上台彩扮大概不成罢，声调过于逶迤曼长了。虽是两人递接着唱，但并非对口，唱了半天，仍是一个人口吻。全是抒情，没有情节。事实自《红楼梦》敷衍而出。黛玉委委屈屈向宝玉倾诉心事。每一段末尾长呼&quot;我的宝哥哥儿来&quot;。可是唱得含蓄低宛，居然并不觉得刺耳，颇有人细细的听，凝着神，安安静静，脸上恻恻的，身体各部松弛解放下来，气息深深，偶然舒一舒胸，长长透一 口气，纸烟灰烧出长段，跌落在衣襟上。碎了，这才霍然如梦如醒。有人低语： “他的眼睛——” “瞎子，雀盲。” “哦一一” 进门站下来的时候就觉得，他的眼睛有点特别，空空落落，不大有光影，不流动。可是他女儿没有进来之先他向舱门外望了一眼，他扬头，样子不象瞎眼的人。瞎眼人脸上都有一种焦急愤恨。眼角嘴角大都要变形的，雀盲尤其自卑，扭扭捏捏。藏藏躲躲，他没有，他脸上恬静平和极了。他应当是生下来就双眼不通，不会是半途上暗的。 女孩子唱的还不如他父亲。一一听是还可以听。 这段曲子本来跟多数民间流行曲子一样，除了感伤，剩下就没有什么东西了，可是他唱得感伤也感伤，一点都不厉害。唱得深极了，远极了，素雅极了，醇极了，细运轻输，不枝不蔓，舒服极了。他唱的时候没有一处摇摆动晃，脸上都不大变样子，只有眉眼间略略有点凄愁。像是在深深思念之中，不像在唱。——啊不，是在唱，他全身都在低唱，没有那一处是散涣叛离的，他唱得真低，然而不枯，不弱，声声匀调，字字透达，听得清楚分明极了，每一句，轻轻的拍一板，一段，连拍三四下。女儿所唱，格韵虽较一般为高，但是听起来薄，松，含糊，懒懒的，她是受她父亲的影响，摹仿父亲而没有其精华神髓，她尽量压减洗涤她的嗓音里的野性和俗气，可是她的生命不能与那个形式蕴合，她年纪究竟轻，而且性格不够。她不能沉缅，她心不专，她唱，她自己不听。她没有想跳出这个生活，她是个老实孩子。老实孩子，但不是没有一些片片段段的事实足以教她分心，教她不能全神贯注，入乎其中。 她有十七八岁了罢？有啰，可能还要大一点，样子还不难看。脸宽宽的，鼻子有点塌，眼睛分得很开。撩了一点脂粉，胭脂颜色不好，桃红的。头发修得很齐，梳得光光的，稍为平板了一点，前面一个发卷于是显得像个筒子，跟后面头发有点不能相连属，腰身粗粗的，眼前还不要紧，千万不能再胖。站着能够稳稳的，腿分得不太开，脚不乱动，上身不扭，然而不僵，就算难得的了。她的态度救了她的相貌不少。她神色间有点疲倦，一种心理的疲倦。一一她有了人家没有？一件黑底小红碎花布棉袍，青鞋，线袜，干干净净。——又是父亲了，他们轮着来。她唱得比较少，大概是父亲唱两段，女儿唱一段。 天气真好，简直没有什么风。船行得稳极了。 谁把茶壶跟茶杯挨近着放，船震，轻轻的碜出瓷的声音，细细的，像个金铃子叫。——嗳呀，叫得有点烦人！心里不舒服，觉得恶心。——好了，平息了，心上一点霉斑。——让它叫去罢，不去管它。 是不是这么分的，一个两段，一个一段？这么分法有什么理由？要是倒过来，一一现在这么听着挺合适，要是女儿唱两段父亲唱一段呢。这个布局想象得出么？两种花色编结起来的连续花边，两朵蓝的，间有一朵绿的， (紫的，黄的，银红的，杂色的， )如果改成两朵绿的一朵蓝的呢？……什么蓝的绿的，不像！干什么用比喻呢，比喻不伦！一一有没有女儿两段父亲一段的时候？ ——分开了唱四段比连着唱三段省力， 两个人比一个人唱好，有变化，不单调，起来复舒卷感，象花边，——比喻是个陷井，还是摔不开！一一接口接得真好，一点不露痕迹，没有夺占，没有缝隙，水流云驻，叶落花开，相契莫逆，自自在在，当他末一声的有余将尽，她的第一字恰恰出口，不颔首，不送目，不轻轻咳嗽，看不出一点点暗示和预备的动作。 他们并排站着，稍有一段距离。他们是父女，是师徒，也还是同伴。她唱得比较少，可是并不就是附属陪衬。她并不多余，在她唱的时候她也是独当一面，她有她的机会，他并不完全笼罩了她，他们之间有的是平等，合作时不可少的平等。这种平等不是力求，故不露暴，于是更圆满了。——真的平等不包含争取。父亲唱的时候女儿闲着，她手里没有一样东西，可是她能那么安详！她垂手直身，大方窈窕.有时稍稍回首，看她父亲一眼，看他的侧面，他的手。一一她脚下不动。 他自己唱的时候他拍板，女儿唱的时候他为女儿拍板，他从头没有离开过曲子一步。他为女儿拍板时也跟为自己拍板时一样，好像他女儿唱的时候有两起声音，一起直接散出去，一起流过他，再出去。不，这两条路亦分亦合，还有一条路，不管是他和她所发的声音都似乎不是从这里，不是由这两个人，不是在我们眼前这个方寸之地传来的，不复是一个现实，这两个声音本身已经连成一个单位。——不是连成，本是一体，如藕于花，如花于镜，无所凭借，亦无落著，在虚空中，在天地水土之间。…… 女孩子眼睛里看见什么了？一个客人袖子带翻了一只茶杯，残茶流出来，渐成一线，伸过去，伸过去，快要到那个纸包了，一一纸包里是什么东西？ ——嘻，好了，桌子有一条缝，茶透到缝里去了一一还没有，——还没有一一滴下来了！这种茶杯底子太小，不稳，轻轻一偏就倒了。她一边看，一边唱，唱完了，还在看，不知是不是觉得有人看出了，有点不好意思，微低了头。面色肃然。一一有人悄悄的把放在桌上的香烟火蜡放回口袋里，快到了罢？对岸山浅浅的一抹。他唱完了这一段大概还有一段，由他开头，也由他收尾。 完了，可是这次好像只有一段？女儿走下来收钱，他还是等在那儿。他收起檀板，敛手垂袖而立，温文恭谨，含情脉脉，跟进来时候一样。 他样子真好极了，人高高的，各部分都称配，均衡，可是并不伟岸，周身一种说不出来的优雅高贵。稍稍有点衰弱，还好，还看不出有病苦的痕迹。总有五十岁左右了。……今天是……十三，过了年才这么几天，风吹着已经似乎不同了。——他是理了发过的年罢，发根长短正合适。梳得妥妥贴贴，大大方方。共发还看不出白的。——他不能自己修脸罢？ 也还好，并不惨厉，而且稍为有点阴翳于他正相宜，这是他的本来面目，太光滑了就不大象他了。他脸上轮廓清晰而固定，不易为光暗影响改变。手指白白皙皙，指甲修得齐齐的。一一一干净极了！一眼看去就觉得他的干净。可是干净得近人情，干净得教人舒服，不萧索，不干燥，不冷，不那么兢兢冀冀，时刻提防，觉得到处都脏，碰不得似的。一件灰色棉袍，剪裁得合身极了。布的。——看上去料子像很好？一一是布的，不单是袍子，里面衬的每一件衣裤也一定都舒舒齐齐，不破，不脏，没有气味，不窝囊着，不扯起来，口袋纽子都不残缺，一件套着一件，一层投着一层，袖口一样长短，领子差不多高低，边对边，缝对缝。……还很新，是去年冬天做的。——袍子似乎太厚了一程，有点臃肿，减少了他的挺拔。一一不，你看他的腮，他真该穿得暖些啊。他的胸，他的背，他的腰肋，都暖洋洋的，他全身正在领受着一重丰厚的暖意， ——一脉近于叹息的柔情在他的脸上。 她顺着次序走过个一个旅客，不说一句话，伸出她的手，坦率，无邪，不局促，不忸怩，不争多较少，不泼辣，不纠缠，规规矩矩老老实实。一一这女孩子实在不怎样好看。她鼻子底下有颗痣。都给的。——有一两个，她没有走近，看样子他也许没有，然而她态度中并无轻蔑之意，不让人不安，有的脸背着，或低头扣好皮箱的锁，她轻轻在袖子上拉一拉。一一真怪，这样一个动作中居然都包含一点卖弄风情，没有一点冒昧。被拉的并不嗔怪，不声不响，掏出钱来给她。——有人看着他，他脸一红，想分辩，我不是——是的，你忙着有事，不是规避，谁说你小器的呢，瞧瞧你这样的人，像么，一一于是两人脸上似笑非笑了一下，眼光各向一个方向挪去。——这两个人说不定有机会认识，他们老早谈过话了。——在操堂里，饭馆里，街上，隔着干日子，碰着了，他们有招呼之意，可是匆匆错过了，回来，也许他们会想，这个人好面熟，哪里见过的？一一大概想不出究竟是哪里见过的了罢？——人应当记日记。——给的钱上下都差不多，这也好像有个行情，有个适当得体的数目，切合自己生活，也不触犯整个社会。这玩意儿真不易，够学的！过到老，学不了，学的就是这种东西？这是老练，是人生经验，是贾宝玉反对的学问文章。我的老天爷！——这一位，没有零的，掏出来一张两万关金券， 一时张皇极了，没有主意，连忙往她手里一搁，心直跳，转过身来伏在船窗上看江水，他简直像大街上摔了一大跤。——哎，别介，没有关系。——差不多全给的，然而送给舱里任何一位一定没有人要。一点不是一个可羡慕的数目。一一上海正发行房屋奖券，过里头一定有人买的，就快开奖了 ，你见过设计图样么？ ——从前用铜子，主唱的多用一个小藤册子接钱，投进去磬磬的响。 都收了，她回去，走近她父亲，——她第一次靠着她父亲，伸一个手给他，拉着他，她在前，他在后，一步一步走出去了 。他是个瞎子。¬——我这才真正的觉得他瞎。看到他眼睛看不见，十分的动了心。他的一切声容动静都归纳摄收在这最后的一瞥，造成一个印象，完足，简赅，具体。他走了，可是印象留下来。——他们是父女，无条件的，永远的，没有一丝缝隙的亲骨肉。不，她简直是他的母亲啊！他们走了。…… “他们一天能得多少钱？” “也不多——轮渡一天来回才开几趟。夏天好，夏天晚上还有人叫到家里唱。” “那他们穿的？” “嗳——” 船平平稳稳的行进，太阳光照在船上，船在柔软的江水上。机器的震动均匀而有力，充满健康，充满自信。舱壁上几道水影的反光晃荡。船上安静极了，有秩序极了。——忽然乱起来，象一个灾难，一个麻袋挣裂了，滚出各种果实。一个脚夫象天神似的跳到舱里。——到了，下午两点钟。 一九四八年","link":"/xie-hou/"},{"title":"陌上","text":"多少次咫尺之隔的希望 却终是目送着的离开 最美好的时候（） ？ 多少次经意又不经意 自然而又矫情 踌躇在触手可及的门口 隔的是无限的冰凌 缓慢而痛彻心扉 冷漠而撕心裂肺 就算你冷若冰霜 就算残存的桥被时间的流冲淡 就算寒冰封冻了每一处角落 不再颤动 我 洇痕 就算悸动的心被死寂的水销毁 就算迟来的阳光等不到花开的日子 就算此时相望不相闻 溱与洧 方涣涣兮 明天 愿往来翕忽的鱼儿 离开涸辙的田野 愿熙熙攘攘的行人 离开郁孤台的障翳 愿逐月华 流照君 纵使过往的种种想要钦定了未来 纵使层迭的细沙似已磨灭了你我 （不甘、仗剑、人） 斩的 就是命运 纵使真的到达了最黑暗的时刻 纵使远方的洪流咆哮着向着未来 纵使湛蓝的天空里爱恨交盏 纵使 山无棱 如果再相遇 我想 陪你一起 飞过彷徨 看最初的一道光 凤凰于飞 覆照殷红 夕阳","link":"/mo-shang/"},{"title":"第三次写雪","text":"好多好多的雪，一片一片的，有大有小。 它们挤在空气里。 有时候风停了，它们盘旋一会儿，便无可抗拒地被拉向地心，覆在枯兀的树枝旁，盖在黑褐色的山丘上。 有时候风大了，它们集结成束，近乎平行地面地飞着。密密麻麻的细丝轻轻颤动，像填满罅隙的琴弦。 它们还是要落在地上，躺在毫无新意的地方。规则的六角形，在触到固体的刹那，便化为了飞灰。它们在严冬的苍白的太阳里升腾，变成交叠的球团，又回到没有棱角的松仁。 我看到临别的雪花，恋恋不舍地吻着空气，像我所奢望的那样。","link":"/3rd-snow/"},{"title":"雪（精选集）","text":"连载小说 &amp; 概念 EP &amp; 随笔 系列一：连载小说 （主线剧情：星, 梦, 昙 → 未来 → 黎明之烬 → 涉江 &amp; 凝眉） 最新：凝眉 纪念初中时候的一段故事吧。顺便把这个系列收个尾。大概就结束了。 他和她坐在跑道边，说是要等着，等最后一片云霞沉寂在地平线下。时不时地，他们凑在对方的耳边，轻声低语；欢谑声里，沉沉的烟火灿烂着，像雪染成的白绫。风打在他和她的肩上。 一 星, 梦, 昙 Director 放下了望远镜，凝视着那隙天边的裂痕，在远方，缩成一团光影。在他的身后，几筒烟花飞向空中，绽出几点荧烁的火光。 时空的网交错在一起，织成了天上的星。 二 未来 我的视线依然投在远方。看着看着，我渐渐不明白有多少东西可以称得上是变化了。世界本来就没有形状。 三 黎明之烬 黑暗包围了你和高桥。你紧紧地牵着她的手，and so did she。你的眼前出现了一池水潭：那是世界的原点，也是世界的尽头。 四 涉江 她可能还没有想到过那样的一天，雪花浸满了每一个角落。空自，她守望着梦乡。 五 凝眉 时不时地，他们凑在对方的耳边，轻声低语；欢谑声里，沉沉的烟火灿烂着，像雪染成的白绫。 系列二：概念 EP 2022 全创作概念辑《湖水》 系列三：随笔 一 第三次写雪 它们在严冬的苍白的太阳里升腾，变成交叠的球团，又回到没有棱角的松仁。 我看到临别的雪花，恋恋不舍地吻着空气，像我所奢望的那样。 二 陌上 看最初的一道光 凤凰于飞 覆照殷红 夕阳","link":"/snow/"},{"title":"高级动态规划：区间、树形","text":"区间 DP P1880 [NOI1995]石子合并 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 220;int ans, dp[N][N], n, a[N], s[N];int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, a+i); s[i] = s[i-1] + a[i]; } for(int i=1; i&lt;=n; ++i) { s[i+n] = s[i+n-1] + a[i]; } memset(dp, 0x3f, sizeof dp); for(int i=1; i&lt;=2*n; ++i) dp[i][i] = 0; for(int l=2; l&lt;=n; ++l) { for(int i=1, j=l; j&lt;=2*n; ++i, ++j) { for(int k=i; k&lt;j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + s[j] - s[i-1]); } } } ans = 0x3f3f3f3f; for(int i=1; i&lt;=n; ++i) { //printf(&quot;%d &quot;, dp[i][i+n-1]); ans = min(ans, dp[i][i+n-1]); } printf(&quot;%d\\n&quot;, ans); memset(dp, 0, sizeof dp); for(int i=1; i&lt;=2*n; ++i) dp[i][i] = 0; for(int l=2; l&lt;=n; ++l) { for(int i=1, j=l; j&lt;=2*n; ++i, ++j) { for(int k=i; k&lt;j; ++k) { dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + s[j] - s[i-1]); } } } ans = 0; for(int i=1; i&lt;=n; ++i) { ans = max(ans, dp[i][i+n-1]); } printf(&quot;%d\\n&quot;, ans); return 0;} P1063 能量项链 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 220;int n, h[N], t[N], dp[N][N];int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;h[i]); h[i+n] = h[i]; } for(int i=1; i&lt;2*n; ++i) t[i] = h[i+1]; for(int l=2; l&lt;=n; ++l) { for(int i=1, j=l; j&lt;=2*n; ++i, ++j) { for(int k=i; k&lt;j; ++k) { dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + h[i] * t[k] * t[j]); } } } int ans = 0; for(int i=1; i&lt;=n; ++i) { ans = max(ans, dp[i][i+n-1]); } printf(&quot;%d\\n&quot;, ans); return 0;} P3146 [USACO16OPEN]248 G 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int n, dp[300][300], ans = 0;int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) { scanf(&quot;%d&quot;, &amp;dp[i][i]); } for(int l=2; l&lt;=n; ++l) { for(int i=1, j=l; j&lt;=n; ++i, ++j){ for(int k=i; k&lt;j; ++k) { if(dp[i][k] == dp[k+1][j]) dp[i][j] = max(dp[i][j], dp[i][k]+1); } ans = max(ans, dp[i][j]); } } printf(&quot;%d\\n&quot;, ans); return 0;} 树形 DP 树形DP三大问题：树的最大独立集 树的重心 树的最长路径 P1352 没有上司的舞会 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef vector&lt;int&gt;::iterator IT;const int N = 6e3 + 10;int fa[N]; vector&lt;int&gt; g[N];int n, r[N];inline int fin() { for(int i=1; i&lt;=n; ++i) if(!fa[i]) return i;}int f[N][2];// 0/1void dfs(int u) { f[u][0] = 0; f[u][1] = r[u]; for(IT it = g[u].begin(); it != g[u].end(); ++it) { dfs(*it); f[u][0] += max(f[*it][0], f[*it][1]); f[u][1] += f[*it][0]; }}int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, r+i); for(int i=1; i&lt;n; ++i) { int l, k; scanf(&quot;%d%d&quot;, &amp;l, &amp;k); fa[l] = k; g[k].push_back(l); } int rt = fin(); dfs(rt); printf(&quot;%d&quot;, max(f[rt][0], f[rt][1])); return 0;} P2014 [CTSC1997]选课 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 330;vector&lt;int&gt; g[N];int n, m; int dp[N][N];void dfs(int u) { for(vector&lt;int&gt;::iterator it = g[u].begin(); it != g[u].end(); it++) { dfs(*it); for(int j=m+1; j&gt;1; --j) { for(int k=0; k&lt;j; ++k) dp[u][j] = max(dp[u][j], dp[*it][k] + dp[u][j-k]); } }}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) { int k; scanf(&quot;%d%d&quot;, &amp;k, &amp;dp[i][1]); g[k].push_back(i); } dfs(0); printf(&quot;%d\\n&quot;, dp[0][m+1]); return 0;}","link":"/dp-series/"}],"tags":[{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"DFS","slug":"dfs","link":"/tags/dfs/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"小说","slug":"小说","link":"/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"图书馆","slug":"图书馆","link":"/tags/%E5%9B%BE%E4%B9%A6%E9%A6%86/"},{"name":"Hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Butterfly","slug":"butterfly","link":"/tags/butterfly/"},{"name":"Aplayer","slug":"aplayer","link":"/tags/aplayer/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"STL","slug":"stl","link":"/tags/stl/"},{"name":"码风","slug":"码风","link":"/tags/%E7%A0%81%E9%A3%8E/"},{"name":"Gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"PWA","slug":"pwa","link":"/tags/pwa/"},{"name":"应用程序","slug":"应用程序","link":"/tags/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"name":"部署","slug":"部署","link":"/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Vercel","slug":"vercel","link":"/tags/vercel/"},{"name":"SSH","slug":"ssh","link":"/tags/ssh/"},{"name":"GitHub","slug":"github","link":"/tags/github/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"匹配","slug":"匹配","link":"/tags/%E5%8C%B9%E9%85%8D/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"LCA","slug":"lca","link":"/tags/lca/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"DAG","slug":"dag","link":"/tags/dag/"},{"name":"尺取法","slug":"尺取法","link":"/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最小割","slug":"最小割","link":"/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"PB_DS","slug":"pb-ds","link":"/tags/pb-ds/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"小说 &amp; 随笔","slug":"hitokoto","link":"/categories/hitokoto/"},{"name":"算法","slug":"algorithm","link":"/categories/algorithm/"},{"name":"图书馆","slug":"图书馆","link":"/categories/%E5%9B%BE%E4%B9%A6%E9%A6%86/"},{"name":"未来","slug":"hitokoto/future","link":"/categories/hitokoto/future/"},{"name":"Hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"动态规划","slug":"algorithm/dp","link":"/categories/algorithm/dp/"},{"name":"数论","slug":"algorithm/数论","link":"/categories/algorithm/%E6%95%B0%E8%AE%BA/"},{"name":"陌上","slug":"hitokoto/陌上","link":"/categories/hitokoto/%E9%99%8C%E4%B8%8A/"},{"name":"网络流","slug":"algorithm/network-flow","link":"/categories/algorithm/network-flow/"}]}